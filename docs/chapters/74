<!DOCTYPE html>
<html lang="en">
  <head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156801664-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156801664-1');
</script>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="4.1.1 
    The Core of the Evaluator
  " />
    <title>
         4.1.1 
    The Core of the Evaluator
  
    </title>

    <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="FdIT/wtxVi/MzKbfq65lqRjtEim8cgutbFVs8sfoGD/JhKDEbBro+CaSG70FTCUOrI1kDVkQML2qMT0f5RApKg==" />

    <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata&display?swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Droid+Sans|Droid+Serif" rel="stylesheet">
    <link rel="stylesheet" media="all" href="../assets/application-f313219f7bd4d132a6fd02c8f84b86f62781f5d155b9681036fc6390c9f3d06c.css" />

   <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon-17dbf972938cc63d48794e3be2c66977e723014f9a9518097da971fb34202187.ico" />

<!--    <link rel="shortcut icon" type="image/png" href="/images/lambda.png" /> -->

    <!-- for support of progressive web app, see github README -->
    <link rel="manifest" href="../static/manifest.json">

    <script src="https://code.jquery.com/jquery-3.2.1.min.js" 
		     	  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
	          crossorigin="anonymous">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>
    
    <!-- <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script> -->
    <script type="text/javascript" 
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-AMS-MML_HTMLorMML-full">
    </script>
   <!--  <script type="text/javascript" 
      src="../MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full">
    </script> -->

    <script src="../assets/application-77eef7aa2695bed514b473158fa8f35a6ae4cb10c6e0f2ae8e2b485af0611d43.js"></script>

    <!-- Rendering inline LaTeX -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          jax: ["input/TeX","output/HTML-CSS"]
        }
      });
    </script>
    <!--<script src="/mathjax/MathJax.js?config=TeX-AMS_HTML-full.js" type="text/javascript"></script>-->
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js" type="text/javascript"></script>
    <![endif]-->
  </head>
  <body>

    
    <!-- support for progressive web app, see README -->
    <script>
      if ('serviceWorker' in navigator && !navigator.serviceWorker.controller) {
          navigator.serviceWorker.register("/sw.js").then(function(reg) {
              console.log("Service worker has been registered for scope: " + reg.scope);
          });
      }
    </script>

     <nav class="navbar navbar-expand-sm navbar-dark bg-dark fixed-top justify-content-between">
       <button id="btn" class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#nav-sidebar" aria-controls="nav-sidebar" aria-expanded="false" aria-label="Toggle navigation" title="navigation">
         <span class="navbar-toggler-icon"></span>
       </button>
       <span class="navbar-brand-short"><a title="Go back to front page" href="../index.html" class="gray">SICP &mdash; JS</a></span>
       <span class="navbar-brand-long" ><a title="Go back to front page" href="../index.html" class="gray">Structure and Interpretation
            of Computer Programs &mdash; JavaScript Adaptation</a></span>

       <!-- edit the search engine by visiting: 
	    https://cse.google.com/cse/setup/basic?cx=015760785273492757659:nc_tznrzlsg 
	       -->
       <form class="form-inline ml-auto" id="xxx">
         <div id="search-box">
	         <script>
	           (function() {
	               var cx = "015760785273492757659:nc_tznrzlsg";
	               var gcse = document.createElement("script");
	               gcse.type = "text/javascript";
	               gcse.async = true;
	               gcse.src = "https://cse.google.com/cse.js?cx=" + cx;
	               var s = document.getElementsByTagName("script")[0];
	               s.parentNode.insertBefore(gcse, s);
	           })();
	           window.onload = function()
	           { 
	               var searchBox =  document.getElementById("gsc-i-id1");
	               searchBox.placeholder="search web edition";
	               searchBox.title="search web edition"; 
	           }
	         </script>
	         <gcse:search></gcse:search>
         </div>
       </form>
       <span class="navbar-brand-short">
         &nbsp;
         &nbsp;
         <a href="https://sicp.comp.nus.edu.sg/source/" title="Go to the Source language(s) definition(s)" class="gray">S</a>
       </span>
       <span class="navbar-brand-long">
         &nbsp;
         &nbsp;
         <a href="https://sicp.comp.nus.edu.sg/source/" title="Go to the Source language(s) definition(s)" class="gray">Source</a>
       </span>
     </nav>
     
     <div class="container scroll">

       <div class="collapse" id="nav-sidebar" role="tablist" aria-multiselectable="true">
	 <!-- insert a dummy entry, to give one extra line of space -->
         <a class="navbar-brand" href="index.html">&nbsp;</a>
                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-122">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-122" aria-expanded="false" aria-controls="sidebar-collapse-122">
                    <a href="122">        Foreword    </a>
                  </span>
                </h5>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-123">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-123" aria-expanded="false" aria-controls="sidebar-collapse-123">
                    <a href="123">        Prefaces    </a>
                  </span>
                </h5>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-124">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-124" aria-expanded="false" aria-controls="sidebar-collapse-124">
                    <a href="124">Acknowledgments from Second Edition of SICP, 1996    </a>
                  </span>
                </h5>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-1">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-1" aria-expanded="true" aria-controls="sidebar-collapse-1">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-1" aria-expanded="true" aria-controls="sidebar-collapse-1">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="1">1        Building Abstractions with       Functions    </a>
                </h5>
              </div>
              <div id="sidebar-collapse-1" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-2">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-2" aria-expanded="true" aria-controls="sidebar-collapse-2">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-2" aria-expanded="true" aria-controls="sidebar-collapse-2">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="2">1.1  The Elements of Programming</a>
                </h5>
              </div>
              <div id="sidebar-collapse-2" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-3">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-3" aria-expanded="false" aria-controls="sidebar-collapse-3">
                    <a href="3">1.1.1  Expressions</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-4">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-4" aria-expanded="false" aria-controls="sidebar-collapse-4">
                    <a href="4">1.1.2  Naming and the Environment</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-5">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-5" aria-expanded="false" aria-controls="sidebar-collapse-5">
                    <a href="5">1.1.3            Evaluating          Operator Combinations        </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-6">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-6" aria-expanded="false" aria-controls="sidebar-collapse-6">
                    <a href="6">1.1.4            Functions        </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-7">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-7" aria-expanded="false" aria-controls="sidebar-collapse-7">
                    <a href="7">1.1.5            The Substitution Model for                                                 Function                              Application        </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-8">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-8" aria-expanded="false" aria-controls="sidebar-collapse-8">
                    <a href="8">1.1.6            Conditional Expressions and Predicates        </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-9">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-9" aria-expanded="false" aria-controls="sidebar-collapse-9">
                    <a href="9">1.1.7  Example: Square Roots by Newtons Method</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-10">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-10" aria-expanded="false" aria-controls="sidebar-collapse-10">
                    <a href="10">1.1.8                                                  Functions                                as Black-Box Abstractions        </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-11">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-11" aria-expanded="true" aria-controls="sidebar-collapse-11">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-11" aria-expanded="true" aria-controls="sidebar-collapse-11">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="11">1.2              Functions            and the Processes They Generate      </a>
                </h5>
              </div>
              <div id="sidebar-collapse-11" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-12">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-12" aria-expanded="false" aria-controls="sidebar-collapse-12">
                    <a href="12">1.2.1  Linear Recursion and Iteration</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-13">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-13" aria-expanded="false" aria-controls="sidebar-collapse-13">
                    <a href="13">1.2.2  Tree Recursion</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-14">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-14" aria-expanded="false" aria-controls="sidebar-collapse-14">
                    <a href="14">1.2.3  Orders of Growth</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-15">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-15" aria-expanded="false" aria-controls="sidebar-collapse-15">
                    <a href="15">1.2.4  Exponentiation</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-16">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-16" aria-expanded="false" aria-controls="sidebar-collapse-16">
                    <a href="16">1.2.5  Greatest Common Divisors</a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-17">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-17" aria-expanded="false" aria-controls="sidebar-collapse-17">
                    <a href="17">1.2.6  Example: Testing for Primality</a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-18">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-18" aria-expanded="true" aria-controls="sidebar-collapse-18">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-18" aria-expanded="true" aria-controls="sidebar-collapse-18">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="18">1.3          Formulating Abstractions with Higher-Order         Functions      </a>
                </h5>
              </div>
              <div id="sidebar-collapse-18" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-19">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-19" aria-expanded="false" aria-controls="sidebar-collapse-19">
                    <a href="19">1.3.1            Functions          as Arguments        </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-20">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-20" aria-expanded="false" aria-controls="sidebar-collapse-20">
                    <a href="20">1.3.2            Function Definition Expressions          </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-21">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-21" aria-expanded="false" aria-controls="sidebar-collapse-21">
                    <a href="21">1.3.3              Functions            as General Methods          </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-22">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-22" aria-expanded="false" aria-controls="sidebar-collapse-22">
                    <a href="22">1.3.4      Functions    as Returned Values  </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>

                </div>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-23">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-23" aria-expanded="true" aria-controls="sidebar-collapse-23">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-23" aria-expanded="true" aria-controls="sidebar-collapse-23">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="23">2  Building Abstractions with Data</a>
                </h5>
              </div>
              <div id="sidebar-collapse-23" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-24">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-24" aria-expanded="true" aria-controls="sidebar-collapse-24">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-24" aria-expanded="true" aria-controls="sidebar-collapse-24">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="24">2.1  Introduction to Data Abstraction</a>
                </h5>
              </div>
              <div id="sidebar-collapse-24" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-25">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-25" aria-expanded="false" aria-controls="sidebar-collapse-25">
                    <a href="25">2.1.1      Example: Arithmetic Operations for Rational Numbers  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-26">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-26" aria-expanded="false" aria-controls="sidebar-collapse-26">
                    <a href="26">2.1.2          Abstraction Barriers      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-27">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-27" aria-expanded="false" aria-controls="sidebar-collapse-27">
                    <a href="27">2.1.3          What Is Meant by Data?      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-28">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-28" aria-expanded="false" aria-controls="sidebar-collapse-28">
                    <a href="28">2.1.4          Extended Exercise: Interval Arithmetic      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-29">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-29" aria-expanded="true" aria-controls="sidebar-collapse-29">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-29" aria-expanded="true" aria-controls="sidebar-collapse-29">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="29">2.2  Hierarchical Data and the Closure Property</a>
                </h5>
              </div>
              <div id="sidebar-collapse-29" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-30">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-30" aria-expanded="false" aria-controls="sidebar-collapse-30">
                    <a href="30">2.2.1          Representing Sequences      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-31">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-31" aria-expanded="false" aria-controls="sidebar-collapse-31">
                    <a href="31">2.2.2          Hierarchical Structures      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-32">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-32" aria-expanded="false" aria-controls="sidebar-collapse-32">
                    <a href="32">2.2.3          Sequences as Conventional Interfaces      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-33">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-33" aria-expanded="false" aria-controls="sidebar-collapse-33">
                    <a href="33">2.2.4          Example: A Picture Language      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-34">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-34" aria-expanded="true" aria-controls="sidebar-collapse-34">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-34" aria-expanded="true" aria-controls="sidebar-collapse-34">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="34">2.3  Symbolic Data</a>
                </h5>
              </div>
              <div id="sidebar-collapse-34" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-35">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-35" aria-expanded="false" aria-controls="sidebar-collapse-35">
                    <a href="35">2.3.1          Strings      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-36">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-36" aria-expanded="false" aria-controls="sidebar-collapse-36">
                    <a href="36">2.3.2          Example: Symbolic Differentiation      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-37">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-37" aria-expanded="false" aria-controls="sidebar-collapse-37">
                    <a href="37">2.3.3          Example: Representing Sets      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-38">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-38" aria-expanded="false" aria-controls="sidebar-collapse-38">
                    <a href="38">2.3.4          Example: Huffman Encoding Trees      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-39">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-39" aria-expanded="true" aria-controls="sidebar-collapse-39">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-39" aria-expanded="true" aria-controls="sidebar-collapse-39">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="39">2.4  Multiple Representations for Abstract Data</a>
                </h5>
              </div>
              <div id="sidebar-collapse-39" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-40">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-40" aria-expanded="false" aria-controls="sidebar-collapse-40">
                    <a href="40">2.4.1          Representations for Complex Numbers      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-41">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-41" aria-expanded="false" aria-controls="sidebar-collapse-41">
                    <a href="41">2.4.2          Tagged data      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-42">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-42" aria-expanded="false" aria-controls="sidebar-collapse-42">
                    <a href="42">2.4.3          Data-Directed Programming and Additivity      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-43">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-43" aria-expanded="true" aria-controls="sidebar-collapse-43">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-43" aria-expanded="true" aria-controls="sidebar-collapse-43">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="43">2.5  Systems with Generic Operations</a>
                </h5>
              </div>
              <div id="sidebar-collapse-43" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-44">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-44" aria-expanded="false" aria-controls="sidebar-collapse-44">
                    <a href="44">2.5.1          Generic Arithmetic Operations      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-45">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-45" aria-expanded="false" aria-controls="sidebar-collapse-45">
                    <a href="45">2.5.2          Combining Data of Different Types      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-46">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-46" aria-expanded="false" aria-controls="sidebar-collapse-46">
                    <a href="46">2.5.3          Example: Symbolic Algebra      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>

                </div>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-47">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-47" aria-expanded="true" aria-controls="sidebar-collapse-47">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-47" aria-expanded="true" aria-controls="sidebar-collapse-47">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="47">3  Modularity, Objects, and State</a>
                </h5>
              </div>
              <div id="sidebar-collapse-47" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-48">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-48" aria-expanded="true" aria-controls="sidebar-collapse-48">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-48" aria-expanded="true" aria-controls="sidebar-collapse-48">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="48">3.1  Assignment and Local State</a>
                </h5>
              </div>
              <div id="sidebar-collapse-48" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-49">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-49" aria-expanded="false" aria-controls="sidebar-collapse-49">
                    <a href="49">3.1.1          Local State Variables      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-50">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-50" aria-expanded="false" aria-controls="sidebar-collapse-50">
                    <a href="50">3.1.2          The Benefits of Introducing Assignment      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-51">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-51" aria-expanded="false" aria-controls="sidebar-collapse-51">
                    <a href="51">3.1.3          The Costs of Introducing Assignment      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-52">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-52" aria-expanded="true" aria-controls="sidebar-collapse-52">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-52" aria-expanded="true" aria-controls="sidebar-collapse-52">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="52">3.2  The Environment Model of Evaluation</a>
                </h5>
              </div>
              <div id="sidebar-collapse-52" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-53">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-53" aria-expanded="false" aria-controls="sidebar-collapse-53">
                    <a href="53">3.2.1          The Rules for Evaluation      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-54">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-54" aria-expanded="false" aria-controls="sidebar-collapse-54">
                    <a href="54">3.2.2          Applying Simple        Functions      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-55">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-55" aria-expanded="false" aria-controls="sidebar-collapse-55">
                    <a href="55">3.2.3          Frames as the Repository of Local State      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-56">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-56" aria-expanded="false" aria-controls="sidebar-collapse-56">
                    <a href="56">3.2.4          Internal Definitions      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-57">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-57" aria-expanded="true" aria-controls="sidebar-collapse-57">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-57" aria-expanded="true" aria-controls="sidebar-collapse-57">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="57">3.3  Modeling with Mutable Data</a>
                </h5>
              </div>
              <div id="sidebar-collapse-57" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-58">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-58" aria-expanded="false" aria-controls="sidebar-collapse-58">
                    <a href="58">3.3.1          Mutable List Structure      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-59">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-59" aria-expanded="false" aria-controls="sidebar-collapse-59">
                    <a href="59">3.3.2          Representing Queues      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-60">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-60" aria-expanded="false" aria-controls="sidebar-collapse-60">
                    <a href="60">3.3.3          Representing Tables      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-61">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-61" aria-expanded="false" aria-controls="sidebar-collapse-61">
                    <a href="61">3.3.4          A Simulator for Digital Circuits      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-62">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-62" aria-expanded="false" aria-controls="sidebar-collapse-62">
                    <a href="62">3.3.5          Propagation of Constraints      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-63">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-63" aria-expanded="true" aria-controls="sidebar-collapse-63">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-63" aria-expanded="true" aria-controls="sidebar-collapse-63">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="63">3.4  Concurrency: Time Is of the Essence</a>
                </h5>
              </div>
              <div id="sidebar-collapse-63" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-64">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-64" aria-expanded="false" aria-controls="sidebar-collapse-64">
                    <a href="64">3.4.1      The Nature of Time in Concurrent Systems  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-65">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-65" aria-expanded="false" aria-controls="sidebar-collapse-65">
                    <a href="65">3.4.2      Mechanisms for Controlling Concurrency  </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-66">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-66" aria-expanded="true" aria-controls="sidebar-collapse-66">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-66" aria-expanded="true" aria-controls="sidebar-collapse-66">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="66">3.5  Streams</a>
                </h5>
              </div>
              <div id="sidebar-collapse-66" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-67">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-67" aria-expanded="false" aria-controls="sidebar-collapse-67">
                    <a href="67">3.5.1      Streams Are Delayed Lists  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-68">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-68" aria-expanded="false" aria-controls="sidebar-collapse-68">
                    <a href="68">3.5.2      Infinite Streams  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-69">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-69" aria-expanded="false" aria-controls="sidebar-collapse-69">
                    <a href="69">3.5.3      Exploiting the Stream Paradigm  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-70">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-70" aria-expanded="false" aria-controls="sidebar-collapse-70">
                    <a href="70">3.5.4      Streams and Delayed Evaluation  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-71">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-71" aria-expanded="false" aria-controls="sidebar-collapse-71">
                    <a href="71">3.5.5      Modularity of Functional Programs and Modularity of Objects  </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>

                </div>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-72">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-72" aria-expanded="true" aria-controls="sidebar-collapse-72">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-72" aria-expanded="true" aria-controls="sidebar-collapse-72">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="72">4  Metalinguistic Abstraction</a>
                </h5>
              </div>
              <div id="sidebar-collapse-72" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-73">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-73" aria-expanded="true" aria-controls="sidebar-collapse-73">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-73" aria-expanded="true" aria-controls="sidebar-collapse-73">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="73">4.1  The Metacircular Evaluator</a>
                </h5>
              </div>
              <div id="sidebar-collapse-73" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-74">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-74" aria-expanded="false" aria-controls="sidebar-collapse-74">
                    <a href="74">4.1.1      The Core of the Evaluator  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-75">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-75" aria-expanded="false" aria-controls="sidebar-collapse-75">
                    <a href="75">4.1.2      Representing                Statements and Expressions      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-76">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-76" aria-expanded="false" aria-controls="sidebar-collapse-76">
                    <a href="76">4.1.3      Evaluator Data Structures  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-77">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-77" aria-expanded="false" aria-controls="sidebar-collapse-77">
                    <a href="77">4.1.4      Running the Evaluator as a Program  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-78">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-78" aria-expanded="false" aria-controls="sidebar-collapse-78">
                    <a href="78">4.1.5    Data as Programs      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-79">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-79" aria-expanded="false" aria-controls="sidebar-collapse-79">
                    <a href="79">4.1.6      Internal Declarations  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-80">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-80" aria-expanded="false" aria-controls="sidebar-collapse-80">
                    <a href="80">4.1.7      Separating Syntactic Analysis from Execution  </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-81">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-81" aria-expanded="true" aria-controls="sidebar-collapse-81">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-81" aria-expanded="true" aria-controls="sidebar-collapse-81">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="81">4.2    Lazy Evaluation</a>
                </h5>
              </div>
              <div id="sidebar-collapse-81" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-82">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-82" aria-expanded="false" aria-controls="sidebar-collapse-82">
                    <a href="82">4.2.1      Normal Order and Applicative Order  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-83">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-83" aria-expanded="false" aria-controls="sidebar-collapse-83">
                    <a href="83">4.2.2      An Interpreter with Lazy Evaluation  </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-84">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-84" aria-expanded="false" aria-controls="sidebar-collapse-84">
                    <a href="84">4.2.3      Streams as Lazy Lists  </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-85">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-85" aria-expanded="true" aria-controls="sidebar-collapse-85">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-85" aria-expanded="true" aria-controls="sidebar-collapse-85">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="85">4.3   Nondeterministic Computing</a>
                </h5>
              </div>
              <div id="sidebar-collapse-85" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-86">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-86" aria-expanded="false" aria-controls="sidebar-collapse-86">
                    <a href="86">4.3.1    Amb and Search      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-87">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-87" aria-expanded="false" aria-controls="sidebar-collapse-87">
                    <a href="87">4.3.2    Examples of Nondeterministic Programs      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-88">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-88" aria-expanded="false" aria-controls="sidebar-collapse-88">
                    <a href="88">4.3.3    Implementing the amb Evaluator      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-89">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-89" aria-expanded="true" aria-controls="sidebar-collapse-89">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-89" aria-expanded="true" aria-controls="sidebar-collapse-89">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="89">4.4  Logic Programming</a>
                </h5>
              </div>
              <div id="sidebar-collapse-89" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-90">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-90" aria-expanded="false" aria-controls="sidebar-collapse-90">
                    <a href="90">4.4.1    Deductive Information Retrieval      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-91">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-91" aria-expanded="false" aria-controls="sidebar-collapse-91">
                    <a href="91">4.4.2    How the Query System Works      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-92">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-92" aria-expanded="false" aria-controls="sidebar-collapse-92">
                    <a href="92">4.4.3    Is Logic Programming Mathematical Logic?      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-93">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-93" aria-expanded="false" aria-controls="sidebar-collapse-93">
                    <a href="93">4.4.4    Implementing the Query System      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>

                </div>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-94">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-94" aria-expanded="true" aria-controls="sidebar-collapse-94">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-94" aria-expanded="true" aria-controls="sidebar-collapse-94">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="94">5  Computing with Register Machines</a>
                </h5>
              </div>
              <div id="sidebar-collapse-94" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-95">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-95" aria-expanded="true" aria-controls="sidebar-collapse-95">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-95" aria-expanded="true" aria-controls="sidebar-collapse-95">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="95">5.1  Designing Register Machines</a>
                </h5>
              </div>
              <div id="sidebar-collapse-95" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-96">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-96" aria-expanded="false" aria-controls="sidebar-collapse-96">
                    <a href="96">5.1.1    A Language for Describing Register Machines      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-97">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-97" aria-expanded="false" aria-controls="sidebar-collapse-97">
                    <a href="97">5.1.2    Abstraction in Machine Design      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-98">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-98" aria-expanded="false" aria-controls="sidebar-collapse-98">
                    <a href="98">5.1.3    Subroutines      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-99">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-99" aria-expanded="false" aria-controls="sidebar-collapse-99">
                    <a href="99">5.1.4    Using a Stack to Implement Recursion      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-100">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-100" aria-expanded="false" aria-controls="sidebar-collapse-100">
                    <a href="100">5.1.5    Instruction Summary      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-101">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-101" aria-expanded="true" aria-controls="sidebar-collapse-101">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-101" aria-expanded="true" aria-controls="sidebar-collapse-101">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="101">5.2  A Register-Machine Simulator</a>
                </h5>
              </div>
              <div id="sidebar-collapse-101" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-102">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-102" aria-expanded="false" aria-controls="sidebar-collapse-102">
                    <a href="102">5.2.1    The Machine Model      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-103">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-103" aria-expanded="false" aria-controls="sidebar-collapse-103">
                    <a href="103">5.2.2    The Assembler      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-104">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-104" aria-expanded="false" aria-controls="sidebar-collapse-104">
                    <a href="104">5.2.3    Generating Execution  Functions  for Instructions      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-105">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-105" aria-expanded="false" aria-controls="sidebar-collapse-105">
                    <a href="105">5.2.4    Monitoring Machine Performance      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-106">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-106" aria-expanded="true" aria-controls="sidebar-collapse-106">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-106" aria-expanded="true" aria-controls="sidebar-collapse-106">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="106">5.3  Storage Allocation and Garbage Collection</a>
                </h5>
              </div>
              <div id="sidebar-collapse-106" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-107">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-107" aria-expanded="false" aria-controls="sidebar-collapse-107">
                    <a href="107">5.3.1    Memory as Vectors      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-108">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-108" aria-expanded="false" aria-controls="sidebar-collapse-108">
                    <a href="108">5.3.2    Maintaining the Illusion of Infinite Memory      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-109">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-109" aria-expanded="true" aria-controls="sidebar-collapse-109">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-109" aria-expanded="true" aria-controls="sidebar-collapse-109">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="109">5.4  The Explicit-Control Evaluator</a>
                </h5>
              </div>
              <div id="sidebar-collapse-109" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-110">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-110" aria-expanded="false" aria-controls="sidebar-collapse-110">
                    <a href="110">5.4.1    The Core of the Explicit-Control Evaluator      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-111">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-111" aria-expanded="false" aria-controls="sidebar-collapse-111">
                    <a href="111">5.4.2    Sequence Evaluation and Tail Recursion      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-112">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-112" aria-expanded="false" aria-controls="sidebar-collapse-112">
                    <a href="112">5.4.3    Conditionals, Assignments, and Definitions      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-113">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-113" aria-expanded="false" aria-controls="sidebar-collapse-113">
                    <a href="113">5.4.4    Running the Evaluator      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-114">
                <h5 class="mb-0">
                  <a class="sidebar-show collapsed" data-toggle="collapse" href="#sidebar-collapse-114" aria-expanded="true" aria-controls="sidebar-collapse-114">
                     &#10148;   <!-- ➤ (because this one is rendered blue on mobile: ▶  -->
                  </a>
                  <a class="sidebar-hide collapsed" data-toggle="collapse" href="#sidebar-collapse-114" aria-expanded="true" aria-controls="sidebar-collapse-114">
                    &#x25BC;    <!-- ▼ (because the corresponding one is not rendered) -->
                  </a>
                    <a href="114">5.5  Compilation</a>
                </h5>
              </div>
              <div id="sidebar-collapse-114" class="collapse" role="tabpanel" aria-labelledby="headingOne">
                <div class="card-block">
                                <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-115">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-115" aria-expanded="false" aria-controls="sidebar-collapse-115">
                    <a href="115">5.5.1    Structure of the Compiler      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-116">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-116" aria-expanded="false" aria-controls="sidebar-collapse-116">
                    <a href="116">5.5.2    Compiling Expressions      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-117">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-117" aria-expanded="false" aria-controls="sidebar-collapse-117">
                    <a href="117">5.5.3    Compiling Combinations      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-118">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-118" aria-expanded="false" aria-controls="sidebar-collapse-118">
                    <a href="118">5.5.4    Combining Instruction Sequences      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-119">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-119" aria-expanded="false" aria-controls="sidebar-collapse-119">
                    <a href="119">5.5.5    An Example of Compiled Code      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-120">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-120" aria-expanded="false" aria-controls="sidebar-collapse-120">
                    <a href="120">5.5.6    Lexical Addressing      </a>
                  </span>
                </h5>
              </div>
            </div>
            <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-121">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-121" aria-expanded="false" aria-controls="sidebar-collapse-121">
                    <a href="121">5.5.7    Interfacing Compiled Code to the Evaluator      </a>
                  </span>
                </h5>
              </div>
            </div>

                </div>
              </div>
            </div>

                </div>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-125">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-125" aria-expanded="false" aria-controls="sidebar-collapse-125">
                    <a href="125">References</a>
                  </span>
                </h5>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-126">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-126" aria-expanded="false" aria-controls="sidebar-collapse-126">
                    <a href="126">Index</a>
                  </span>
                </h5>
              </div>
            </div>

                     <div class="card card-inverse">
              <div class="card-header" role="tab" id="sidebar-127">
                <h5 class="mb-0">
                  <span class="collapsed" data-toggle="collapse" href="#sidebar-collapse-127" aria-expanded="false" aria-controls="sidebar-collapse-127">
                    <a href="127">Making of the JavaScript Adaptation</a>
                  </span>
                </h5>
              </div>
            </div>

       </div>

           <div id="permalink-msg">
  <div class="screen">
    <div class="alert alert-success">
      <strong>Permalink copied!</strong> 
    </div>
  </div>
</div>
<div class="chapter-content">

  <div class="chapter-title">
    <div class="permalink">
      <a name="top" class="permalink">4.1.1 
    The Core of the Evaluator
  </a>
    </div>
  </div>
    <div class="chapter-text" >
        <div class="SUBSECTION"><SUBSECTION>
  

  <div class="permalink">
<a name="p1" class="permalink"></a><p>
    

    <SPLIT>
      
    </SPLIT>
    The evaluation process can be described as the interplay between two
    functions: 
    
    <kbd>evaluate</kbd>
    
    and <kbd>apply</kbd>.
  </p>
</div>
      
  <div class="permalink">
<a name="h1" class="permalink"></a><h2>
    
      
      The function 
      <kbd>evaluate</kbd>
    
  </h2>
</div>

  <div class="permalink">
<a name="p2" class="permalink"></a><p>

  

    
      
      The function <kbd>evaluate</kbd>
    
    takes as arguments 
    
    a statement 
    and an environment.  It  classifies the 
    
    statement 
    and directs its evaluation.  
    
      
      The function <kbd>evaluate</kbd>
    
    is structured as a case analysis of the syntactic type of the expression
    to be evaluated.  In order to keep the
    
    function
    general, we express
    the determination of the type of 
    
    a statement
    abstractly, making no
    commitment to any particular 
    
    representation for the various types of
    
    statements.
    Each type of 
    
    statement
    has a predicate that tests for
    it and an abstract means for selecting its parts.  This 
    
    
    <EM>abstract syntax</EM> makes it easy to see how we can change the syntax of
    the language by using the same evaluator, but with a different collection of
    syntax
    
    functions.
  </p>
</div>

  <SUBSUBSUBSECTION>
    Primitive expressions

    <SPLIT>
      
      
	<div class="permalink">
<a name="p3" class="permalink"></a><p>
          <UL>
	    <LI>
	      
	      
	      If the given statement is a self-evaluating expression,
	      such as a number, 
	      <kbd>evaluate</kbd>
	      returns the expression itself.
	    </LI>
	    <LI>
	      The function <kbd>evaluate</kbd>
	      must look up names
	      in the environment to find their values.
	    </LI>
          </UL>
	</p>
</div>
      
    </SPLIT>
  </SUBSUBSUBSECTION>

    <SPLIT>
      
      
  <SUBSUBSUBSECTION>	
	Language constructs
	<div class="permalink">
<a name="p4" class="permalink"></a><p>
          <UL>
	    <LI>
	      An assignment to (or a declaration of) a name must recursively call
	      <kbd>evaluate</kbd>
	      to compute the new value to be associated with the
	      variable.  The environment must be modified to change (or create) the
	      binding of the variable.
	    </LI>
	    <LI>
	      A conditional expression requires special processing of its parts,
	      so as to evaluate the consequent if the predicate is true, and
	      otherwise to evaluate the alternative.
	    </LI>
	    <LI>
	      A function definition expression must be transformed into an applicable
	      function by packaging together the parameters and body
	      specified by the function definition with 
	      the environment of the evaluation.
	    </LI>
	    <LI>
	      A sequence of statements requires evaluating its 
	      component statements in the order in which they appear.
	    </LI>
	    <LI>
	      A block requires evaluating its statements, while ensuring that
	      declarations within the block remain local to the block.
	    </LI>
	    <LI>
	      When <kbd>evaluate</kbd>
	      encounters a <kbd>return</kbd>
	      statement, the <kbd>return</kbd>
	      expression is evaluated and marked as a return value.
	    </LI>
          </UL>
	</p>
</div>
  </SUBSUBSUBSECTION>
      
    </SPLIT>


  <SUBSUBSUBSECTION>
    Combinations

    <SPLIT>
      
      
	<div class="permalink">
<a name="p5" class="permalink"></a><p>
          <UL>
	    <LI>
	      For a function application, 
	      <kbd>evaluate</kbd>
	      must recursively evaluate the function expression and the arguments of
	      the application.  The resulting function
	      and arguments are passed to <kbd>apply</kbd>, which
	      handles the actual function application.
	    </LI>
          </UL>
	</p>
</div>
      
    </SPLIT>
  </SUBSUBSUBSECTION>
  
  <div class="permalink">
<a name="p6" class="permalink"></a><p>
    
    Here is the definition of
    
    <kbd>evaluate</kbd>:
    

    
    
    <div class="snippet" id="javascript_74_0_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}'+'\n'+'\nconst my_program = parse(&quot;1; { true; 3; }&quot;);\nevaluate(my_program, the_empty_environment);\n      '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function evaluate(stmt, env) {
   return is_self_evaluating(stmt)
          ?  stmt
        : is_name(stmt)
          ? lookup_name_value(name_of_name(stmt), env)
        : is_constant_declaration(stmt)
          ? eval_constant_declaration(stmt, env)
        : is_variable_declaration(stmt)
          ? eval_variable_declaration(stmt, env)
        : is_assignment(stmt)
          ? eval_assignment(stmt, env)
        : is_conditional_expression(stmt)
          ? eval_conditional_expression(stmt, env)
        : is_function_definition(stmt)
          ? eval_function_definition(stmt, env)
        : is_sequence(stmt)
          ? eval_sequence(sequence_statements(stmt), env)
        : is_block(stmt)
          ? eval_block(stmt, env)
        : is_return_statement(stmt)
          ? eval_return_statement(stmt, env)
        : is_application(stmt)
          ? apply(evaluate(operator(stmt), env),
                  list_of_values(operands(stmt), env))
        : error(stmt, "Unknown statement type in evaluate: ");
}</pre></div></div>

    

  </p>
</div>


  <div class="permalink">
<a name="p7" class="permalink"></a><p>
    
    
    For clarity, 
    
    <kbd>evaluate</kbd>
    has been implemented as a case analysis using
    
    conditional expressions.
    The disadvantage of this is that our
    
    function
    handles
    only a few distinguishable types of 
    
    statements,
    and no new ones can be defined without editing the definition of 
    
    <kbd>evaluate</kbd>.
    
    In most
    interpreter
    
    implementations, dispatching on the type of an expression is done in a
    data-directed style.  This allows a user to add new types of    
    
    statements and expressions that
    <kbd>evaluate</kbd>
    
    can distinguish, without modifying the definition of 
    
    <kbd>evaluate</kbd>
    itself.
    (See exercise <REF NAME="ex:data-directed-eval"><a class="superscript" id="4.1.1-ex-link-4.2" href="75#ex_4.2">4.2</a></REF>.)
  </p>
</div>

  <div class="permalink">
<a name="h2" class="permalink"></a><h2>
    Apply
  </h2>
</div>

  <div class="permalink">
<a name="p8" class="permalink"></a><p>
    
    The function <kbd>apply</kbd>
    
    takes two arguments, a
    
    function
    and a list of arguments  to which the
    
    function
    should be applied.  
    
    The function <kbd>apply</kbd>
    
    classifies
    
    functions
    into two kinds: It calls 

  

    
      
      
	<kbd>apply_primitive_function</kbd>
      
    
    to apply primitives; it applies compound
    
    functions
    by sequentially evaluating the 
    
    statements that
    make up the body of the function.  
    The environment for the
    evaluation of the body of a compound
    
    function
    is constructed by extending the base environment carried by
    the
    
    function
    to include a frame that binds the parameters of the
    
    function
    to the arguments to which the
    
    function is to be applied, and the body's
    local names to a special value
    <kbd>no_value_yet</kbd>.
    The function
    <kbd>local_names</kbd>
    for computing the body's local names is also used for
    <EM>blocks</EM> and explained below.
    
    Here is the definition of <kbd>apply</kbd>:

    <div class="snippet" id="javascript_74_1_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}'+'\n'+'\nconst plus = make_primitive_function( \n                   (x, y) =&gt; x + y\n                  );\napply(plus, list(1, 2));\n      '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function apply(fun, args) {
   if (is_primitive_function(fun)) {
      return apply_primitive_function(fun, args);
   } else if (is_compound_function(fun)) {
      const body = function_body(fun);
      const locals = local_names(body);
      const names = insert_all(function_parameters(fun),
                               locals);
      const temp_values = map(x =&gt; no_value_yet,
                              locals);
      const values = append(args,
                            temp_values);			   
      const result =
         evaluate(body,
                  extend_environment(
                      names,
                      values,
                      function_environment(fun)));
      if (is_return_value(result)) {
         return return_value_content(result);
      } else {
          return undefined;
      }
   } else {
      error(fun, "Unknown function type in apply");
   }
}</pre></div></div>

    
    
    
      
      
	In order to return a value, JavaScript functions need to evaluate a return 
	statement. If a function terminates without return, the value 
	<kbd>undefined</kbd>
	is returned. Thus, if the evaluation of the function body yields a return
	value, the content of the return value is retrieved, and otherwise the
	value <kbd>undefined</kbd> is returned.
      
    
  </p>
</div>

  <div class="permalink">
<a name="h3" class="permalink"></a><h2>
    
    Function
    arguments
  </h2>
</div>

  <div class="permalink">
<a name="p9" class="permalink"></a><p>
    When
    
    <kbd>evaluate</kbd>
    processes a
    
    function
    application, it uses 
    
    <kbd>list_of_values</kbd>
    
    to produce the
    list of arguments to which the
    
    function
    is to be applied.
    
    The function <kbd>list_of_values</kbd>
    
    takes as an argument the operands of the combination.
    It evaluates each operand and returns a list of the corresponding
    values:<a class="superscript" id="footnote-link-1" href="74#footnote-1">[1]</a>

    <div class="snippet" id="javascript_74_2_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}'+'\n'+'\nconst my_addition_expression = parse(&quot;1 + 2;&quot;);\nlist_of_values(list(1, my_addition_expression, 7),\n               the_global_environment);\n      '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function list_of_values(exps, env) {
    if (no_operands(exps)) {
        return null;
    } else {
        return pair(evaluate(first_operand(exps), env),
                    list_of_values(rest_operands(exps), env));
   }
}</pre></div></div>

    
  </p>
</div>

  <div class="permalink">
<a name="h4" class="permalink"></a><h2>
    Conditionals
  </h2>
</div>

  <div class="permalink">
<a name="p10" class="permalink"></a><p>
    
    The function
    <kbd>eval_conditional_expression</kbd>
    
    evaluates the predicate part of an
    
    conditional expression
    in the given environment.  If the result is true, 
    
      
      
	the consequent is evaluated, otherwise the alternative:
    

    <div class="snippet" id="javascript_74_3_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}'+'\n'+'\nconst my_cond_expr = parse(&quot;if (true) { 1; } else { 2; }&quot;);\neval_conditional_expression(my_cond_expr, the_empty_environment);\n      '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_conditional_expression(stmt, env) {
    return is_true(evaluate(cond_expr_pred(stmt),
                            env))
           ? evaluate(cond_expr_cons(stmt), 
                      env)
           : evaluate(cond_expr_alt(stmt), 
                      env);
}</pre></div></div>
    

  </p>
</div>

  <div class="permalink">
<a name="p11" class="permalink"></a><p>
    
    The use of 
    
    <kbd>is_true</kbd>
    in 
    
    <kbd>eval_conditional_expression</kbd>
    
    highlights the issue of the
    connection between an implemented language and an implementation
    language.  The 
    
    predicate
    is evaluated in the language being
    implemented and thus yields a value in that language.  The interpreter
    predicate 
    
    <kbd>is_true</kbd>
     
    translates that value into a value that can be
    tested by the
    
    conditional expression
    in the implementation language: The
    metacircular representation of truth might not be the same as that of
    the underlying 
    JavaScript.<a class="superscript" id="footnote-link-2" href="74#footnote-2">[2]</a>
  </p>
</div>

  <SPLIT>
    
      <div class="permalink">
<a name="h5" class="permalink"></a><h2>
	Function definitions
      </h2>
</div>
      <div class="permalink">
<a name="p12" class="permalink"></a><p>
	The evaluation of a function definition expression creates
	a function object that represents the function during the
	evaluation. The function object contains the parameters
	and the body of the function definition, as well as the
	environment with respect to which the function definition
	is evaluated. According to the environment model, this is
	the environment that needs to be extended, when the function
	gets applied to actual arguments.
	<div class="snippet" id="javascript_74_4_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}'+'\n'+'\nconst my_fun = parse(&quot;x =&gt; x * x;&quot;);\neval_function_definition(my_fun, the_empty_environment);\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_function_definition(stmt,env) {
    return make_compound_function(
              map(name_of_name,
                  function_definition_parameters(stmt)),
              function_definition_body(stmt),
              env);
}</pre></div></div>
	
      </p>
</div>
    
  </SPLIT>

  <div class="permalink">
<a name="h6" class="permalink"></a><h2>
    Sequences
  </h2>
</div>

  <SPLIT>
    
    
      <div class="permalink">
<a name="p13" class="permalink"></a><p>
	The function <kbd>eval_sequence</kbd>
	is used by <kbd>eval</kbd>
	to evaluate a sequence of statements.
	Note that the evaluation of the first component
	of a sequence may yield a return value, in which
	case the rest of the statement is not evaluated.

	<div class="snippet" id="javascript_74_5_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}'+'\n'+'\nconst my_sequence = head(tail(parse(&quot;1; true; 3;&quot;)));\neval_sequence(my_sequence, the_empty_environment);\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_sequence(stmts, env) {
    if (is_empty_sequence(stmts)) {
        return undefined;
    } else if (is_last_statement(stmts)) {
            return evaluate(first_statement(stmts),env);
    } else {
        const first_stmt_value = 
            evaluate(first_statement(stmts),env);
        if (is_return_value(first_stmt_value)) {
            return first_stmt_value;
        } else {
            return eval_sequence(
                rest_statements(stmts),env);
        }
    }
}</pre></div></div>

	
      </p>
</div>
    
  </SPLIT>

  <SPLIT>
    
      <div class="permalink">
<a name="h7" class="permalink"></a><h2>
	Blocks
      </h2>
</div>


      <div class="permalink">
<a name="p14" class="permalink"></a><p>
	The function <kbd>eval_block</kbd>
	is used by  
	<kbd>evaluate</kbd>
	to evaluate block statements. The constants and variables
	declared in the block need to be local to the block. 
	The evaluation of block statements evaluates the body of the
	block with respect to an environment that extends the current
	environment with a binding of the local names of the block
	body to a special value
        <kbd>no_value_yet</kbd>.
	<div class="snippet" id="javascript_74_6_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}'+'\n'+'\nconst my_block = parse(&quot;{ true; 3; 42; }&quot;);\neval_block(my_block, the_empty_environment);\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_block(stmt, env) {
    const body = block_body(stmt);
    const locals = local_names(body);	    
    const temp_values = map(x =&gt; no_value_yet,
                            locals);
    return evaluate(body,
                extend_environment(locals, temp_values, env));
}</pre></div></div>

	
      </p>
</div>

      <div class="permalink">
<a name="p15" class="permalink"></a><p>
      The function 
      <kbd>local_names</kbd>
      collects all names declared in the body statements. For
      a name to be included in the list of
      <kbd>local_names</kbd>, it needs
      to be declared outside of any other block or function.

      

      <div class="snippet" id="javascript_74_7_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}'+'\n'+'\nlocal_names(parse(&quot;const x = 1; let y = 2;&quot;));\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function local_names(stmt) {
    if (is_sequence(stmt)) {
        const stmts = sequence_statements(stmt);
        return is_empty_sequence(stmts)
            ? null
            : insert_all(
                  local_names(first_statement(stmts)),
                  local_names(make_sequence(
		               rest_statements(stmts))));
    } else {
       return is_constant_declaration(stmt)
           ? list(constant_declaration_name(stmt))
           : is_variable_declaration(stmt)
             ? list(variable_declaration_name(stmt))
             : null;
    }
}</pre></div></div>

      <div class="snippet" id="javascript_74_8_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'local_names(parse(&quot;const x = 1; let y = 2;&quot;));'+'\n'+''+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">local_names(parse("const x = 1; let y = 2;"));</pre></div></div>
      </p>
</div>

      <div class="permalink">
<a name="h8" class="permalink"></a><h2>
	Return statements
      </h2>
</div>

      <div class="permalink">
<a name="p16" class="permalink"></a><p>
	The function <kbd>eval_return_statement</kbd>
	is used by  
	<kbd>evaluate</kbd>
	to evaluate return statements. As seen in the evaluation
	of sequences, the result of evaluation of return statements
	needs to be identifiable so that the evaluation of function
	bodies can return immediately, even if there are statements
	after the return statement. For this purpose,
	the evaluation of a return statement wraps the result of
	evaluating the return expression in a return value object.
	<div class="snippet" id="javascript_74_9_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}'+'\n'+'\nconst my_program = parse(&quot;{ function f() { return 1; } f(); }&quot;);\nevaluate(my_program, the_global_environment);\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_return_statement(stmt, env) {
    return make_return_value(
               evaluate(return_statement_expression(stmt),
                        env));
}</pre></div></div>
	
      </p>
</div>
    
  </SPLIT>

  <div class="permalink">
<a name="h9" class="permalink"></a><h2>
    Assignments and
    declarations
    
  </h2>
</div>

  <div class="permalink">
<a name="p17" class="permalink"></a><p>
    The following
    
    function
    handles assignments to variables.  It calls
    
    <kbd>evaluate</kbd>
    to find the value to be assigned and transmits the variable
    and the resulting value to 
    
    <kbd>assign_name_to_value</kbd>
    
    to be installed  in the designated environment.

    <div class="snippet" id="javascript_74_10_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}\n	  \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}'+'\n'+'\nconst my_program = parse(&quot;{ let x = 1; x = 2; }&quot;);\nevaluate(my_program, the_global_environment);\n      '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_assignment(stmt, env) {
    const value = evaluate(assignment_value(stmt), env);
    assign_name_value(assignment_name(stmt), value, env);
    return value;
}</pre></div></div>

    
    
  </p>
</div>

  <SPLIT>
    

    
      <div class="permalink">
<a name="p18" class="permalink"></a><p>
	Declarations of constants and variables are handled in a similar
	manner. Section <REF NAME="sec:eval-data-structures"><a class="superscript" id="4.1.1-sec-link-4.1.3" href="76">4.1.3</a></REF>
	explains how we distinguish variables and constants in the functions
	and how we prevent assignment to constants.
	<div class="snippet" id="javascript_74_11_div"><div class="pre-prettyprint"><pre class="prettyprint" title="Evaluate Javascript expression" onclick="var compressed = LZString.compressToEncodedURIComponent('\n// functions from chapter 4, section 1.1\n\n      \nfunction evaluate(stmt, env) {\n   return is_self_evaluating(stmt)\n          ?  stmt\n        : is_name(stmt)\n          ? lookup_name_value(name_of_name(stmt), env)\n        : is_constant_declaration(stmt)\n          ? eval_constant_declaration(stmt, env)\n        : is_variable_declaration(stmt)\n          ? eval_variable_declaration(stmt, env)\n        : is_assignment(stmt)\n          ? eval_assignment(stmt, env)\n        : is_conditional_expression(stmt)\n          ? eval_conditional_expression(stmt, env)\n        : is_function_definition(stmt)\n          ? eval_function_definition(stmt, env)\n        : is_sequence(stmt)\n          ? eval_sequence(sequence_statements(stmt), env)\n        : is_block(stmt)\n          ? eval_block(stmt, env)\n        : is_return_statement(stmt)\n          ? eval_return_statement(stmt, env)\n        : is_application(stmt)\n          ? apply(evaluate(operator(stmt), env),\n                  list_of_values(operands(stmt), env))\n        : error(stmt, &quot;Unknown statement type in evaluate: &quot;);\n}\n      \nfunction apply(fun, args) {\n   if (is_primitive_function(fun)) {\n      return apply_primitive_function(fun, args);\n   } else if (is_compound_function(fun)) {\n      const body = function_body(fun);\n      const locals = local_names(body);\n      const names = insert_all(function_parameters(fun),\n                               locals);\n      const temp_values = map(x =&gt; no_value_yet,\n                              locals);\n      const values = append(args,\n                            temp_values);			   \n      const result =\n         evaluate(body,\n                  extend_environment(\n                      names,\n                      values,\n                      function_environment(fun)));\n      if (is_return_value(result)) {\n         return return_value_content(result);\n      } else {\n          return undefined;\n      }\n   } else {\n      error(fun, &quot;Unknown function type in apply&quot;);\n   }\n}\n      \nfunction list_of_values(exps, env) {\n    if (no_operands(exps)) {\n        return null;\n    } else {\n        return pair(evaluate(first_operand(exps), env),\n                    list_of_values(rest_operands(exps), env));\n   }\n}\n      \nfunction eval_conditional_expression(stmt, env) {\n    return is_true(evaluate(cond_expr_pred(stmt),\n                            env))\n           ? evaluate(cond_expr_cons(stmt), \n                      env)\n           : evaluate(cond_expr_alt(stmt), \n                      env);\n}\n      \nfunction eval_function_definition(stmt,env) {\n    return make_compound_function(\n              map(name_of_name,\n                  function_definition_parameters(stmt)),\n              function_definition_body(stmt),\n              env);\n}\n	  \nfunction eval_sequence(stmts, env) {\n    if (is_empty_sequence(stmts)) {\n        return undefined;\n    } else if (is_last_statement(stmts)) {\n            return evaluate(first_statement(stmts),env);\n    } else {\n        const first_stmt_value = \n            evaluate(first_statement(stmts),env);\n        if (is_return_value(first_stmt_value)) {\n            return first_stmt_value;\n        } else {\n            return eval_sequence(\n                rest_statements(stmts),env);\n        }\n    }\n}\n          \n// We use a nullary function as temporary value for names whose\n// declaration has not yet been evaluated. The purpose of the\n// function definition is purely to create a unique identity;\n// the function will never be applied and its return value \n// (null) is irrelevant.\nconst no_value_yet = () =&gt; null;\n      \nfunction insert_all(xs, ys) {\n    return is_null(xs)\n        ? ys\n        : is_null(member(head(xs), ys))\n          ? pair(head(xs), insert_all(tail(xs), ys))\n          : error(head(xs), &quot;multiple declarations of: &quot;);\n}\n	\nfunction local_names(stmt) {\n    if (is_sequence(stmt)) {\n        const stmts = sequence_statements(stmt);\n        return is_empty_sequence(stmts)\n            ? null\n            : insert_all(\n                  local_names(first_statement(stmts)),\n                  local_names(make_sequence(\n		               rest_statements(stmts))));\n    } else {\n       return is_constant_declaration(stmt)\n           ? list(constant_declaration_name(stmt))\n           : is_variable_declaration(stmt)\n             ? list(variable_declaration_name(stmt))\n             : null;\n    }\n}	     \n	  \nfunction eval_block(stmt, env) {\n    const body = block_body(stmt);\n    const locals = local_names(body);	    \n    const temp_values = map(x =&gt; no_value_yet,\n                            locals);\n    return evaluate(body,\n                extend_environment(locals, temp_values, env));\n}\n          \nfunction eval_return_statement(stmt, env) {\n    return make_return_value(\n               evaluate(return_statement_expression(stmt),\n                        env));\n}\n          \nfunction eval_assignment(stmt, env) {\n    const value = evaluate(assignment_value(stmt), env);\n    assign_name_value(assignment_name(stmt), value, env);\n    return value;\n}\n      \n    \n// functions from chapter 4, section 1.2\n\n	      \nfunction is_self_evaluating(stmt) {\n    return is_number(stmt) ||\n           is_string(stmt) || \n           is_boolean(stmt);\n}\n	      \nfunction is_tagged_list(stmt, the_tag) {\n    return is_pair(stmt) &amp;&amp; head(stmt) === the_tag;\n}\n	      \nfunction is_name(stmt) {\n    return is_tagged_list(stmt, &quot;name&quot;);\n}\nfunction name_of_name(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_assignment(stmt) {\n   return is_tagged_list(stmt, &quot;assignment&quot;);\n}\nfunction assignment_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction assignment_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_constant_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;constant_declaration&quot;);\n}\nfunction constant_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction constant_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction is_variable_declaration(stmt) {\n   return is_tagged_list(stmt, &quot;variable_declaration&quot;);\n}\nfunction variable_declaration_name(stmt) {\n   return head(tail(head(tail(stmt))));\n}\nfunction variable_declaration_value(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_function_definition(stmt) {\n   return is_tagged_list(stmt, &quot;function_definition&quot;);\n}\nfunction function_definition_parameters(stmt) {\n   return head(tail(stmt));\n}\nfunction function_definition_body(stmt) {\n   return head(tail(tail(stmt)));\n}\n	      \nfunction is_return_statement(stmt) {\n   return is_tagged_list(stmt, &quot;return_statement&quot;);\n}\nfunction return_statement_expression(stmt) {\n   return head(tail(stmt));\n}\n	      \nfunction is_conditional_expression(stmt) {\n   return is_tagged_list(stmt, \n                &quot;conditional_expression&quot;);\n}\nfunction cond_expr_pred(stmt) {\n   return list_ref(stmt, 1);\n}\nfunction cond_expr_cons(stmt) {\n   return list_ref(stmt, 2);\n}\nfunction cond_expr_alt(stmt) {\n   return list_ref(stmt, 3);\n}\n	      \nfunction is_sequence(stmt) {\n   return is_tagged_list(stmt, &quot;sequence&quot;);\n}\nfunction make_sequence(stmts) {\n   return list(&quot;sequence&quot;, stmts);\n}\nfunction sequence_statements(stmt) {   \n   return head(tail(stmt));\n}\nfunction is_empty_sequence(stmts) {\n   return is_null(stmts);\n}\nfunction is_last_statement(stmts) {\n   return is_null(tail(stmts));\n}\nfunction first_statement(stmts) {\n   return head(stmts);\n}\nfunction rest_statements(stmts) {\n   return tail(stmts);\n}\n	      \nfunction is_block(stmt) {\n    return is_tagged_list(stmt, &quot;block&quot;);\n}\nfunction make_block(stmt) {\n   return list(&quot;block&quot;, stmt);\n}\nfunction block_body(stmt) {\n    return head(tail(stmt));\n}\n	      \nfunction is_application(stmt) {\n   return is_tagged_list(stmt, &quot;application&quot;);\n}\nfunction operator(stmt) {\n   return head(tail(stmt));\n}\nfunction operands(stmt) {\n   return head(tail(tail(stmt)));\n}\nfunction no_operands(ops) {\n   return is_null(ops);\n}\nfunction first_operand(ops) {\n   return head(ops);\n}\nfunction rest_operands(ops) {\n   return tail(ops);\n}\n	      \n    \n	// functions from chapter 4, section 1.3\n\n      \nfunction is_true(x) {\n    return x === true;\n}\n      \nfunction make_compound_function(parameters, body, env) {\n    return list(&quot;compound_function&quot;,\n                parameters, body, env);\n}\nfunction is_compound_function(f) {\n    return is_tagged_list(f, &quot;compound_function&quot;);\n}\nfunction function_parameters(f) {\n    return list_ref(f, 1);\n}\nfunction function_body(f) {\n    return list_ref(f, 2);\n}\nfunction function_environment(f) {\n    return list_ref(f, 3);\n}\n      \nfunction make_return_value(content) {\n    return list(&quot;return_value&quot;, content);\n}\nfunction is_return_value(value) {\n    return is_tagged_list(value,&quot;return_value&quot;);\n}\nfunction return_value_content(value) {\n    return head(tail(value));\n}\n	  \nfunction enclosing_environment(env) {\n    return tail(env);\n}\nfunction first_frame(env) {\n    return head(env);\n}\nfunction enclose_by(frame, env) {    \n    return pair(frame, env);\n}\nconst the_empty_environment = null;\nfunction is_empty_environment(env) {\n    return is_null(env);\n}\n      \nfunction make_frame(names, values) {\n    return pair(names, values);\n}\nfunction frame_names(frame) {    \n    return head(frame);\n}\nfunction frame_values(frame) {    \n    return tail(frame);\n}\n      \nfunction extend_environment(names, vals, base_env) {\n    if (length(names) === length(vals)) {\n        return enclose_by(\n                   make_frame(names, \n                      map(x =&gt; pair(x, true), vals)),\n                   base_env);\n    } else if (length(names) &lt; length(vals)) {\n        error(&quot;Too many arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    } else {\n        error(&quot;Too few arguments supplied: &quot; + \n              stringify(names) + &quot;, &quot; + \n              stringify(vals));\n    }\n}\n      \nfunction lookup_name_value(name, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                   ? env_loop(\n                       enclosing_environment(env))\n                   : name === head(names)\n                     ? head(head(vals))\n                     : scan(tail(names), tail(vals));\n        }\n        if (is_empty_environment(env)) {\n            error(name, &quot;Unbound name: &quot;);\n        } else {\n            const frame = first_frame(env);\n            const value =  scan(frame_names(frame),\n                                frame_values(frame));\n	    return value === no_value_yet\n              ? error(name, &quot;Name use before declaration: &quot;)\n              : value;\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction assign_name_value(name, val, env) {\n    function env_loop(env) {\n        function scan(names, vals) {\n            return is_null(names)\n                ? env_loop(\n                    enclosing_environment(env))\n                : name === head(names)\n                  ? ( tail(head(vals))\n                      ? set_head(head(vals), val)\n                      : error(&quot;no assignment &quot; +\n                          &quot;to constants allowed&quot;) )\n                  : scan(tail(names), tail(vals));\n        } \n        if (env === the_empty_environment) {\n            error(name, &quot;Unbound name in assignment: &quot;);\n        } else {\n            const frame = first_frame(env);\n            return scan(frame_names(frame),\n                        frame_values(frame));\n        }\n    }\n    return env_loop(env);\n}\n      \nfunction set_name_value(name, val, env) {\n    function scan(names, vals) {\n        return is_null(names)\n            ? error(&quot;internal error: name not found&quot;)\n            : name === head(names)\n              ? set_head(head(vals), val)\n              : scan(tail(names), tail(vals));\n    } \n    const frame = first_frame(env);\n    return scan(frame_names(frame),\n                frame_values(frame));\n}\n	  \n    \n	// functions from chapter 4, section 1.4\n\n      \nfunction make_primitive_function(impl) {\n    return list(&quot;primitive&quot;, impl);\n}\nfunction is_primitive_function(fun) {\n   return is_tagged_list(fun, &quot;primitive&quot;);\n}\nfunction primitive_implementation(fun) {\n   return list_ref(fun, 1);\n}\n	  \nconst primitive_functions = list(\n       list(&quot;display&quot;,       display          ),\n       list(&quot;error&quot;,         error            ),\n       list(&quot;+&quot;,             (x, y) =&gt; x + y  ),\n       list(&quot;-&quot;,             (x, y) =&gt; x - y  ),\n       list(&quot;*&quot;,             (x, y) =&gt; x * y  ),\n       list(&quot;/&quot;,             (x, y) =&gt; x / y  ),\n       list(&quot;%&quot;,             (x, y) =&gt; x % y  ),\n       list(&quot;===&quot;,           (x, y) =&gt; x === y),\n       list(&quot;!==&quot;,           (x, y) =&gt; x !== y),\n       list(&quot;&lt;&quot;,             (x, y) =&gt; x &lt;   y),\n       list(&quot;&lt;=&quot;,            (x, y) =&gt; x &lt;=  y),\n       list(&quot;&gt;&quot;,             (x, y) =&gt; x &gt;   y),\n       list(&quot;&gt;=&quot;,            (x, y) =&gt; x &gt;=  y),\n       list(&quot;!&quot;,              x     =&gt;   !   x)\n       );\n      \nconst primitive_constants = list(list(&quot;undefined&quot;, undefined),\n                                 list(&quot;NaN&quot;,       NaN),\n                                 list(&quot;Infinity&quot;,  Infinity),\n                                 list(&quot;math_PI&quot;,   math_PI)\n                                );\n	  \nfunction apply_primitive_function(fun, argument_list) {\n    return apply_in_underlying_javascript(\n                primitive_implementation(fun),\n                argument_list);     \n}\n    \nfunction setup_environment() {\n    const primitive_function_names =\n        map(f =&gt; head(f), primitive_functions);\n    const primitive_function_values =\n        map(f =&gt; make_primitive_function(head(tail(f))),\n            primitive_functions);\n    const primitive_constant_names =\n        map(f =&gt; head(f), primitive_constants);\n    const primitive_constant_values =\n        map(f =&gt; head(tail(f)),\n            primitive_constants);\n    return extend_environment(\n               append(primitive_function_names, \n                      primitive_constant_names),\n               append(primitive_function_values, \n                      primitive_constant_values),\n               the_empty_environment);\n}\n      \nconst the_global_environment = setup_environment();\n      \n    '+'\n'+'function eval_variable_declaration(stmt, env) {\n    set_name_value(variable_declaration_name(stmt),\n        evaluate(variable_declaration_value(stmt), env),\n        env);\n}   \nfunction eval_constant_declaration(stmt, env) {\n    set_name_value(constant_declaration_name(stmt),\n        evaluate(constant_declaration_value(stmt), env),\n        env);\n}'+'\n'+'\nconst my_program = parse(&quot;{ let x = 1; const y = 2; x + y; }&quot;);\nevaluate(my_program, the_global_environment);\n	  '+'\n'); var url = 'https://source-academy.github.io/playground#chap=4&amp;prgrm='+compressed; window.open(url); ">function eval_variable_declaration(stmt, env) {
    set_name_value(variable_declaration_name(stmt),
        evaluate(variable_declaration_value(stmt), env),
        env);
}   
function eval_constant_declaration(stmt, env) {
    set_name_value(constant_declaration_name(stmt),
        evaluate(constant_declaration_value(stmt), env),
        env);
}</pre></div></div>

	
      </p>
</div>

      <div class="permalink">
<a name="p19" class="permalink"></a><p>
	Note that the returned value of constant and variable
	declaration is the value <kbd>undefined</kbd>,
	as prescribed by the ECMAScript standard (<CITATION>Ecma 1997</CITATION>).
	
      </p>
</div>

    
  </SPLIT>


  
  
  <div class="permalink">
<a name="ex_4.1" class="permalink"></a><EXERCISE><b><a class="exercise-number permalink" id="ex_4.1">Exercise 4.1 </a></b>
    
    
    Notice that we cannot tell whether the metacircular evaluator
    evaluates operands from left to right or from right to left.  Its evaluation
    order is inherited from the underlying
    JavaScript:
    
    If the arguments to
    
    <kbd>pair</kbd>
    
    in
    
    <kbd>list_of_values</kbd>
    
    are evaluated from left to right, then
    
    <kbd>list_of_values</kbd>
    
    will evaluate operands from left to right; and if the arguments to
    
    <kbd>pair</kbd>
    
    are evaluated from right to left, then
    
    <kbd>list_of_values</kbd>
    
    will evaluate operands from right to left.

    Write a version of
    
    <kbd>list_of_values</kbd>
    
    that evaluates operands
    from left to right regardless of the order of evaluation in the underlying
    JavaScript.
    
    Also write a version of
    
    <kbd>list_of_values</kbd>
    
    that evaluates operands from right to left.
    
  <div class="Solution">
<div class="solution_btn"><button class="btn btn-secondary solution_btn" href="#no_solution_74_1_div" data-toggle="collapse">Add solution</button></div>
<div class="solution_content collapse" id="no_solution_74_1_div">There is currently no solution available for this exercise. This textbook adaptation is a community effort. Do consider contributing by providing a solution for this exercise, using a Pull Request in <a address="https://github.com/source-academy/sicp" href="https://github.com/source-academy/sicp">Github</a>.</div>
</div></EXERCISE>
</div>

<hr>
<div class="footnote">
<a class="footnote-number" id="footnote-1" href="74#footnote-link-1">[1] </a><FOOTNOTE>We could have simplified the 
    
    <kbd>is_application</kbd>
    
    clause in
    
    <kbd>evaluate</kbd>
    by using <kbd>map</kbd>
    (and stipulating that <kbd>operands</kbd> returns a list)
    rather than writing an explicit 
    
    <kbd>list_of_values</kbd>
    
    
    function.
    We chose not to use <kbd>map</kbd> here to emphasize the
    fact that the
    
    
    evaluator can be implemented without any use of higher-order
    
    functions
    (and thus could be written in a language that doesn't have
    higher-order
    
    functions),
    even though the language that it supports will include higher-order
    
    functions.
    </FOOTNOTE>
</div>
<div class="footnote">
<a class="footnote-number" id="footnote-2" href="74#footnote-link-2">[2] </a><FOOTNOTE>In this case, the language being implemented and the
    implementation language are the same.  Contemplation of the meaning of
    
    
    <kbd>is_true</kbd>
    
    here yields expansion of consciousness without the abuse of
    substance.</FOOTNOTE>
</div></SUBSECTION></div>
    </div>

    <div class="nav">

        <button type="button" class="btn btn-secondary" style="background-color: #fff;">
          <a href="73">&lt; Previous</a>
        </button>

    <div style="flex-grow: 1;"></div>
    
        <button type="button" class="btn btn-secondary" style="background-color: #fff;">
          <a class="scroll-next" href="75">Next &gt;</a>
        </button>


  </div>
  <div class="chapter_sign">
        4.1.1 
    The Core of the Evaluator
  
    </div>
  <script>
//<![CDATA[
var chapter_id = 74;
//]]>
</script>
  <div class="next-page"></div>
</div>

     </div><!-- /.container -->


     <!--<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
     -->
   </body>
</html>

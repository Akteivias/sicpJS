      <SUBSECTION>
        <NAME>
          <SPLITINLINE><SCHEME>Constructing Procedures using Lambda</SCHEME><JAVASCRIPT>Function Definition Expressions</JAVASCRIPT></SPLITINLINE>
          </NAME>

        <LABEL NAME="sec:lambda"/>
        <LABEL NAME="sec:introduce-let"/>

        <SPLIT>
          <SCHEME>
            <TEXT>
          In using <SCHEMEINLINE>sum</SCHEMEINLINE> as in Section<SPACE/><REF NAME="sec:procedures-as-parameters"/>,
          it seems terribly awkward to have to define trivial
          procedures such as
          <SCHEMEINLINE>pi-term</SCHEMEINLINE> and <SCHEMEINLINE>pi-next</SCHEMEINLINE> just 
          so we can use them as arguments to our higher-order
          procedure.
          Rather than define <SCHEMEINLINE>pi-next</SCHEMEINLINE> and 
          <SCHEMEINLINE>pi-term</SCHEMEINLINE>, it would be more convenient
          to have a way to directly specify <QUOTE>the
            procedure that returns its
            input incremented by 4</QUOTE> and <QUOTE>the
            procedure that returns the
            reciprocal of its input times its input plus 2.</QUOTE>  We can do this by
          introducing the special form <SCHEMEINLINE>lambda</SCHEMEINLINE>, which creates
          procedures.
          Using <SCHEMEINLINE>lambda</SCHEMEINLINE> we can describe what we want as

          <SNIPPET EVAL="no">
            <SCHEME>
(lambda (x) (+ x 4))
            </SCHEME>
          </SNIPPET>

          and 

          <SNIPPET EVAL="no">
            <SCHEME>
(lambda (x) (/ 1.0 (* x (+ x 2))))
            </SCHEME>
          </SNIPPET>
            </TEXT>
          </SCHEME>
          <JAVASCRIPT>
        <TEXT>
          In using <JAVASCRIPTINLINE>sum</JAVASCRIPTINLINE> as in Section<SPACE/><REF NAME="sec:procedures-as-parameters"/>,
          it seems terribly awkward to have to define trivial
          functions
          such as
          <JAVASCRIPTINLINE>pi_term</JAVASCRIPTINLINE> and <JAVASCRIPTINLINE>pi_next</JAVASCRIPTINLINE> just 
          so we can use them as arguments to our higher-order
          function.
          Rather than define <JAVASCRIPTINLINE>pi_next</JAVASCRIPTINLINE> and 
          <JAVASCRIPTINLINE>pi_term</JAVASCRIPTINLINE>, it would be more convenient
          to have a way to directly specify <QUOTE>the
            function that returns its
            input incremented by 4</QUOTE> and <QUOTE>the
            function that returns the
            reciprocal of its input times its input plus 2.</QUOTE>  We can do this by
          introducing <EM>function definition expressions</EM> that look just like
          function definition statements, but leave out the name of the function.
          Using this new kind of expression, we can describe what we want as

          <SNIPPET EVAL="no">
            <JAVASCRIPT>
function(x) { return x + 4; }
            </JAVASCRIPT>
          </SNIPPET>

          and 

          <SNIPPET EVAL="no">
            <JAVASCRIPT>
function(x) { return 1.0 / (x * (x + 2)); }
            </JAVASCRIPT>
          </SNIPPET>
        </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <TEXT>
          Then our 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>pi-sum</SCHEMEINLINE></SCHEME>
            <JAVASCRIPT><JAVASCRIPTINLINE>pi_sum</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          can be expressed without defining any auxiliary
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
          as

        <SNIPPET PAGE="62">
          <NAME>pi_sum_definition3</NAME>
          <REQUIRES>sum_definition</REQUIRES>
          <EXAMPLE>pi_sum_example</EXAMPLE>
          <SCHEME>
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
          </SCHEME>
          <JAVASCRIPT>
function pi_sum(a,b) {
   return sum(function(x) { return 1.0 / (x * (x + 2)); },
              a,
              function(x) { return x + 4; },
              b);
}
          </JAVASCRIPT>
        </SNIPPET>
        <!-- \indcode*{pi-sum}[lambda@with <SCHEMEINLINE>lambda</SCHEMEINLINE>] -->
        </TEXT>

        <TEXT>
          Again using 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>a function definition expression</JAVASCRIPT></SPLITINLINE>, 
          we can write the <SCHEMEINLINE>integral</SCHEMEINLINE>
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          without having to define the auxiliary
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME><SCHEMEINLINE>add-dx</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>add_dx</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
        <SNIPPET PAGE="62">
          <NAME>integral_definition2</NAME>
          <REQUIRES>sum_definition</REQUIRES>
          <REQUIRES>cube_definition</REQUIRES>
          <EXAMPLE>integral_example</EXAMPLE>
          <SCHEME>
(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
          </SCHEME>
          <JAVASCRIPT>
function integral(f,a,b,dx) {
   return sum(f,
              a + dx / 2.0,
              function(x) { return x + dx; },
              b)
          *
          dx;
}
          </JAVASCRIPT>
        </SNIPPET>
        </TEXT>
        <!--
            \indsf*{lambda}
            \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE>]
            <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>creating with <SCHEMEINLINE>lambda</SCHEMEINLINE></SUBINDEX></INDEX>
            \indsf{lambda}[define@<SCHEMEINLINE>define</SCHEMEINLINE> vs.|(]
            \indsf{define}[lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE> vs.|(]
            -->
        <SPLIT>
          <SCHEME>
        <TEXT>
          In general, <SCHEMEINLINE>lambda</SCHEMEINLINE> is used to create
          procedures in the same way as <SCHEMEINLINE>define</SCHEMEINLINE>, except that 
          <INDEX>procedure<SUBINDEX>anonymous</SUBINDEX></INDEX>
          no name is specified for the procedure:
          <SNIPPET EVAL="no">
            <SCHEME>
              (lambda (^formal-parameters^) ^body^)
            </SCHEME>
          </SNIPPET>
        </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <CHANGE><OMISSION>This similarity is more obvious in JavaScript, and was already 
                mentioned when function definition expressions were introduced.</OMISSION></CHANGE>
          </JAVASCRIPT>
        </SPLIT>
        <TEXT>
          The resulting
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          is just as much a
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          as one that is
          created using 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>define</SCHEMEINLINE></SCHEME><JAVASCRIPT>a function definition statement</JAVASCRIPT></SPLITINLINE>.  
          The only difference is that it has not
          been associated with any name in the environment.  In fact,
          <!--
              \indsf{define}[<SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>@for<SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>]
            -->
        <SNIPPET PAGE="62">
          <NAME>plus4_definition</NAME>
          <EXAMPLE>plus4_example</EXAMPLE>
          <SCHEME>
(define (plus4 x) (+ x 4))
          </SCHEME>
          <JAVASCRIPT>
function plus4(x) { return x + 4; }
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="62" HIDE="yes">
          <NAME>plus4_example</NAME>
          <SCHEME>
(plus4 3)
          </SCHEME>
          <JAVASCRIPT>
plus4(3);
          </JAVASCRIPT>
        </SNIPPET>

          is equivalent to
          <!--
              \indsf{lambda}[define@<SCHEMEINLINE>define</SCHEMEINLINE> vs.|)]
              \indsf{define}[lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE> vs.|)]
            -->
        <SNIPPET PAGE="63">
          <NAME>plus4_definition</NAME>
          <EXAMPLE>plus4_example</EXAMPLE>
          <SCHEME>
(define plus4 (lambda (x) (+ x 4)))
          </SCHEME>
          <JAVASCRIPT>
var plus4 = function(x) { return x + 4; };
          </JAVASCRIPT>
        </SNIPPET>
        </TEXT>
        <TEXT>
          We can read a 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE>
          expression as follows:
          <SNIPPET EVAL="no" LATEX="yes">
            <SCHEME>
(lambda             (x)   (+  x    4))
^\hskip17pt$\uparrow$\hskip104pt$\uparrow$\hskip30pt$\uparrow$\hskip12pt$\uparrow$\hskip28pt$\uparrow$^
^the procedure of an argument^ x ^that adds^ x ^and^ 4
            </SCHEME>
            <JAVASCRIPT>
function          (x) { return   x  +  4; }
$\hskip17pt \uparrow \hskip80pt \uparrow \hskip73pt \uparrow \hskip25pt \uparrow$
the function of an argument x    to which it adds 4
            </JAVASCRIPT>
          </SNIPPET>
        </TEXT>

        <TEXT>
          <INDEX>combination<SUBINDEX>lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE> 
              expression as operator of</SUBINDEX></INDEX>
          <!--\indcodeplus{lambda}{expression}[operator@as operator of combination] -->
          <INDEX>operator of a combination
            <SUBINDEX>lambda@<SCHEMEINLINE>lambda</SCHEMEINLINE> expression as</SUBINDEX></INDEX>
          Like any expression that has a
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          as its value, a
          <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE>
          expression can be used as the function expression in an application
          combination such as
        <SNIPPET PAGE="63">
          <REQUIRES>square_definition</REQUIRES>
          <SCHEME>
((lambda (x y z) (+ x y (square z))) 
 1 2 3)
          </SCHEME>
              <SCHEMEOUTPUT>
12
              </SCHEMEOUTPUT>
          <JAVASCRIPT>
(function(x,y,z) { 
    return x + y + square(z); 
})(1,2,3);
          </JAVASCRIPT>
        </SNIPPET>
        or, more generally, in any context where we would normally use a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        name.<SPLITINLINE><SCHEME><FOOTNOTE>It would be clearer and less intimidating to
          people learning Lisp if a name more obvious than <SCHEMEINLINE>lambda</SCHEMEINLINE>, such as
            <SCHEMEINLINE>make-procedure</SCHEMEINLINE>, were used.  But the convention is firmly
            entrenched.  The notation is adopted from the 
            <INDEX>lambda@<LATEXINLINE>$\lambda$</LATEXINLINE> calculus (lambda calculus)</INDEX>
            <LATEXINLINE>$\lambda$</LATEXINLINE> calculus, a
            <INDEX>Church, Alonzo</INDEX>
            mathematical formalism introduced by the mathematical logician Alonzo
            Church (1941).  Church developed the <LATEXINLINE>$\lambda$</LATEXINLINE> calculus to provide a
            rigorous foundation for studying the notions of function and function
            application.  The <LATEXINLINE>$\lambda$</LATEXINLINE> calculus has become a basic tool for
            mathematical investigations of the semantics of programming
            languages.</FOOTNOTE></SCHEME><JAVASCRIPT><FOOTNOTE>The idea to introduce functions without naming
              them plays a central role in the 
            <INDEX>lambda@<LATEXINLINE>$\lambda$</LATEXINLINE> calculus (lambda calculus)</INDEX>
            <LATEXINLINE>$\lambda$</LATEXINLINE> calculus, a
            <INDEX>Church, Alonzo</INDEX>
            mathematical formalism introduced by the mathematical logician Alonzo
            Church (1941).  Church developed the <LATEXINLINE>$\lambda$</LATEXINLINE> calculus 
            to provide a
            rigorous foundation for studying the notions of function and function
            application.  
            The <LATEXINLINE>$\lambda$</LATEXINLINE> calculus has become a basic tool for
            mathematical investigations of the semantics of programming
            languages.</FOOTNOTE> Note that the JavaScript parser requires parentheses 
            around the function in this case.</JAVASCRIPT></SPLITINLINE>
        </TEXT>

        <SUBHEADING>
          <NAME>Using 
            <SPLITINLINE><SCHEME><SCHEMEINLINE>let</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>var</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
            to create local variables
          </NAME>
        </SUBHEADING>
        <INDEX>local variable|(</INDEX>
        <INDEX>local name|(</INDEX>

        <TEXT>
          Another use of 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>function definition expressions</JAVASCRIPT></SPLITINLINE>
          is in creating local variables.
          We often need local variables in our
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
          other than those that have
          been bound as formal parameters.  For example, suppose we wish to
          compute the function
          <LATEX>
            \[ f(x,y)=x(1+xy)^2 +y(1-y)+(1+xy)(1-y)\]
          </LATEX>
          which we could also express as
          <LATEX>
            \begin{eqnarray*}
            a &amp;=&amp; 1+xy\\
            b &amp;=&amp; 1-y\\
            f(x,y) &amp;=&amp; xa^2 +yb +ab
            \end{eqnarray*}
          </LATEX>
          In writing a
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          to compute <LATEXINLINE>$f$</LATEXINLINE>, we would like to include as
          local variables not only <LATEXINLINE>$x$</LATEXINLINE> and 
          <LATEXINLINE>$y$</LATEXINLINE>  but also the names of
          intermediate quantities like <LATEXINLINE>$a$</LATEXINLINE> and 
          <LATEXINLINE>$b$</LATEXINLINE>.  One way to
          accomplish this is to use an auxiliary
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          to bind the local variables:
        <SNIPPET PAGE="64">
          <NAME>f_helper_definition</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <EXAMPLE>f_helper_example</EXAMPLE>
          <SCHEME>
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y)) 
            (- 1 y)))
          </SCHEME>
          <JAVASCRIPT>
function f(x,y) {
   function f_helper(a,b) {
      return x * square(a) + 
             y * b + 
             a * b;
   }
   return f_helper(1 + x * y,
                   1 - y);
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="64" HIDE="yes">
          <NAME>f_helper_example</NAME>
          <REQUIRES>f_helper_definition</REQUIRES>
          <SCHEME>
(f 3 4)
          </SCHEME>
          <JAVASCRIPT>
f(3,4);
          </JAVASCRIPT>
        </SNIPPET>
        </TEXT>

        <TEXT>
          Of course, we could use a 
          <SPLITINLINE><SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME><JAVASCRIPT>function definition</JAVASCRIPT></SPLITINLINE>
          expression to specify an anonymous
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          for binding our local variables.  The body of
          <SCHEMEINLINE>f</SCHEMEINLINE> then becomes a single call to that
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:

        <SNIPPET PAGE="64">
          <NAME>f_helper_definition2</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <EXAMPLE>f_helper_example</EXAMPLE>
          <SCHEME>
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
          </SCHEME>
          <JAVASCRIPT>
function f(x,y) {
   return function(a,b) {
             return x * square(a) + 
                    y * b + 
                    a * b;
          }(1 + x * y, 1 - y);
}
          </JAVASCRIPT>
        </SNIPPET>
        </TEXT>

        <SPLIT>
          <SCHEME>
            <TEXT>
          This construct is so useful that there is a special form called
          <SCHEMEINLINE>let</SCHEMEINLINE> to make its use more convenient.  
          Using <SCHEMEINLINE>let</SCHEMEINLINE>, the <SCHEMEINLINE>f</SCHEMEINLINE>
          procedure could be written as

        <SNIPPET PAGE="64">
          <NAME>f_helper_definition3</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <EXAMPLE>f_helper_example</EXAMPLE>
          <SCHEME>
(define (f x y)
  (let ((a (+ 1 (* x y)))
       (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
          </SCHEME>
        </SNIPPET>
        </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <TEXT>
              A more convenient way to define local variables is by using
              <JAVASCRIPTINLINE>var</JAVASCRIPTINLINE> within the body of
              the function. Variables declared this way have the entire
              function body as their scope.<FOOTNOTE>This peculiar scoping
                rule makes it rather difficult to directly 
                define a substitution model
                for functions with <JAVASCRIPTINLINE>var</JAVASCRIPTINLINE>.
                The simplest way to provide a substitution model in this
                case is to first convert the body to an equivalent form that
                uses function definition expressions as shown above.</FOOTNOTE>
              Using <JAVASCRIPTINLINE>var</JAVASCRIPTINLINE>, the 
              <JAVASCRIPTINLINE>f</JAVASCRIPTINLINE> function can be written as
        <SNIPPET PAGE="64">
          <NAME>f_helper_definition3</NAME>
          <REQUIRES>square_definition</REQUIRES>
          <EXAMPLE>f_helper_example</EXAMPLE>
          <JAVASCRIPT>
function f(x,y) {
   var a = 1 + x * y;
   var b = 1 - y;
   return x * square(a) + 
          y * b + 
          a * b;
}
          </JAVASCRIPT>
        </SNIPPET>
          </TEXT>
          </JAVASCRIPT>
        </SPLIT>

        <SPLIT>
          <SCHEME>
        <!--
            \indsf*{let}
            \ind*{special forms (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[let@<SCHEMEINLINE>let</SCHEMEINLINE>]
          -->
        <TEXT>
          The general form of a <SCHEMEINLINE>let</SCHEMEINLINE> expression is
          <SNIPPET EVAL="no">
            <SCHEME>
(let ((^var$_1$^ ^exp$_1$^)
      (^var$_2$^ ^exp$_2$^)
      ^$\vdots$^
      (^var$_n$^ ^exp$_n$^))
     ^body^)
            </SCHEME>
          </SNIPPET>
          which can be thought of as saying
          <TREETAB>
            \begin{tabular}{ll}
            let &amp;var$_1$ have the value exp$_1$\ and\\
            &amp;var$_2$ have the value exp$_2$\ and\\
            &amp;\vdots\\
            &amp;var$_n$ have the value exp$_n$\\
            in  &amp;body
            \end{tabular}
          </TREETAB>
        </TEXT>

        <TEXT>
          The first part of the <SCHEMEINLINE>let</SCHEMEINLINE> expression is a list of
          name-expression pairs.  When the <SCHEMEINLINE>let</SCHEMEINLINE> is evaluated, each name is
          associated with the value of the corresponding expression.  The body
          of the <SCHEMEINLINE>let</SCHEMEINLINE> is evaluated with
          these names bound as local variables.  The way this happens is that the <SCHEMEINLINE>let</SCHEMEINLINE> expression is interpreted as an alternate syntax for

          <SNIPPET EVAL="no">
            <SCHEME>
((lambda (^var$_1$^ ^$\ldots$^ ^var$_n$^)
   ^body^)
 ^exp$_1$^
 ^$\vdots$^
 ^exp$_n$^)
            </SCHEME>
          </SNIPPET>
        </TEXT>

        <TEXT>
          No new mechanism is required in the interpreter in order to
          provide local variables.  A 
          <INDEX>syntactic sugar<SUBINDEX>let@<SCHEMEINLINE>let</SCHEMEINLINE> as</SUBINDEX></INDEX>
          <!--\indsf{let}[syntactic@as syntactic sugar]-->
          <SCHEMEINLINE>let</SCHEMEINLINE> expression is simply syntactic sugar for
          the underlying <SCHEMEINLINE>lambda</SCHEMEINLINE> application.

          <!--\indsf{let}[scope of variables]-->
          <INDEX>scope of a variable<SUBINDEX>let@in <SCHEMEINLINE>let</SCHEMEINLINE></SUBINDEX></INDEX>
          We can see from this equivalence that
          the scope of a variable specified by a <SCHEMEINLINE>let</SCHEMEINLINE> expression is the body of
          the <SCHEMEINLINE>let</SCHEMEINLINE>.
          This implies that:
          <UL>
            <LI>
              <SCHEMEINLINE>Let</SCHEMEINLINE> allows one to
              bind variables as locally as possible to where they
              are to be used.  For example, if the value of <SCHEMEINLINE>x</SCHEMEINLINE> is 5,
              the value of the expression
        <SNIPPET PAGE="65" HIDE="yes">
          <NAME>x_definition</NAME>
          <SCHEME>
(define x 5)
          </SCHEME>
        </SNIPPET> 

        <SNIPPET PAGE="65">
          <REQUIRES>x_definition</REQUIRES>
          <SCHEME>
(+ (let ((x 3))
     (+ x (* x 10)))
   x)
          </SCHEME>
        </SNIPPET> 
              is 38.  Here, the <SCHEMEINLINE>x</SCHEMEINLINE> in the body of the <SCHEMEINLINE>let</SCHEMEINLINE> is 3,
              so the value of the <SCHEMEINLINE>let</SCHEMEINLINE> expression is 33.  On the other hand, the
              <SCHEMEINLINE>x</SCHEMEINLINE> that is the second argument to the outermost <SCHEMEINLINE>+</SCHEMEINLINE> is still<SPACE/>5.
            </LI>
            <LI>
              The variables<APOS/> values are computed outside the <SCHEMEINLINE>let</SCHEMEINLINE>.
              This matters when the expressions that
              provide the values for the local variables depend upon
              variables having the same names as the local variables themselves.
              For example, if the value of <SCHEMEINLINE>x</SCHEMEINLINE> is 2, the expression
        <SNIPPET PAGE="65" HIDE="yes">
          <NAME>x_definition2</NAME>
          <SCHEME>
(define x 2)
          </SCHEME>
        </SNIPPET> 

        <SNIPPET PAGE="65">
          <REQUIRES>x_definition2</REQUIRES>
          <SCHEME>
(let ((x 3)
      (y (+ x 2)))
  (* x y))
          </SCHEME>
        </SNIPPET> 
        will have the value 12 because, inside the body of the <SCHEMEINLINE>let</SCHEMEINLINE>,
        <SCHEMEINLINE>x</SCHEMEINLINE> will be 3 and <SCHEMEINLINE>y</SCHEMEINLINE> will be 4 (which is the
        outer <SCHEMEINLINE>x</SCHEMEINLINE> plus 2).
            </LI>
          </UL>
        </TEXT>

        <TEXT>
          <INDEX>internal definition<SUBINDEX>let@<SCHEMEINLINE>let</SCHEMEINLINE> vs.</SUBINDEX></INDEX>
          <!--\indsf{let}[internal definition vs.]-->
          Sometimes we can use internal definitions to get the same effect as
          with <SCHEMEINLINE>let</SCHEMEINLINE>.  For example, we could have 
          defined the procedure <SCHEMEINLINE>f</SCHEMEINLINE> above as
        <SNIPPET PAGE="66">
          <REQUIRES>square_definition</REQUIRES>
          <EXAMPLE>f_helper_example</EXAMPLE>
          <SCHEME>
(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
          </SCHEME>
        </SNIPPET>
        </TEXT>

        <TEXT>
          We prefer, however, to use <SCHEMEINLINE>let</SCHEMEINLINE> in 
          situations like this
          and to use internal <SCHEMEINLINE>define</SCHEMEINLINE> 
          only for internal procedures.<FOOTNOTE>Understanding 
            internal definitions well enough to be sure a
            program means what we intend it to mean requires a more elaborate
            model of the evaluation process than we have presented in this
            chapter.  The subtleties do not arise with internal definitions of
            procedures, however.  We will return to this issue in
            Section<SPACE/><REF NAME="sec:internal-definitions"/>, 
            after we learn more about evaluation.</FOOTNOTE>
          <INDEX>local variable|)</INDEX>
          <INDEX>local name|)</INDEX>
        </TEXT>
          </SCHEME>
          <JAVASCRIPT>
            <CHANGE><OMISSION>There is no concept in JavaScript that corresponds to Scheme<APOS/>s
                let. The issue of substitution model for JavaScript variables declared 
                with var is handled in the footnote above.</OMISSION></CHANGE>
          </JAVASCRIPT>
        </SPLIT>

        <EXERCISE> 
          Suppose we define the
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <SNIPPET PAGE="66">
          <NAME>fg_definition</NAME>
          <SCHEME>
(define (f g)
  (g 2))
          </SCHEME>
          <JAVASCRIPT>
function f(g) {
   return g(2);
}
          </JAVASCRIPT>
        </SNIPPET>

          Then we have

        <SNIPPET PAGE="66">
          <REQUIRES>fg_definition</REQUIRES>
          <REQUIRES>square_definition</REQUIRES>
          <SCHEME>
(f square)
          </SCHEME>
            <SCHEMEOUTPUT>
              4
            </SCHEMEOUTPUT>
          <JAVASCRIPT>
f(square);
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET PAGE="66">
          <REQUIRES>fg_definition</REQUIRES>
          <SCHEME>
(f (lambda (z) (* z (+ z 1))))
          </SCHEME>
            <SCHEMEOUTPUT>
              6
            </SCHEMEOUTPUT>
          <JAVASCRIPT>
f(function(z) { return z * (z + 1); });
          </JAVASCRIPT>
        </SNIPPET>
          What happens if we (perversely) ask the interpreter to evaluate the
          combination 
        <SPLITINLINE><SCHEME><SCHEMEINLINE>(f f)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>f(f)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>?  
        Explain.
    <SNIPPET SOLUTION="yes">
    <JAVASCRIPT>
/* Let's use the substitution model to illustrate:

(f f)
(f 2)
(2 2)

The combination (2 2) is an error, since 2 is neither a primitive nor a compound
procedure. */
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
        </EXERCISE>
      </SUBSECTION>
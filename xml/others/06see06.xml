  <MATTER>
    <NAME>
        Index Crossreferences (for proofreading)
    </NAME>


    <TEXT>

      <!-- find \ind... starting in 1.1.6 -->
      <!-- look for @ throughout chapter 1 -->

      <!--
	  %% Original 

%% Syntax is
%% \indsee{main-entry}[optional-subentry]{thing-to-see}
%% \indseealso{main-entry}[optional-subentry]{thing-to-see}
%%
%%
%% NOTE that you can't make independent calls and get them combined, like this:
%%\indsee{expression}{compound expression}
%%\indsee{expression}{primitive expression}
%%
%% They must be combined into a single item, like this:
%%\indsee{expression}{compound expression; primitive expression}

%% SYMBOLS (at start of index) refer you to name of symbol (alphabetically)
      -->

      <UL>
	<LI>
	  <INDEX><ORDER>\\t</ORDER>$\theta$<SEE>theta</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX><ORDER>\\l</ORDER>$\lambda$ calculus<SEE>lambda calculus</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX><ORDER>\\p</ORDER>$\pi$<SEE>pi</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX><ORDER>\\;</ORDER><JAVASCRIPTINLINE>;</JAVASCRIPTINLINE><SEE>constant declaration; expression statement; variable declaration</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>semicolon<SEE>constant declaration; expression statement; variable declaration</SEE><FRAGILE/></INDEX>
	</LI>

	<!--
	    %% HUMOR
	    %ch1
	-->
	<LI>
	  <INDEX>magician<SEE>numerical analyst</SEE><FRAGILE/></INDEX> 
	</LI>
	
	<!--
	    %% regular entries
	-->

	<LI>
	  <INDEX><ORDER>what is</ORDER>``what is'' vs.\ ``how to'' description<SEE>declarative vs.\ imperative knowledge</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX><ORDER>how to</ORDER>``how to'' vs.\ ``what is'' description<SEE>imperative vs.\ declarative knowledge</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>abstract data<SEEALSO>data abstraction</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>data<SUBINDEX>abstract</SUBINDEX><SEEALSO>data abstraction</SEEALSO><FRAGILE/></INDEX>
	</LI>


	<LI>
	  <INDEX>abstraction<SEEALSO>means of abstraction; data abstraction; higher-order functions</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>data abstraction<SEEALSO>metacircular evaluator</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>means of combination<SEEALSO>closure</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>combination, means of<SEEALSO>closure</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>argument passing<SEE>call-by-name argument passing;
	  call-by-need argument passing</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>parameter passing<SEE>call-by-name argument passing;
	  call-by-need argument passing</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>agenda<SEE>digital-circuit simulation</SEE><FRAGILE/></INDEX>
	</LI>


	<!--
	    <LI>
	    <INDEX>assignment operator<SEEALSO><JAVASCRIPTINLINE>=</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	    </LI>
	    <LI>
	    <INDEX>assignment<SEEALSO><JAVASCRIPTINLINE>=</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	    </LI>
	    <LI>
            <INDEX><ORDER>= (syntactic form)</ORDER><JAVASCRIPTINLINE>=</JAVASCRIPTINLINE> (syntactic form)<SEEALSO>assignment</SEEALSO></INDEX>
	    </LI>

	-->


	<LI>
	  <INDEX>backtracking<SEEALSO>nondeterministic computing</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>balanced binary tree<SEEALSO>binary tree</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>computational process<SEEALSO>process</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>code<SUBINDEX>Huffman</SUBINDEX><SEE>Huffman code</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>efficiency<SEEALSO>order of growth</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>environment<SUBINDEX>global</SUBINDEX><SEE>global environment</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>environment<SUBINDEX>compile-time</SUBINDEX><SEE>compile-time environment</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>equation, solving<SEE>half-interval method; Newton's method; <JAVASCRIPTINLINE>solve</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>roots of equation<SEE>half-interval method; Newton's method</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>solving equation<SEE>half-interval method; Newton's method; <JAVASCRIPTINLINE>solve</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>evaluation<SUBINDEX>applicative-order</SUBINDEX><SEE>applicative-order evaluation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>evaluation<SUBINDEX>normal-order</SUBINDEX><SEE>normal-order evaluation</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>evaluation<SUBINDEX>order of subexpression evaluation</SUBINDEX><SEE>order of evaluation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>order of subexpression evaluation<SEE>order of evaluation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>evaluation<SUBINDEX>delayed</SUBINDEX><SEE>delayed evaluation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>evaluation<SUBINDEX>environment model of</SUBINDEX><SEE>environment model of evaluation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>evaluation<SUBINDEX>substitution model of</SUBINDEX><SEE>substitution model of function application</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>expression<SUBINDEX>algebraic</SUBINDEX><SEE>algebraic expressions</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>arithmetic<SUBINDEX>generic</SUBINDEX><SEEALSO>generic arithmetic operations</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>efficiency<SEEALSO>order of growth</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>algebra, symbolic<SEE>symbolic algebra</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>merging infinite streams<SEE>infinite stream(s)</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>nested mappings<SEE>mapping</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>evaluator<SEEALSO>interpreter</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>interpreter<SEEALSO>evaluator</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>read-eval-print loop<SEEALSO>driver loop</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<!--
	    %following needed because so many proc names intervene
	-->

	<LI>
	  <INDEX>compilation<SEE>compiler</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>compiler for JavaScript<SUBINDEX>code generators</SUBINDEX><SEE><JAVASCRIPTINLINE>compile_...</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>compiler for JavaScript<SEEALSO>code generator; compile-time environment; instruction sequence; linkage descriptor; target register</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>needed registers<SEE>instruction sequence</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>modified registers<SEE>instruction sequence</SEE><FRAGILE/></INDEX>
	</LI>

	<!--
	    %%??? Which want as main entry: lazy or normal-order?  amb or nondeterministic?
	-->


	<LI>
	  <INDEX>evaluators<SEE>metacircular evaluator; analyzing evaluator; lazy evaluator; nondeterministic evaluator; query interpreter; explicit-control evaluator</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX><ORDER>amb eval</ORDER><JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> evaluator<SEE>nondeterministic evaluator</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>normal-order evaluator<SEE>lazy evaluator</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>expression<SEEALSO>compound expression; primitive expression</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>compound expression<SEEALSO>combination; syntactic form</SEEALSO><FRAGILE/></INDEX>
	</LI>


	<LI>
	  <INDEX>fraction<SEE>rational number(s)</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>GCD<SEE>greatest common divisor</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>iteration contructs<SEE>looping constructs</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>iterative process<SUBINDEX>implemented by function call</SUBINDEX><SEEALSO>tail recursion</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>changing money<SEE>counting change</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>making change<SEE>counting change</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>money, changing<SEE>counting change</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>mutable data objects<SEEALSO>queue; table</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>data<SUBINDEX>mutable</SUBINDEX><SEE>mutable data objects</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>string<SEE>character string</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>list(s)<SUBINDEX>empty</SUBINDEX><SEE>empty list</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>tree<SUBINDEX>binary</SUBINDEX><SEEALSO>binary tree</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>stream(s)<SUBINDEX>infinite</SUBINDEX><SEE>infinite streams</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>infinite stream(s)<SUBINDEX>of integers</SUBINDEX><SEE><JAVASCRIPTINLINE>integers</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>infinite stream(s)<SUBINDEX>of Fibonacci numbers</SUBINDEX><SEE><JAVASCRIPTINLINE>fibs</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>infinite stream(s)<SUBINDEX>of prime numbers</SUBINDEX><SEE><JAVASCRIPTINLINE>primes</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>Fibonacci numbers<SUBINDEX>infinite stream of</SUBINDEX><SEE><JAVASCRIPTINLINE>fibs</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>prime number(s)<SUBINDEX>infinite stream of</SUBINDEX><SEE><JAVASCRIPTINLINE>primes</JAVASCRIPTINLINE></SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>declaration<SEEALSO>internal definition</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>nested definitions<SEE>internal definition</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>name<SEEALSO>local name; constant; variable</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>scope of a name<SEEALSO>lexical scoping</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>name<SUBINDEX>scope of</SUBINDEX><SEEALSO>scope of a name</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>integral<SEEALSO>definite integral; Monte Carlo integration</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>differential equation<SEEALSO><JAVASCRIPTINLINE>solve</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>mathematical function<SEE>function (mathematical)</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>compound function<SEEALSO>function</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>function application<SUBINDEX>substitution model of</SUBINDEX><SEE>substitution model
	  of function application</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>function<SUBINDEX>higher-order</SUBINDEX><SEE>higher-order function</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>dispatching<SUBINDEX>on type</SUBINDEX><SEEALSO>data-directed programming</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>programming<SUBINDEX>data-directed</SUBINDEX><SEE>data-directed programming</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>programming<SUBINDEX>functional</SUBINDEX><SEE>functional programming</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>program<SUBINDEX><ORDER>structure</ORDER>structure of</SUBINDEX><SEEALSO>abstraction barriers</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>automatic search<SEEALSO>search</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>natural language<SUBINDEX>parsing</SUBINDEX><SEE>parsing natural language</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>language<SEE>natural language; programming language</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>syntax<SUBINDEX>abstract</SUBINDEX><SEE>abstract syntax</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>syntax<SEEALSO>syntactic forms</SEEALSO><FRAGILE/></INDEX>
	</LI>


	<!--
	    %  (above is instead of having each syntactic form as a subentry
	    %   of 'syntax' - - we weren't consistent about it anyway, having omitted
	    %   several syntactic forms under syntax)
	-->


	<LI>
	  <INDEX>symbolic expression<SEEALSO>symbol(s)</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>expression<SUBINDEX>symbolic</SUBINDEX><SEEALSO>symbol(s)</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>arithmetic<SUBINDEX>on polynomials</SUBINDEX><SEE>polynomial arithmetic</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>binary numbers, addition of<SEE>adder</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>implementation dependencies<SEEALSO>unspecified values</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator</SUBINDEX><SEEALSO>failure continuation;
	  success continuation</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>Euclid's Algorithm<SEEALSO>greatest common divisor</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>macro<SEEALSO>reader macro character</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>parallelism<SEE>concurrency</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>graphics<SEE>picture language</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>query<SEEALSO>simple query; compound query</SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>primitive query<SEE>simple query</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query language<SUBINDEX>simple query</SUBINDEX><SEE>simple query</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query language<SUBINDEX>compound query</SUBINDEX><SEE>compound query</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query language<SUBINDEX>rule</SUBINDEX><SEE>rule</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query interpreter<SUBINDEX>simple query</SUBINDEX><SEE>simple query</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query interpreter<SUBINDEX>compound query</SUBINDEX><SEE>compound query</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>query interpreter<SUBINDEX>rule</SUBINDEX><SEE>rule</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>frame (query interpreter)<SEEALSO>pattern matching; unification</SEEALSO><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>logic programming<SEEALSO>query language; query interpreter</SEEALSO><FRAGILE/></INDEX>
	</LI>


	<!--
	    % query lang is a particular logic-prog lang; query interp implements it
	-->


	<LI>
	  <INDEX>simulation<SUBINDEX>Monte Carlo</SUBINDEX><SEE>Monte Carlo simulation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>simulation<SUBINDEX><ORDER>register</ORDER>of register machine</SUBINDEX><SEE>register-machine simulator</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>simulation<SUBINDEX><ORDER>digital</ORDER>of digital circuit</SUBINDEX><SEE>digital-circuit simulation</SEE><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>circuit<SUBINDEX>digital</SUBINDEX><SEE>digital-circuit simulation</SEE><FRAGILE/></INDEX>
	</LI>


	<LI>
	  <INDEX>information retrieval<SEE>data base</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>LIFO buffer<SEE>stack</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>state<SUBINDEX>local</SUBINDEX><SEE>local state</SEE><FRAGILE/></INDEX>
	</LI>



	<LI>
	  <INDEX>synchronization<SEE>concurrency</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>table<SUBINDEX>operation-and-type</SUBINDEX><SEE>operation-and-type table</SEE><FRAGILE/></INDEX>
	</LI>

	<LI>
	  <INDEX>factorial<SEEALSO><JAVASCRIPTINLINE>factorial</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>Fibonacci numbers<SEEALSO><JAVASCRIPTINLINE>fib</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>greatest common divisor<SEEALSO><JAVASCRIPTINLINE>gcd</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	</LI>
	<LI>
	  <INDEX>square root<SEEALSO><JAVASCRIPTINLINE>sqrt</JAVASCRIPTINLINE></SEEALSO><FRAGILE/></INDEX>
	</LI>
      </UL>
      <!--
	  %% ???

%% It's not clear how to index abstraction vs. means of abstraction.
%% Put things like define (ch1 p.8) in both?
%% Or have one of them 'see also' the other?
%% I'm not being consistent even in p.1-8 (jems)

%% also want SEE refs from 'application of procedure' ?
      -->
    </TEXT>
    
  </MATTER>

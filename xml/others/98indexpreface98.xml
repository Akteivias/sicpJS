<!--
%% 12/17/2020 Martin receives indexcrossrefs.tex from
              Julie and copies the entries into this file,
              to be converted to XML and JavaScript terminology;
              now under git version control
%% 4/13-4/15 changes after final printout of chapters
%% 4/6/96-4/11/96 Julie
%% 4/5/96 Hal edits
%% 3/30/96 Julie
-->

<NAME>Index</NAME>

<LATEX>
  \addcontentsline{toc}{chapter}{Index}
</LATEX>

<EPIGRAPH>
Any inaccuracies in this index may be explained by the fact that it has been 
prepared with the help of a computer.
    <ATTRIBUTION>
      <AUTHOR>Donald E. Knuth</AUTHOR> 
      <TITLE>Fundamental Algorithms (Volume 1 of The~Art of Computer Programming)</TITLE>
      <INDEX>Knuth, Donald E.</INDEX>
    </ATTRIBUTION>
</EPIGRAPH>

<TEXT>
  <NOINDENT/>
Page numbers for JavaScript declarations are in italics.\\
Page numbers followed by \textit{n} indicate footnotes. 
</TEXT>
<TEXT>
  <INDEX><DECLARATION>?:</DECLARATION><SEE>conditional expression</SEE></INDEX>
  <!-- chapter 1 rough cut -->
  <!-- find \ind... starting in 1.1.6 -->
  <!-- look for @ throughout chapter 1 -->
  <!-- get rid of INDEX for EM -->


  <!--
%% Original 

%% Syntax is
%% \indsee{main-entry}[optional-subentry]{thing-to-see}
%% \indseealso{main-entry}[optional-subentry]{thing-to-see}
%%
%%
%% NOTE that you can't make independent calls and get them combined, like this:
%%\indsee{expression}{compound expression}
%%\indsee{expression}{primitive expression}
%%
%% They must be combined into a single item, like this:
%%\indsee{expression}{compound expression; primitive expression}

%% SYMBOLS (at start of index) refer you to name of symbol (alphabetically)
\indsee{$\theta$}{theta}
\indsee{$\lambda$ calculus}{lambda calculus}
\indsee{$\pi$}{pi}
\indsee{{\tt ;}}{semicolon}

%% HUMOR
%ch1
\indsee{magician}{numerical analyst}  %% should this be reversed????
%ch2
\indsee{morning star}{evening star}
\indsee{evening star}{Venus}


%% regular entries

\indsee{what is@``what is'' vs.\ ``how to'' description}{declarative
vs.\ imperative knowledge}
\indsee{how to@``how to'' vs.\ ``what is'' description}{imperative
vs.\ declarative knowledge}

\indseealso{abstract data}{data abstraction}
\indseealso{data}[abstract]{data abstraction}


\indseealso{abstraction}{means of abstraction; data abstraction;
higher-order procedures}
\indseealso{data abstraction}{metacircular evaluator}

\indseealso{means of combination}{closure}
\indseealso{combination, means of}{closure}

\indsee{argument passing}{call-by-name argument passing;
call-by-need argument passing}
\indsee{parameter passing}{call-by-name argument passing;
call-by-need argument passing}

\indsee{agenda}{digital-circuit simulation}

\indseealso{assignment operator}{{\tt set!}}
\indseealso{assignment}{{\tt set!}}
\indseealso{set! (special form)@{\tt set!} (special form)}{assignment}

\indseealso{backtracking}{nondeterministic computing}

\indseealso{balanced binary tree}{binary tree}

\indseealso{case analysis}[general]{{\tt cond}}

\indseealso{computational process}{process}

\indsee{code}[Huffman]{Huffman code}%

\indseealso{efficiency}{order of growth}

\indsee{environment}[global]{global environment}
\indsee{environment}[compile-time]{compile-time environment}

\indsee{equation, solving}{half-interval method; Newton's method; {\tt solve}}
\indsee{roots of equation}{half-interval method; Newton's method}
\indsee{solving equation}{half-interval method; Newton's method; {\tt solve}}

\indsee{evaluation}[applicative-order]{applicative-order evaluation}
\indsee{evaluation}[normal-order]{normal-order evaluation}
\indsee{evaluation}[order of subexpression evaluation]{order of evaluation}
\indsee{order of subexpression evaluation}{order of evaluation}
\indsee{evaluation}[delayed]{delayed evaluation}
\indsee{evaluation}[environment model of]{environment model of evaluation}
\indsee{evaluation}[substitution model of]{substitution model of procedure application}

\indsee{expression}[algebraic]{algebraic expressions}

\indseealso{arithmetic}[generic]{generic arithmetic operations}

\indseealso{efficiency}{order of growth}

\indsee{algebra, symbolic}{symbolic algebra}

\indsee{merging infinite streams}{infinite stream(s)}

\indsee{nested mappings}{mapping}


\indseealso{evaluator}{interpreter}
\indseealso{interpreter}{evaluator}
\indseealso{read-eval-print loop}{driver loop}

%following needed because so many proc names intervene
\indsee{compilation}{compiler}

\indsee{compiler for Scheme}[code generators]{{\tt compile-...}}
\indseealso{compiler for Scheme}{code generator; compile-time environment;
instruction sequence; linkage descriptor; target register}

\indsee{needed registers}{instruction sequence}
\indsee{modified registers}{instruction sequence}
\indsee{statements}{instruction sequence}

%%??? Which want as main entry: lazy or normal-order?  amb or nondeterministic?
\indsee{evaluators}{metacircular evaluator; analyzing evaluator;
lazy evaluator; nondeterministic evaluator; query interpreter;
explicit-control evaluator}

\indsee{amb eval@{\tt amb} evaluator}{nondeterministic evaluator}
\indsee{normal-order evaluator}{lazy evaluator}

\indseealso{expression}{compound expression; primitive expression}
\indseealso{compound expression}{combination; special form}


\indsee{fraction}{rational number(s)}

\indsee{GCD}{greatest common divisor}

\indsee{iteration contructs}{looping constructs}
\indseealso{iterative process}[implemented by procedure call]{tail recursion}

\indsee{changing money}{counting change}
\indsee{making change}{counting change}
\indsee{money, changing}{counting change}

\indseealso{mutable data objects}{queue; table}%
\indsee{data}[mutable]{mutable data objects}

\indsee{string}{character string}
\indsee{list(s)}[empty]{empty list}
\indseealso{tree}[binary]{binary tree}

\indsee{stream(s)}[infinite]{infinite streams}
\indsee{infinite stream(s)}[of integers]{{\tt integers}}
\indsee{infinite stream(s)}[of Fibonacci numbers]{{\tt fibs}}
\indsee{infinite stream(s)}[of prime numbers]{{\tt primes}}
\indsee{Fibonacci numbers}[infinite stream of]{{\tt fibs}}
\indsee{prime number(s)}[infinite stream of]{{\tt primes}}

\indsee{definition}{{\tt define}; internal definition}
\indsee{define (special form)@{\tt define} (special form)}[internal]{internal definition}
\indsee{nested definitions}{internal definition}
\indseealso{name}{local name; variable; local variable}
\indseealso{variable}{local variable}
\indseealso{scope of a variable}{lexical scoping}
\indseealso{variable}[scope of]{scope of a variable}

\indseealso{integral}{definite integral; Monte Carlo integration}
\indseealso{differential equation}{{\tt solve}}
\indsee{mathematical function}{function (mathematical)}

\indseealso{compound procedure}{procedure}
\indsee{procedure application}[substitution model of]{substitution model
of procedure application}
\indsee{procedure}[higher-order]{higher-order procedure}

\indseealso{dispatching}[on type]{data-directed programming}
\indsee{programming}[data-directed]{data-directed programming}
\indsee{programming}[functional]{functional programming}
\indseealso{program}[structure@structure of]{abstraction barriers}

\indseealso{automatic search}{search}
\indsee{natural language}[parsing]{parsing natural language}
\indsee{language}{natural language; programming language}

\indsee{syntax}[abstract]{abstract syntax}
\indseealso{syntax}{special forms}
%  (above is instead of having each special form as a subentry
%   of 'syntax' -- we weren't consistent about it anyway, having omitted
%   several special forms under syntax)

\indseealso{symbolic expression}{symbol(s)}
\indseealso{expression}[symbolic]{symbol(s)}

\indsee{arithmetic}[on polynomials]{polynomial arithmetic}

\indsee{binary numbers, addition of}{adder}

\indseealso{implementation dependencies}{unspecified values}
\indseealso{value}[expression@of an expression]{unspecified values}

\indseealso{continuation}[in nondeterministic evaluator]{failure continuation;
success continuation}

\indseealso{Euclid's Algorithm}{greatest common divisor}

\indseealso{macro}{reader macro character}

\indsee{parameter}{formal parameters}

\indsee{parallelism}{concurrency}
\indsee{graphics}{picture language}

\indseealso{query}{simple query; compound query}
\indsee{primitive query}{simple query}
\indsee{query language}[simple query]{simple query}
\indsee{query language}[compound query]{compound query}
\indsee{query language}[rule]{rule}
\indsee{query interpreter}[simple query]{simple query}
\indsee{query interpreter}[compound query]{compound query}
\indsee{query interpreter}[rule]{rule}
\indseealso{frame (query interpreter)}{pattern matching; unification}

\indseealso{logic programming}{query language; query interpreter}
% query lang is a particular logic-prog lang; query interp implements it

\indsee{simulation}[Monte Carlo]{Monte Carlo simulation}
\indsee{simulation}[register@of register machine]{register-machine simulator}
\indsee{simulation}[digital@of digital circuit]{digital-circuit simulation}
\indsee{circuit}[digital]{digital-circuit simulation}


\indsee{information retrieval}{data base}

\indsee{LIFO buffer}{stack}

\indsee{state}[local]{local state}

\indsee{synchronization}{concurrency}

\indsee{table}[operation-and-type]{operation-and-type table}

\indseealso{factorial}{{\tt factorial}}
\indseealso{Fibonacci numbers}{{\tt fib}}
\indseealso{greatest common divisor}{{\tt gcd}}
\indseealso{square root}{{\tt sqrt}}

%% ???

%% It's not clear how to index abstraction vs. means of abstraction.
%% Put things like define (ch1 p.8) in both?
%% Or have one of them 'see also' the other?
%% I'm not being consistent even in p.1-8 (jems)

%% also want SEE refs from 'application of procedure' ?



-->
  
</TEXT>

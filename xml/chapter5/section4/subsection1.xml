<SUBSECTION>
  <NAME>
    The Core of the Explicit-Control Evaluator
  </NAME>

  <LABEL NAME="sec:eceval-core"/>
  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme
      <SUBINDEX>controller|(</SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript
      <SUBINDEX>controller|(</SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

  <TEXT>
    The central element in the evaluator is the sequence of instructions
    beginning at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    This corresponds to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of the metacircular evaluator described in
    section<SPACE/><REF NAME="sec:core-of-evaluator"/>.  When the controller
    starts at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    it evaluates the expression specified by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><SCHEMEINLINE>stmt</SCHEMEINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the environment specified by <SCHEMEINLINE>env</SCHEMEINLINE>.  When
    evaluation is complete, the controller will go to the entry point stored in
    <SCHEMEINLINE>continue</SCHEMEINLINE>, and the
    <SCHEMEINLINE>val</SCHEMEINLINE> register will hold the value of the
    expression.  As with the metacircular
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>eval</SCHEMEINLINE>,
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the structure of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is a case analysis on the syntactic type of the expression to be
    evaluated.<FOOTNOTE>In our controller, the dispatch is written as a
    sequence of <SCHEMEINLINE>test</SCHEMEINLINE> and
    <SCHEMEINLINE>branch</SCHEMEINLINE> instructions.  Alternatively,
    it could have been written in a data-directed style (and in a real
    system it probably would have been) to avoid the need to perform
    sequential tests and to facilitate the definition of new expression
    types.
    <SPLITINLINE>
      <SCHEME>
        A machine designed to run Lisp would probably include a
        <SCHEMEINLINE>dispatch-on-type</SCHEMEINLINE> instruction
        that would efficiently execute such data-directed
        dispatches.
      </SCHEME>
      <JAVASCRIPT>
        Most common JavaScript implementations today do not interpret the
        JavaScript source code directly. Instead, source is transformed
        into an intermediate representation called bytecode which is
        typically interpreted in a loop similar to our dispatch functions.
        Some JavaScript interpreters are register machines, like ours --
        others are stack machines, in which operations pop and push
        operands from and to a stack instead of keeping a large number of
        registers. For performance reasons, most JavaScript interpreters
        compile commonly executed parts of a program from bytecode to
        machine code. This is called Just-In-Time compilation (JIT). We
        will address compilation in section <REF NAME="sec:compilation"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
  </FOOTNOTE>
    <!--  \indcode*{eval-dispatch} -->
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{eval-dispatch} -->
eval-dispatch
(test (op self-evaluating?) (reg exp))
(branch (label ev-self-eval))
(test (op variable?) (reg exp))
(branch (label ev-variable))
(test (op quoted?) (reg exp))
(branch (label ev-quoted))
(test (op assignment?) (reg exp))
(branch (label ev-assignment))
(test (op definition?) (reg exp))
(branch (label ev-definition))
(test (op if?) (reg exp))
(branch (label ev-if))
(test (op lambda?) (reg exp))
(branch (label ev-lambda))
(test (op begin?) (reg exp))
(branch (label ev-begin))
(test (op application?) (reg exp))
(branch (label ev-application))
(goto (label unknown-expression-type))
      </SCHEME>
      <JAVASCRIPT>
"eval_dispatch",
      test(list(op("is_literal"), reg("stmt"))),
      branch(label("ev_literal")),
      test(list(op("is_name"), reg("stmt"))),
      branch(label("ev_name")),
      test(list(op("is_application"), reg("stmt"))),
      branch(label("ev_application")),
      test(list(op("is_operator_combination"), reg("stmt"))),
      branch(label("ev_operator_combination")),
      test(list(op("is_operator_combination"), reg("stmt"))),
      branch(label("ev_operator_combination")),
      test(list(op("is_conditional"), reg("stmt"))),
      branch(label("ev_cond")),
      test(list(op("is_lambda_expression"), reg("stmt"))),
      branch(label("ev_lambda")),
      test(list(op("is_sequence"), reg("stmt"))),
      branch(label("ev_seq")),
      test(list(op("is_block"), reg("stmt"))),
      branch(label("ev_block")),
      test(list(op("is_return_statement"), reg("stmt"))),
      branch(label("ev_return")),
      test(list(op("is_function_declaration"), reg("stmt"))),
      branch(label("ev_function_declaration")),
      test(list(op("is_declaration"), reg("stmt"))),
      branch(label("ev_declaration")),
      test(list(op("is_assignment"), reg("stmt"))),
      branch(label("ev_assignment")),
      go_to(label("unknown_expression_type")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Evaluating simple expressions</NAME>
  </SUBHEADING>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme
      <SUBINDEX>expressions with no subexpressions to evaluate|(</SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript
      <SUBINDEX>expressions with no subexpressions to evaluate|(</SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

    <TEXT>
    Numbers and strings <SPLITINLINE><SCHEME>(which are self-evaluating),</SCHEME></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	variables,
	quotations,
      </SCHEME>
      <JAVASCRIPT>
	names,
      </JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>lambda</JAVASCRIPT>
    </SPLITINLINE>
    expressions have no
    subexpressions to be evaluated.  For these, the evaluator simply
    places the correct value in the
    <SCHEMEINLINE>val</SCHEMEINLINE> register and continues
    execution at the entry point specified by
    <SCHEMEINLINE>continue</SCHEMEINLINE>.  Evaluation
    of simple expressions is performed by the following controller code:
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{ev-self-eval} -->
ev-self-eval
(assign val (reg exp))
(goto (reg continue))
<!--  \indcode*{ev-variable} -->
ev-variable
(assign val (op lookup-variable-value) (reg exp) (reg env))
(goto (reg continue))
<!--  \indcode*{ev-quoted} -->
ev-quoted
(assign val (op text-of-quotation) (reg exp))
(goto (reg continue))
<!--  \indcode*{ev-lambda} -->
ev-lambda
(assign unev (op lambda-parameters) (reg exp))
(assign exp (op lambda-body) (reg exp))
(assign val (op make-procedure)
(reg unev) (reg exp) (reg env))
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_literal",
      assign("val", list(op("literal_value"), reg("stmt"))),
      go_to(reg("continue")),
      
"ev_name",
      assign("val",
        list(op("lookup_symbol_value"), reg("stmt"), reg("env"))),
      go_to(reg("continue")),
      
"ev_lambda",
      assign("unev", list(op("lambda_parameter_symbols"), reg("stmt"))),
      assign("stmt", list(op("lambda_body"), reg("stmt"))),
      assign("val", list(op("make_function"),
                         reg("unev"), reg("stmt"), reg("env"))),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
    Observe how
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-lambda</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_lambda</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    uses the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>unev</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>stmt</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    registers to hold the parameters and body of the lambda expression so
    that they can be passed to the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_compound_function</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    operation, along with the environment in <SCHEMEINLINE>env</SCHEMEINLINE>.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme
	<SUBINDEX>expressions with no subexpressions to evaluate|)</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript
	<SUBINDEX>expressions with no subexpressions to evaluate|)</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING> 
    <NAME>Evaluating
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    applications</NAME>
  </SUBHEADING>

  <SPLITINLINE>
    <SCHEME>
      <INDEX>explicit-control evaluator for Scheme
      <SUBINDEX>procedure application|(</SUBINDEX></INDEX>
      <INDEX>explicit-control evaluator for Scheme
      <SUBINDEX>combinations|(</SUBINDEX></INDEX>
    </SCHEME>
    <JAVASCRIPT>
      <INDEX>explicit-control evaluator for JavaScript
      <SUBINDEX>function application|(</SUBINDEX></INDEX>
      <INDEX>explicit-control evaluator for JavaScript
      <SUBINDEX>combinations|(</SUBINDEX></INDEX>
    </JAVASCRIPT>
  </SPLITINLINE>

  <TEXT>
    <SPLIT>
      <SCHEME>
	A procedure application is specified by a combination containing an
  <SPLITINLINE>
    <SCHEME>operator</SCHEME>
    <JAVASCRIPT>function expression</JAVASCRIPT>
  </SPLITINLINE>
  and
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>.
	The
  <SPLITINLINE>
    <SCHEME>operator</SCHEME>
    <JAVASCRIPT>function expression</JAVASCRIPT>
  </SPLITINLINE>
  is a subexpression whose value is a
	procedure, and the 
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
  are subexpressions whose values are the
	arguments to which the procedure
	should be applied.
      </SCHEME>
      <JAVASCRIPT>
	A function application is specified by a combination containing
	a function expression and argument expressions.
	The function expression is a subexpression whose value is a function,
	and the argument expressions are subexpressions whose values are the
	arguments to which the function
	should be applied.
      </JAVASCRIPT>
    </SPLIT>
    The metacircular
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    handles applications by calling itself recursively to
    evaluate each element of the combination, and then passing the results
    to <SCHEMEINLINE>apply</SCHEMEINLINE>, which performs the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application.  The
    explicit-control evaluator does the same thing; these recursive calls
    are implemented by
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>goto</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>go_to</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    instructions, together with 
    <INDEX>explicit-control evaluator for Scheme
    <SUBINDEX>stack usage</SUBINDEX></INDEX>
    use of the stack to save registers that will be restored after the recursive
    call returns.  Before each call we will be careful to identify which
    registers must be saved (because their values will be needed
    later).<FOOTNOTE>This is an important but subtle point in translating
    algorithms from a procedural language, such as
    <SPLITINLINE>
      <SCHEME>Lisp,</SCHEME>
      <JAVASCRIPT>JavaScript,</JAVASCRIPT>
    </SPLITINLINE>
    to a register-machine language.  As an alternative to saving only what is
    needed, we could save all the registers (except
    <SCHEMEINLINE>val</SCHEMEINLINE>) before each recursive call.
    This is called a 
    <INDEX>framed-stack discipline</INDEX>
    <INDEX>stack<SUBINDEX>framed</SUBINDEX></INDEX>
    <EM>framed-stack</EM> discipline.  This
    would work but might save more registers than necessary; this could be
    an important consideration in a system where stack operations are
    expensive.  Saving registers whose contents will not be needed later
    may also hold onto useless data that could otherwise be
    garbage-collected, freeing space to be reused.</FOOTNOTE>
  </TEXT>

  <TEXT>
    We begin the evaluation of an application by evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator
      </SCHEME>
      <JAVASCRIPT>
	function expression
      </JAVASCRIPT>
    </SPLITINLINE>
    to produce a
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    which will later be applied to the evaluated
    <SPLITINLINE>
      <SCHEME>
	operands.
      </SCHEME>
      <JAVASCRIPT>
	argument expressions.
      </JAVASCRIPT>
    </SPLITINLINE>
    To evaluate the
    <SPLITINLINE>
      <SCHEME>
	operator,
      </SCHEME>
      <JAVASCRIPT>
	function expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    we move it to the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>stmt</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    register and go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The environment in the <SCHEMEINLINE>env</SCHEMEINLINE> register is already
    the correct one in which to evaluate the
    <SPLITINLINE>
      <SCHEME>operator.</SCHEME>
      <JAVASCRIPT>function expression.</JAVASCRIPT>
    </SPLITINLINE>
    However, we save <SCHEMEINLINE>env</SCHEMEINLINE> because we will need it
    later to evaluate the
    <SPLITINLINE>
      <SCHEME>
	operands.
      </SCHEME>
      <JAVASCRIPT>
	argument expressions.
      </JAVASCRIPT>
    </SPLITINLINE>
    We also extract the
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    into <SCHEMEINLINE>unev</SCHEMEINLINE> and save this on the stack.  We set
    up <SCHEMEINLINE>continue</SCHEMEINLINE> so that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    will resume at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-did-operator</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>ev_appl_did_function_expression</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    after the
    <SPLITINLINE>
      <SCHEME>
	operator
      </SCHEME>
      <JAVASCRIPT>
	function expression
      </JAVASCRIPT>
    </SPLITINLINE>
    has been evaluated.  First, however, we save the old value of
    <SCHEMEINLINE>continue</SCHEMEINLINE>, which tells the controller where to
    continue after the application.
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{ev-application} -->
ev-application
(save continue)
(save env)
(assign unev (op operands) (reg exp))
(save unev)
(assign exp (op operator) (reg exp))
(assign continue (label ev-appl-did-operator))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_application",
      save("continue"),
      save("env"),
      assign("unev", list(op("args"), reg("stmt"))),
      save("unev"),
      assign("stmt", list(op("function_expression"), reg("stmt"))),
      assign("continue", label("ev_appl_did_function_expression")),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme
	<SUBINDEX>operand evaluation|(</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript
	<SUBINDEX>argument evaluation|(</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
    Upon returning from evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator subexpression,
      </SCHEME>
      <JAVASCRIPT>
	function expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    we proceed
    to evaluate the
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    of the
    <SPLITINLINE>
      <SCHEME>combination</SCHEME>
      <JAVASCRIPT>application</JAVASCRIPT>
    </SPLITINLINE>
    and to accumulate the
    resulting arguments in a list, held in <SCHEMEINLINE>argl</SCHEMEINLINE>.
    First we restore the unevaluated
    <SPLITINLINE>
      <SCHEME>
	operands
      </SCHEME>
      <JAVASCRIPT>
	argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    and the environment.  We
    initialize <SCHEMEINLINE>argl</SCHEMEINLINE> to an empty list.  Then we
    assign to the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that was produced by evaluating the
    <SPLITINLINE>
      <SCHEME>
	operator.
      </SCHEME>
      <JAVASCRIPT>
	function expression.
      </JAVASCRIPT>
    </SPLITINLINE>
    If there are
    no
    <SPLITINLINE>
      <SCHEME>
	operands,
      </SCHEME>
      <JAVASCRIPT>
	argument expressions,
      </JAVASCRIPT>
    </SPLITINLINE>
    we go directly to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Otherwise we save
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    on the stack and start the argument-evaluation
    loop:<FOOTNOTE>We add to the evaluator data-structure
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in section<SPACE/><REF NAME="sec:eval-data-structures"/> the following two
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for manipulating argument lists:
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{empty-arglist} -->
(define (empty-arglist) '())

<!--  \indcode*{adjoin-arg} -->
(define (adjoin-arg arg arglist)
  (append arglist (list arg)))
      </SCHEME>
      <JAVASCRIPT>
<!--  \indcode*{empty-arglist} -->
const empty_arglist = list();
<!--  \indcode*{adjoin-arg} --> 
function adjoin_arg(arg, arglist) {
    return append(arglist, list(arg));
}
      </JAVASCRIPT>
    </SNIPPET>
    We also use an additional syntax
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to test for the last
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    in a combination:
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{last-operand?} -->
(define (last-operand? ops)
(null? (cdr ops)))
      </SCHEME>
      <JAVASCRIPT>
<!--  \indcode*{last-operand?} -->
function is_last_argument_expression(ops) {
    return is_null(tail(ops));
}
      </JAVASCRIPT>
    </SNIPPET>
  </FOOTNOTE>
  <SNIPPET EVAL="no">
    <SCHEME>
ev-appl-did-operator
(restore unev)                  ; the operands
(restore env)
(assign argl (op empty-arglist))
(assign proc (reg val))         ; the operator
(test (op no-operands?) (reg unev))
(branch (label apply-dispatch))
(save proc)
    </SCHEME>
    <JAVASCRIPT>
"ev_appl_did_function_expression",
      restore("unev"), // the args
      restore("env"),
      assign("argl", list(op("empty_arglist"))),
      assign("fun", reg("val")), // the function_expression
      test(list(op("has_no_argument_expressions"),
                reg("unev"))),
      branch(label("apply_dispatch")),
      save("fun"),
    </JAVASCRIPT>
  </SNIPPET>
  </TEXT>

  <TEXT>
    Each cycle of the argument-evaluation loop evaluates an 
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    from the list in <SCHEMEINLINE>unev</SCHEMEINLINE> and accumulates the
    result into <SCHEMEINLINE>argl</SCHEMEINLINE>. To evaluate an
  <SPLITINLINE>
    <SCHEME>operand,</SCHEME>
    <JAVASCRIPT>argument expression,</JAVASCRIPT>
  </SPLITINLINE>
    we place it in the 
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>stmt</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    register and go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    after setting <SCHEMEINLINE>continue</SCHEMEINLINE> so that execution will
    resume with the argument-accumulation phase.  But first we save the
    arguments accumulated so far (held in <SCHEMEINLINE>argl</SCHEMEINLINE>), the
    environment (held in <SCHEMEINLINE>env</SCHEMEINLINE>), and the remaining
    <SPLITINLINE>
      <SCHEME>operands</SCHEME>
      <JAVASCRIPT>argument expressions
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated (held in <SCHEMEINLINE>unev</SCHEMEINLINE>).  A special case
    is made for the evaluation of the last
    <SPLITINLINE>
      <SCHEME>operand</SCHEME>
      <JAVASCRIPT>argument expression
      </JAVASCRIPT>
    </SPLITINLINE>
    which is handled at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-last-arg</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_appl_last_arg</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-operand-loop
(save argl)
(assign exp (op first-operand) (reg unev))
(test (op last-operand?) (reg unev))
(branch (label ev-appl-last-arg))
(save env)
(save unev)
(assign continue (label ev-appl-accumulate-arg))
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_argument_expression_loop",
      save("argl"),
      assign("stmt", list(op("first_arg"), reg("unev"))),
      test(list(op("is_last_argument_expression"),
                reg("unev"))),
      branch(label("ev_appl_last_arg")),
      save("env"),
      save("unev"),
      assign("continue", label("ev_appl_accumulate_arg")),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    When an
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    has been evaluated, the value is accumulated into the list
    held in <SCHEMEINLINE>argl</SCHEMEINLINE>.  The
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    is then removed from
    the list of unevaluated
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    in <SCHEMEINLINE>unev</SCHEMEINLINE>, and
    the argument-evaluation continues.
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-accumulate-arg
(restore unev)
(restore env)
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(assign unev (op rest-operands) (reg unev))
(goto (label ev-appl-operand-loop))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_accumulate_arg",
      restore("unev"),
      restore("env"),
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      assign("unev", list(op("rest_args"), reg("unev"))),
      go_to(label("ev_appl_argument_expression_loop")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Evaluation of the last argument is handled differently.  There is no
    need to save the environment or the list of unevaluated 
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    since they will not be required after the last
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    is evaluated.
    Thus, we return from the evaluation to a special entry point
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-accum-last-arg</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_appl_accum_last_arg</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which restores the argument list, accumulates the new argument, restores the
    saved
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and goes off to perform the application.<FOOTNOTE>The optimization of
    treating the last 
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    <INDEX>evlis tail recursion</INDEX>
    specially is known as <EM>evlis tail recursion</EM> (see 
    <INDEX>Wand, Mitchell</INDEX>
    <CITATION>Wand 1980</CITATION>). We could be somewhat more efficient
    in the argument evaluation loop if we made evaluation of the first
  <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
    a special case too.  This would permit us to postpone
    initializing <SCHEMEINLINE>argl</SCHEMEINLINE> until after evaluating the
    first
    <SPLITINLINE>
      <SCHEME>
	operand,
      </SCHEME>
      <JAVASCRIPT>
	argument expression,
      </JAVASCRIPT>
    </SPLITINLINE>
    so
    as to avoid saving <SCHEMEINLINE>argl</SCHEMEINLINE> in this case.  The
    compiler in section<SPACE/><REF NAME="sec:compilation"/> performs this
    optimization.  (Compare the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>construct-arglist</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>construct_arglist</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:compiling-combinations"/>.)</FOOTNOTE>
    <SNIPPET EVAL="no">
      <SCHEME>
ev-appl-last-arg
(assign continue (label ev-appl-accum-last-arg))
(goto (label eval-dispatch))
ev-appl-accum-last-arg
(restore argl)
(assign argl (op adjoin-arg) (reg val) (reg argl))
(restore proc)
(goto (label apply-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_appl_last_arg",
      assign("continue", label("ev_appl_accum_last_arg")),
      go_to(label("eval_dispatch")),
      
"ev_appl_accum_last_arg",
      restore("argl"),
      assign("argl", list(op("adjoin_arg"),
                          reg("val"), reg("argl"))),
      restore("fun"),
      go_to(label("apply_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>order of evaluation
    <SUBINDEX>in explicit-control evaluator</SUBINDEX></INDEX>
    The details of the argument-evaluation loop determine the order in
    which the interpreter evaluates the
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    of a combination (e.g.,
    left to right or right to left<EMDASH/>see
    exercise<SPACE/><REF NAME="ex:order-of-evaluation"/>).  This order is not
    determined by the metacircular evaluator, which inherits its control
    structure from the underlying Scheme in which it is implemented.<FOOTNOTE>The
    order of
    <SPLITINLINE>
    <SCHEME>operand</SCHEME>
    <JAVASCRIPT>argument expression</JAVASCRIPT>
  </SPLITINLINE>
  evaluation in the metacircular evaluator is determined by
    the order of evaluation of the arguments to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    in the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>list-of-values</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>list_of_values</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    of section<SPACE/><REF NAME="sec:core-of-evaluator"/>
    (see exercise<SPACE/><REF NAME="ex:arg-eval-order"/>).</FOOTNOTE>
    Because the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>first-operand</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>first_arg</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    selector (used in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-appl-operand-loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>ev_appl_argument_loop</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to extract successive
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    from <SCHEMEINLINE>unev</SCHEMEINLINE>) is implemented as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>rest-operands</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>rest_args</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    selector is implemented as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    the explicit-control evaluator will evaluate the
  <SPLITINLINE>
    <SCHEME>operands</SCHEME>
    <JAVASCRIPT>argument expressions</JAVASCRIPT>
  </SPLITINLINE>
    of a combination in left-to-right order.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme
	<SUBINDEX>operand evaluation|)</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript
	<SUBINDEX>argument evaluation|)</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <SUBHEADING> 
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedure</SCHEME>
	<JAVASCRIPT>Function</JAVASCRIPT>
      </SPLITINLINE>
    application</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:procedure-application"/>
  <TEXT>
    The entry point
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>apply-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    corresponds to the <SCHEMEINLINE>apply</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of the metacircular evaluator.  By the time we get to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>proc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    register contains the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to apply and <SCHEMEINLINE>argl</SCHEMEINLINE> contains the list of
    evaluated arguments to which it must be applied.  The saved value of
    <SCHEMEINLINE>continue</SCHEMEINLINE> (originally passed to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    and saved at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-application</SCHEMEINLINE>),</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>),
      </JAVASCRIPT>
    </SPLITINLINE>
    which tells where to return with the result of the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application, is on the stack.  When the application is complete, the
    controller transfers to the entry point specified by the saved
    <SCHEMEINLINE>continue</SCHEMEINLINE>, with the result of the application in
    <SCHEMEINLINE>val</SCHEMEINLINE>.  As with the metacircular
    <SCHEMEINLINE>apply</SCHEMEINLINE>, there are two cases to consider.  Either
    the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be applied is a primitive or it is a compound
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{apply-dispatch} -->
apply-dispatch
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-apply))
(test (op compound-procedure?) (reg proc))  
(branch (label compound-apply))
(goto (label unknown-procedure-type))
      </SCHEME>
      <JAVASCRIPT>
"apply_dispatch",
      test(list(op("is_primitive_function"),
                reg("fun"))),
      branch(label("primitive_apply")),
      test(list(op("is_compound_function"),
                reg("fun"))),
      branch(label("compound_apply")),
      go_to(label("unknown_function_type")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for Scheme<SUBINDEX>primitive
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    We assume that each primitive is implemented so as to obtain its
    arguments from <SCHEMEINLINE>argl</SCHEMEINLINE> and place its result in
    <SCHEMEINLINE>val</SCHEMEINLINE>.  To specify how the machine handles
    primitives, we would have to provide a sequence of controller instructions
    to implement each primitive and arrange for
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>primitive-apply</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>primitive_apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to dispatch to the
    instructions for the primitive identified by the
    contents of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>proc</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Since we are interested in the structure of the evaluation process rather
    than the details of the primitives, we will instead just use an
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> operation
    that applies the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    in <SCHEMEINLINE>proc</SCHEMEINLINE> to the arguments in <SCHEMEINLINE>argl</SCHEMEINLINE>.  For the purpose of simulating the evaluator with the simulator
    of section<SPACE/><REF NAME="sec:simulator"/> we use the
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-primitive-procedure</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_primitive_function</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which calls on the underlying
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    system to perform the application, just as we did for the metacircular
    evaluator in section<SPACE/><REF NAME="sec:running-eval"/>.  After computing
    the value of the primitive application, we restore
    <SCHEMEINLINE>continue</SCHEMEINLINE> and go
    to the designated entry point.
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{primitive-apply} -->
primitive-apply
(assign val (op apply-primitive-procedure)
      (reg proc)
      (reg argl))
(restore continue)
(goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"primitive_apply",
      assign("val", list(op("apply_primitive_function"), 
                         reg("fun"), 
                         reg("argl"))),
      restore("continue"),
      go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>explicit-control evaluator for Scheme<SUBINDEX>compound
    <SPLITINLINE><SCHEME>procedures</SCHEME>
    <JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE></SUBINDEX></INDEX>
    To apply a compound
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    we proceed just as with the metacircular evaluator.  We construct a frame
    that binds the
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    parameters to the arguments, use this frame to extend the environment
    carried by the
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    and evaluate in this extended environment the sequence of
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    that forms the body of the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    <SPLIT>
      <SCHEME>
        <SCHEMEINLINE>Ev-sequence</SCHEMEINLINE>, described below
        in section<SPACE/><REF NAME="sec:sequence-evaluation"/>,
        handles the evaluation of the sequence.
      </SCHEME>
      <JAVASCRIPT>
        A little extra work is needed to handle function bodies
        with a single non-return statement as these should return
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>. In this
        case, we set as continuation the label
        <JAVASCRIPTINLINE>end_without_return</JAVASCRIPTINLINE>,
        which will overwrite the contents of
        <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> by
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> before
        jumping back into the dispatch loop. This has implications
        for tail-recursion, which is discussed in
        section<SPACE/><REF NAME="sec:sequence-evaluation"/>.
        All other cases handle returns by themselves as part of
        the normal dispatch loop.
      </JAVASCRIPT>
    </SPLIT>
    <!--  \indcode*{compound-apply} -->
    <SNIPPET EVAL="no">
      <SCHEME>
compound-apply
(assign unev (op procedure-parameters) (reg proc))
(assign env (op procedure-environment) (reg proc))
(assign env (op extend-environment)
      (reg unev) (reg argl) (reg env))
(assign unev (op procedure-body) (reg proc))
(goto (label ev-sequence))
      </SCHEME>
      <JAVASCRIPT>
"compound_apply",
      assign("unev", list(op("function_parameters"), reg("fun"))),
      assign("env", list(op("function_environment"), reg("fun"))),
      assign("env", list(op("extend_environment"), 
                         reg("unev"), reg("argl"), reg("env"))),
      assign("stmt", list(op("function_body"), reg("fun"))),
      save_frame(),
      assign("continue", label("implicit_return")),
      go_to(label("eval_dispatch")),

"implicit_return",
      restore_frame(),
      assign("val", constant(undefined)),
      restore("continue"),
      go_to(reg("continue")),

"ev_return",
      restore_frame(),
      restore("continue"),
      assign("stmt", list(op("return_expression"), reg("stmt"))),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>Compound-apply</SCHEMEINLINE> is the only
        place in the interpreter where the
        <SCHEMEINLINE>env</SCHEMEINLINE> register is ever assigned a
      new value.</SCHEME>
      <JAVASCRIPT>
	      The only places in the interpreter where the
	      <SCHEMEINLINE>env</SCHEMEINLINE> register is assigned a
	      new value are
	      <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> and
	      <JAVASCRIPTINLINE>ev_block</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    
    Just as in the metacircular evaluator, the new environment is constructed
    from the environment carried by the
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    together with the argument list and the corresponding list of
    <SPLITINLINE>
      <SCHEME>variables</SCHEME>
      <JAVASCRIPT>names</JAVASCRIPT>
    </SPLITINLINE>
    to be bound.
    <SPLITINLINE>
      <SCHEME>
	<INDEX>explicit-control evaluator for Scheme
	<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME>
	<JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
	application|)</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for Scheme
	<SUBINDEX>combinations|)</SUBINDEX></INDEX>
      </SCHEME>
      <JAVASCRIPT>
	<INDEX>explicit-control evaluator for JavaScript
	<SUBINDEX>function application|)</SUBINDEX></INDEX>
	<INDEX>explicit-control evaluator for JavaScript
	<SUBINDEX>combinations|)</SUBINDEX></INDEX>
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

    <SPLIT>
      <JAVASCRIPT>
        <TEXT>
          To simplify the treatment of unwinding the stack after a function
          call, we extend the stack in <REF NAME="sec:machine-model"/> with two
          new commands <JAVASCRIPTINLINE>save_frame</JAVASCRIPTINLINE> and
          <JAVASCRIPTINLINE>restore_frame</JAVASCRIPTINLINE>. These commands can
          be implemented using <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and
          <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> and demarcates the
          boundary of the current stack frame, and the new. This marker allows
          returning from any point in a function, and dynamically unwinding the
          stack using the marker as an end condition.
        </TEXT>
        <TEXT>
          Inside a return statement, we unwind the stack before proceeding to
          evaluate the expression that defines the return value. Unwinding the
          stack <EM>before</EM> this evaluation does not pose a problem as
          <JAVASCRIPTINLINE>env</JAVASCRIPTINLINE> and
          <JAVASCRIPTINLINE>unev</JAVASCRIPTINLINE> are unaffected by operations
          on the stack. 
        </TEXT>
        <TEXT>
          To deal with the JavaScript idiosyncrasy that functions that do not
          explicitly return a value returns
          <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>, the evaluator a
          special handler <JAVASCRIPTINLINE>implicit_return</JAVASCRIPTINLINE>
          that sets <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> to
          <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>. All function calls are
          set up with this continuation after the call to
          <JAVASCRIPTINLINE>save_frame</JAVASCRIPTINLINE>. Thus, an explicit
          return's call to <JAVASCRIPTINLINE>restore_frame</JAVASCRIPTINLINE>
          will skip over the handler which preserves the return value.
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>

  <SUBHEADING> 
    <NAME>Sequence Evaluation</NAME>
  </SUBHEADING>

  <LABEL NAME="sec:sequence-evaluation"/>
  <INDEX>explicit-control evaluator for Scheme
  <SUBINDEX>sequences of expressions|(</SUBINDEX></INDEX>

  <TEXT>
    The portion of the explicit-control evaluator at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is analogous to the metacircular evaluator<APOS/>s
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_sequence</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    It handles sequences of expressions in
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    bodies or in 
    <SPLITINLINE>
      <SCHEME>explicit <SCHEMEINLINE>begin</SCHEMEINLINE> expressions.</SCHEME>
      <JAVASCRIPT>sequences of statements.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>explicit<SCHEMEINLINE>begin</SCHEMEINLINE> expressions</SCHEME>
      <JAVASCRIPT>Sequences of statements</JAVASCRIPT>
    </SPLITINLINE>
    are evaluated by placing the 
    <SPLITINLINE>
      <SCHEME>
	sequence of expressions
      </SCHEME>
      <JAVASCRIPT>
	sequence
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated in
    <SCHEMEINLINE>unev</SCHEMEINLINE>, saving
    <SCHEMEINLINE>continue</SCHEMEINLINE> on the
    stack, and jumping to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    <!--  \indcode*{ev-begin} -->
    <SNIPPET EVAL="no">
      <SCHEME>
ev-begin
(assign unev (op begin-actions) (reg exp))
(save continue)
(goto (label ev-sequence))
      </SCHEME>
      <JAVASCRIPT>
"ev_seq",
      save("continue"),
      assign("unev", list(op("sequence_statements"), reg("stmt"))),
      </JAVASCRIPT>
    </SNIPPET>

    
    <SPLITINLINE>
      <SCHEME>The implicit sequences in procedure</SCHEME>
      <JAVASCRIPT>All sequences in function</JAVASCRIPT>
    </SPLITINLINE>
    bodies are handled by jumping to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE> from</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE> via</JAVASCRIPT>
    </SPLITINLINE>
    
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compound-apply</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_seq</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    at which point <SCHEMEINLINE>continue</SCHEMEINLINE> is already on the stack,
    having been saved at
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>ev-application</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    The entries at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-continue</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    form a loop that successively evaluates each
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    in a sequence.  The
    list of unevaluated
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    is kept in <SCHEMEINLINE>unev</SCHEMEINLINE>.
    Before evaluating each
    <SPLITINLINE>
      <SCHEME>
	expression,
      </SCHEME>
      <JAVASCRIPT>
	statement,
      </JAVASCRIPT>
    </SPLITINLINE>
    we check to see if there are additional
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated in the sequence.  If so, we save the rest of the
    unevaluated
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    (held in <SCHEMEINLINE>unev</SCHEMEINLINE>) and the
    environment in which these must be evaluated (held in
    <SCHEMEINLINE>env</SCHEMEINLINE>) and call
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to evaluate the
    <SPLITINLINE>
      <SCHEME>
	expression.
      </SCHEME>
      <JAVASCRIPT>
	statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    The two saved registers are restored upon
    the return from this evaluation, at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-continue</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_sequence_continue</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    The final
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    in the sequence is handled differently, at the
    entry point
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-sequence-last-exp</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>ev_sequence_last_stmt</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Since there are no more
    <SPLITINLINE>
      <SCHEME>
	expressions
      </SCHEME>
      <JAVASCRIPT>
	statements
      </JAVASCRIPT>
    </SPLITINLINE>
    to be evaluated after this one, we need
    not save <SCHEMEINLINE>unev</SCHEMEINLINE> or
    <SCHEMEINLINE>env</SCHEMEINLINE> before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>.
    </JAVASCRIPT></SPLITINLINE>
    The value of the whole sequence is the value of the last
    <SPLITINLINE>
      <SCHEME>
	expression,
      </SCHEME>
      <JAVASCRIPT>
	statement,
      </JAVASCRIPT>
    </SPLITINLINE>
    so
    after the evaluation of the last
    <SPLITINLINE>
      <SCHEME>
	expression
      </SCHEME>
      <JAVASCRIPT>
	statement
      </JAVASCRIPT>
    </SPLITINLINE>
    there is nothing left to do
    except continue at the entry point currently held on the stack (which was
    saved by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-application</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    or
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>ev-begin</SCHEMEINLINE>.)</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>ev_seq</JAVASCRIPTINLINE>.)</JAVASCRIPT>
    </SPLITINLINE>
    Rather than setting up <SCHEMEINLINE>continue</SCHEMEINLINE> to arrange for
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to return here and then restoring <SCHEMEINLINE>continue</SCHEMEINLINE> from
    the stack and continuing at that entry point, we restore
    <SCHEMEINLINE>continue</SCHEMEINLINE> from the stack before going to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    so that
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    will continue at that entry point after evaluating the
    <SPLITINLINE>
      <SCHEME>
	expression.
      </SCHEME>
      <JAVASCRIPT>
	statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
<!--  \indcode*{ev-sequence}[with tail recursion] -->
ev-sequence
(assign exp (op first-exp) (reg unev))
(test (op last-exp?) (reg unev))
(branch (label ev-sequence-last-exp))
(save unev)
(save env)
(assign continue (label ev-sequence-continue))
(goto (label eval-dispatch))
ev-sequence-continue
(restore env)
(restore unev)
(assign unev (op rest-exps) (reg unev))
(goto (label ev-sequence))
ev-sequence-last-exp
(restore continue)
(goto (label eval-dispatch))
      </SCHEME>
      <JAVASCRIPT>
"ev_sequence",
      assign("stmt", list(op("first_statement"), reg("unev"))),
      test(list(op("is_last_statement"), reg("unev"))),
      branch(label("ev_sequence_last_exp")),
      save("unev"),
      save("env"),
      assign("continue", label("ev_sequence_continue")),
      go_to(label("eval_dispatch")),
      
"ev_sequence_continue",
      restore("env"),
      restore("unev"),
      assign("unev", list(op("rest_statements"), reg("unev"))),
      go_to(label("ev_sequence")),

"ev_sequence_last_exp",
      restore("continue"),
      go_to(label("eval_dispatch")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

    
</SUBSECTION>

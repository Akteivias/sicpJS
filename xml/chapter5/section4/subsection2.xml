<SUBSECTION>
  <NAME>
    Return Statements and Tail Recursion
  </NAME>

  <LABEL NAME="sec:tail-recursion-return"/>

  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<OPEN/></SUBINDEX></INDEX>
  <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<OPEN/></SUBINDEX></INDEX>
  <TEXT>
    In chapter<SPACE/>1 we said that the process described by a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SNIPPET EVAL="no">
      <SCHEME>
(define (sqrt-iter guess x)
(if (good-enough? guess x)
guess
(sqrt-iter (improve guess x)
      x)))
      </SCHEME>
      <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
      </JAVASCRIPT>
    </SNIPPET>
    is an iterative process.  Even though the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is syntactically recursive (defined in terms of itself), it is not logically
    necessary for an evaluator to save information in passing from one call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to the next.<FOOTNOTE>We saw in
    section<SPACE/><REF NAME="sec:designing-register-machines"/> how to
    implement such a process with a register machine that had no stack; the
    state of the process was stored in a fixed set of registers.</FOOTNOTE> An
    evaluator that can execute a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    without requiring increasing storage as the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    continues to call itself is called a 
    <INDEX>tail-recursive evaluator</INDEX>
    <EM>tail-recursive</EM> evaluator.  
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>no tail recursion in</SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>metacircular evaluator and</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
        The metacircular implementation of the evaluator in chapter<SPACE/>4
        does not specify whether the evaluator is tail-recursive, because that
        evaluator inherits its mechanism for saving state from the underlying
        Scheme. With the explicit-control evaluator, however, we can trace
        through the evaluation process to see when procedure calls cause a net
        accumulation of information on the stack.
      </SCHEME>
      <JAVASCRIPT>
        The implementation of the metacircular evaluator in chapter<SPACE/>4 is
        not tail-recursive. The reason for this is found in the handling of
        sequences and relates to returning from functions. After the evaluation
        of a statement, we inspect the result to see if the function is
        returning or not. If it is, we return the result. If it is not, we
        continue evaluating the next statement or return
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> if there are no more
        statements to evaluate. In a process that computes a value through a
        nested sequence of function calls, such as
        <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> above, this causes a
        build-up of deferred checking operations, which leads to an accumulation
        of information on the stack.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
        Our evaluator is tail-recursive, because in order to evaluate the final
        expression of a sequence we transfer directly to
        <SCHEMEINLINE>eval-dispatch</SCHEMEINLINE> without saving any
        information on the stack. Hence, evaluating the final expression in a
        sequence<EMDASH/>even if it is a procedure call (as in
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>, where the
        <SCHEMEINLINE>if</SCHEMEINLINE> expression, which is the last expression
        in the procedure body, reduces to a call to
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>)<EMDASH/>will not cause any
        information to be accumulated on the stack.
      </SCHEME>
      <JAVASCRIPT>
        Because our explicit-control evaluator is tail-recursive, accumulation
        of information such as in the metacircular evaluator is avoided. When we
        evaluate a <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> statement, we
        first remove anything saved by the current function on the stack, and
        restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>. Thus, right before 
        proceeding to evaluate the return expression, the information 
        on the stack is the same as at the start of
        <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>, just before the
        call to the function whose return value we are about to compute. We then
        place the return expression in <JAVASCRIPTINLINE>comp</JAVASCRIPTINLINE>
        and transfer directly to
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> without any additional saves.<!--
   --></JAVASCRIPT><!-- 
 --></SPLIT><FOOTNOTE>This implementation of tail
        recursion in <SCHEMEINLINE>ev-sequence</SCHEMEINLINE> is one variety of
        a well-known optimization technique used by many compilers. In compiling
        a procedure that ends with a procedure call, one can replace the call by
        a jump to the called procedure<APOS/>s entry point. Building this
        strategy into the interpreter, as we have done in this section, provides
        the optimization uniformly throughout the language.
      </FOOTNOTE>

      <TEXT>
        <SPLIT>
          <SCHEME>
          If we did not think to take advantage of the fact that it was unnecessary to
          save information in this case, we might have implemented
          <SCHEMEINLINE>eval-sequence</SCHEMEINLINE>
          by treating all the expressions in a sequence in the same way<EMDASH/>saving
          the registers, evaluating the expression, returning to restore the registers,
          and repeating this until all the expressions have been
          evaluated:<FOOTNOTE>We can define
          <SCHEMEINLINE>no-more-exps?</SCHEMEINLINE>
          as follows:
          <SNIPPET EVAL="no">
            <SCHEME>
              (define (no-more-exps? seq) (null? seq))
            </SCHEME>
          </SNIPPET></FOOTNOTE>
          <INDEX><DECLARATION>ev_sequence</DECLARATION><SUBINDEX>without tail recursion</SUBINDEX></INDEX>
          <SNIPPET EVAL="no">
            <SCHEME>
            ev-sequence
            (test (op no-more-exps?) (reg unev))
            (branch (label ev-sequence-end))
            (assign exp (op first-exp) (reg unev))
            (save unev)
            (save env)
            (assign continue (label ev-sequence-continue))
            (goto (label eval-dispatch))
            ev-sequence-continue
            (restore env)
            (restore unev)
            (assign unev (op rest-exps) (reg unev))
            (goto (label ev-sequence))
            ev-sequence-end
            (restore continue)
            (goto (reg continue))
            </SCHEME>
          </SNIPPET>

        This may seem like a minor change to our previous code for evaluation of
        a sequence: The only difference is that we go through the save-restore
        cycle for the last expression in a sequence as well as for the others.
        The interpreter will still give the same value for any expression. But
        this change is fatal to the tail-recursive implementation, because we
        must now return after evaluating the final expression in a sequence in
        order to undo the (useless) register saves. These extra saves will
        accumulate during a nest of procedure calls. Consequently, processes
        such as <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE> will require space
        proportional to the number of iterations rather than requiring constant
        space.
          </SCHEME>
      <JAVASCRIPT>
If we think of <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> as an operator and the return expression as
its operand, we might consider it more intuitive to evaluate
<JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> statements by first computing the return value, and then restore the
stack:
          <!-- FIXME: mislabelling of index? -->
	        <INDEX><DECLARATION>ev_sequence</DECLARATION><SUBINDEX>without tail recursion</SUBINDEX></INDEX>
          <SNIPPET EVAL="no">
            <JAVASCRIPT>
"ev_return",
      assign("comp", list(op("return_expression"), reg("comp"))),
      assign("continue", label("ev_restore_stack")),
      save("continue"),
      go_to(label("eval_dispatch")),

"ev_restore_stack",
      restore_marker("continue"),
      restore("continue"),
      go_to(reg("continue")),
            </JAVASCRIPT>
          </SNIPPET>

        This may seem like a minor change to our previous code for evaluation of
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> statements.  However, 
        this not only keeps the useless information on the stack
        during the evaluation of the return expression, but additionally saves
        <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> to ensure an eventual
        jump back to <JAVASCRIPTINLINE>ev_restore_stack</JAVASCRIPTINLINE> to
        restore the stack and jumping to the continuation of the function
        call. Even if there are never any saves by the current
        function<FOOTNOTE>With our current design, there will always be at
        least one: a save of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> in
        <JAVASCRIPTINLINE>ev_sequence_start</JAVASCRIPTINLINE>.</FOOTNOTE>,
        the last save of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> will
        accumulate during a nest of function calls. In this design, processes
        such as <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> would require
        space proportional to the number of iterations rather than requiring
        constant space.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>
  <TEXT>
    This difference can be significant. For example,
    <INDEX>iterative process<SUBINDEX>implemented by <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> call</SUBINDEX></INDEX>
    with tail recursion, an infinite loop can be expressed using only the
    <SPLITINLINE>
      <SCHEME>procedure-call mechanism:</SCHEME>
      <JAVASCRIPT>function-call and <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> mechanisms:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (count n)
      (newline)
      (display n)
      (count (+ n 1)))
      </SCHEME>
      <JAVASCRIPT>
function count(n) {
    display(n);
    return count(n + 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Without tail recursion, such a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would eventually run out of stack space, and expressing a true iteration
    would require some control mechanism other than
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call.
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        Note that our JavaScript implementation is tail-recursive only in the
        presence of an explicit <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE>
        statement. A function that ends without an explicit
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> statement will go to the
        implicit return handler
        <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE>, which stores
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> in the
        <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> register. Thus, removing
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> from the above count
        function will cause it to eventually run out of stack space.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<CLOSE/></SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<CLOSE/></SUBINDEX></INDEX>
    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>sequences of statements<CLOSE/></SUBINDEX></INDEX>
  </TEXT>
</SUBSECTION>

<SUBSECTION>
  <NAME>
    Return Statements and Tail Recursion
  </NAME>

  <LABEL NAME="sec:tail-recursion-return"/>

  <INDEX>explicit-control evaluator for Scheme<SUBINDEX>tail recursion<OPEN/></SUBINDEX></INDEX>
  <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<OPEN/></SUBINDEX></INDEX>
  <TEXT>
    In chapter<SPACE/>1 we said that the process described by a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SNIPPET EVAL="no">
      <SCHEME>
(define (sqrt-iter guess x)
(if (good-enough? guess x)
guess
(sqrt-iter (improve guess x)
      x)))
      </SCHEME>
      <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
      </JAVASCRIPT>
    </SNIPPET>
    is an iterative process.  Even though the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is syntactically recursive (defined in terms of itself), it is not logically
    necessary for an evaluator to save information in passing from one call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to the next.<FOOTNOTE>We saw in
    section<SPACE/><REF NAME="sec:designing-register-machines"/> how to
    implement such a process with a register machine that had no stack; the
    state of the process was stored in a fixed set of registers.</FOOTNOTE> An
    evaluator that can execute a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    without requiring increasing storage as the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    continues to call itself is called a 
    <INDEX>tail-recursive evaluator</INDEX>
    <EM>tail-recursive</EM> evaluator.  
    <INDEX>metacircular evaluator for Scheme<SUBINDEX>tail recursiveness unspecified in</SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>metacircular evaluator and</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
        The metacircular implementation of the evaluator in chapter<SPACE/>4 does
        not specify whether the evaluator is tail-recursive, because that evaluator
        inherits its mechanism for saving state from the underlying Scheme.
      </SCHEME>
      <JAVASCRIPT>
        The metacircular implementation of the evaluator in chapter<SPACE/>4 is
        not tail-recursive, because of the need to check whether the
        evaluation of the function body returns explicitly or not.
      </JAVASCRIPT>
    </SPLIT>
    With
    the explicit-control evaluator, however, we can trace through the evaluation
    process to see when
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    calls cause a net accumulation of information on the stack.
  </TEXT>

  <TEXT>
    Our evaluator is tail-recursive, because in order to evaluate 
    <SPLITINLINE>
      <SCHEME>
	      the final expression of a sequence 
      </SCHEME>
      <JAVASCRIPT>
	      a return statement in a function body
      </JAVASCRIPT>
    </SPLITINLINE>
    we transfer directly to
    <SPLITINLINE>
      <SCHEME>
        <SCHEMEINLINE>eval-dispatch</SCHEMEINLINE> without saving any information on the stack. 
        Hence, evaluating the final expression in a sequence<EMDASH/>even if it is a
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> after having restored the stack using the marker introduced
        by <JAVASCRIPTINLINE>save_marker</JAVASCRIPTINLINE>.
        Hence, evaluating a return statement in a function body<EMDASH/>even if it contains a
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call (as in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    where the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>if</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>conditional</JAVASCRIPT>
    </SPLITINLINE>
     expression, which is the last 
    <SPLITINLINE>
      <SCHEME>expression in the procedure</SCHEME>
      <JAVASCRIPT>component in the function</JAVASCRIPT>
    </SPLITINLINE>
    body, reduces to a call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>)<EMDASH/>will </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>)<EMDASH/>will
      </JAVASCRIPT>
    </SPLITINLINE>
    not cause any information to be accumulated on the stack.<FOOTNOTE>This
    implementation of tail recursion 
    <SPLITINLINE>
      <SCHEME>in <SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME>
    </SPLITINLINE>
    is one variety of a well-known optimization technique used
    by many compilers.  In compiling a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that ends with a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call, one can replace the call by a jump to the called
    <SPLITINLINE>
      <SCHEME>procedure<APOS/>s</SCHEME>
      <JAVASCRIPT>function<APOS/>s</JAVASCRIPT>
    </SPLITINLINE>
    entry point. Building this strategy into the interpreter, as we have done in
    this section, provides the optimization uniformly throughout the
    language.</FOOTNOTE> 

    <SPLIT>
      <SCHEME>
  <TEXT>
    If we did not think to take advantage of the fact that it was unnecessary to
    save information in this case, we might have implemented
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval-sequence</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>eval_sequence</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    by treating all the expressions in a sequence in the same way<EMDASH/>saving
    the registers, evaluating the expression, returning to restore the registers,
    and repeating this until all the expressions have been
    evaluated <SPLITINLINE><JAVASCRIPT>(for simplicity, ignoring the handling of returns which are not needed to illustrate this point)</JAVASCRIPT></SPLITINLINE>:<FOOTNOTE>We can define
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>no-more-exps?</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>has_no_more_comps</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    as follows:
    <INDEX><DECLARATION>has_no_more_exps</DECLARATION></INDEX> 
    <SNIPPET EVAL="no">
      <SCHEME>
        (define (no-more-exps? seq) (null? seq))
      </SCHEME>
      <JAVASCRIPT>
function has_no_more_exps(seq) {
    return is_null(seq);
}
      </JAVASCRIPT>
    </SNIPPET></FOOTNOTE>
    <INDEX><DECLARATION>ev_sequence</DECLARATION><SUBINDEX>without tail recursion</SUBINDEX></INDEX>
    <SNIPPET EVAL="no">
      <SCHEME>
      ev-sequence
      (test (op no-more-exps?) (reg unev))
      (branch (label ev-sequence-end))
      (assign exp (op first-exp) (reg unev))
      (save unev)
      (save env)
      (assign continue (label ev-sequence-continue))
      (goto (label eval-dispatch))
      ev-sequence-continue
      (restore env)
      (restore unev)
      (assign unev (op rest-exps) (reg unev))
      (goto (label ev-sequence))
      ev-sequence-end
      (restore continue)
      (goto (reg continue))
      </SCHEME>
      <JAVASCRIPT>
"ev_sequence",
     test(list(op("has_no_more_comps"), reg("unev"))),
     branch(label("ev_sequence_end")),
     assign(exp(op("first_comp"), reg("unev")),
     save("unev"),
     save("env"),
     assign("continue", label("ev_sequence_continue")),
     go_to(label("eval_dispatch")),
"ev_sequence_continue",
     restore("env"),
     restore("unev"),
     assign("unev", op("rest_comps"), reg("unev")),
     go_to(label("ev_sequence")),
"ev_sequence_end",
     restore("continue"),
     go_to(reg("continue")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
      </SCHEME>
      <JAVASCRIPT>
        <TEXT>
          If we did not think to take advantage of the fact that it was unnecessary to
          save information in this case, we might have implemented 
          <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>
          in a more intuitive way, by first evaluating the return expression before popping the stack (down to the marker):
          <SNIPPET EVAL="no">
            <JAVASCRIPT>
"ev_return",
      assign("comp", list(op("return_expression"), reg("comp"))),
      assign("continue", label("ev_restore_stack")),
      save("continue"),
      go_to(label("eval_dispatch")),

"ev_restore_stack",
      restore_marker("continue"),
      restore("continue"),
      go_to(reg("continue")),
            </JAVASCRIPT>
          </SNIPPET>
        </TEXT>
      </JAVASCRIPT>
    </SPLIT>
    
  <TEXT>
    <SPLITINLINE>
      <SCHEME>
        This may seem like a minor change to our previous code for
        evaluation of a sequence: The only difference is that we go through
        the save-restore cycle for the last expression in a sequence as well
        as for the others.
      </SCHEME>
      <JAVASCRIPT>
        This may seem like a minor change to <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE> as defined in section<SPACE/><REF NAME="sec:eceval-core"/>.
      </JAVASCRIPT>
    </SPLITINLINE>
    The interpreter will still give the same value for any
    <SPLITINLINE>
      <SCHEME>
        expression.
      </SCHEME>
      <JAVASCRIPT>
        statement.
      </JAVASCRIPT>
    </SPLITINLINE>
    But this change is fatal to the tail-recursive implementation, because we
    must now return after evaluating the 
    <SPLITINLINE>
      <SCHEME>
        final expression in a sequence in order to undo the (useless) register saves. These extra saves 
      </SCHEME>
      <JAVASCRIPT>
        expression inside the return statement in order to undo the (useless) register save. These extra saves 
      </JAVASCRIPT>
    </SPLITINLINE>
    will accumulate during a nest of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    calls.  Consequently, processes such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    will require space proportional to the number of iterations rather than
    requiring constant space.  This difference can be significant. For example,
    <INDEX>iterative process<SUBINDEX>implemented by <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> call</SUBINDEX></INDEX>
    with tail recursion, an infinite loop can be expressed using only the
    <SPLITINLINE>
      <SCHEME>procedure-call</SCHEME>
      <JAVASCRIPT>function-call</JAVASCRIPT>
    </SPLITINLINE>
    mechanism:
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (count n)
      (newline)
      (display n)
      (count (+ n 1)))
      </SCHEME>
      <JAVASCRIPT>
function count(n) {
    display(n);
    return count(n + 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Without tail recursion, such a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would eventually run out of stack space, and expressing a true iteration
    would require some control mechanism other than
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call.
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        Note that our JavaScript implementation is tail-recursive only in the presence of an
        explicit return statement. A function that ends without an explicit return statement will 
        go to the implicit return handler <JAVASCRIPTINLINE>return_undefined</JAVASCRIPTINLINE>, which stores
        <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> in the <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE> register.
        Thus, removing <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> from the above count function will
        eventually run out of stack space.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

    <INDEX>explicit-control evaluator for Scheme<SUBINDEX>tail recursion<CLOSE/></SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<CLOSE/></SUBINDEX></INDEX>
    <INDEX>explicit-control evaluator for Scheme<SUBINDEX>sequences of expressions<CLOSE/></SUBINDEX></INDEX>
  </TEXT>

</SUBSECTION>

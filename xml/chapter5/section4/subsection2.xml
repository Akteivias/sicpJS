<SUBSECTION>
  <NAME>
    Return Statements and Tail Recursion
  </NAME>

  <LABEL NAME="sec:tail-recursion-return"/>

  <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<OPEN/></SUBINDEX></INDEX>
  <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<OPEN/></SUBINDEX></INDEX>
  <TEXT>
    In chapter<SPACE/>1 we said that the process described by a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SNIPPET EVAL="no">
      <SCHEME>
(define (sqrt-iter guess x)
(if (good-enough? guess x)
guess
(sqrt-iter (improve guess x)
      x)))
      </SCHEME>
      <JAVASCRIPT>
function sqrt_iter(guess, x) {
    return is_good_enough(guess, x)
           ? guess
           : sqrt_iter(improve(guess, x), x);
}
      </JAVASCRIPT>
    </SNIPPET>
    is an iterative process.  Even though the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is syntactically recursive (defined in terms of itself), it is not logically
    necessary for an evaluator to save information in passing from one call to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    to the next.<FOOTNOTE>We saw in
    section<SPACE/><REF NAME="sec:designing-register-machines"/> how to
    implement such a process with a register machine that had no stack; the
    state of the process was stored in a fixed set of registers.</FOOTNOTE> An
    evaluator that can execute a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    such as
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>sqrt-iter</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    without requiring increasing storage as the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    continues to call itself is called a 
    <INDEX>tail-recursive evaluator</INDEX>
    <EM>tail-recursive</EM> evaluator.  
    <INDEX>metacircular evaluator for JavaScript<SUBINDEX>no tail recursion in</SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>metacircular evaluator and</SUBINDEX></INDEX>
    <SPLIT>
      <SCHEME>
        The metacircular implementation of the evaluator in chapter<SPACE/>4
        does not specify whether the evaluator is tail-recursive, because that
        evaluator inherits its mechanism for saving state from the underlying
        Scheme. With the explicit-control evaluator, however, we can trace
        through the evaluation process to see when procedure calls cause a net
        accumulation of information on the stack.
      </SCHEME>
      <JAVASCRIPT>
        The implementation of the metacircular evaluator in chapter<SPACE/>4 is
        not tail-recursive. The reason for this is found in the handling of
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> as an operator that creates
        a return value object containing the value to be returned and inspecting the result of a function call to
        see whether it is such an object.
        If the evaluation of a function body produces a return value object, its content
        is the return value of the function. 
        Otherwise, the return value is <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE>.
        Both the construction of the return value object and the eventual inspection of
        the result of the function call are deferred operations, which lead to an
        accumulation of information on the stack.
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
        Our evaluator is tail-recursive, because in order to evaluate the final
        expression of a sequence we transfer directly to
        <SCHEMEINLINE>eval-dispatch</SCHEMEINLINE> without saving any
        information on the stack. Hence, evaluating the final expression in a
        sequence<EMDASH/>even if it is a procedure call (as in
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>, where the
        <SCHEMEINLINE>if</SCHEMEINLINE> expression, which is the last expression
        in the procedure body, reduces to a call to
        <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE>)<EMDASH/>will not cause any
        information to be accumulated on the stack.
      </SCHEME>
      <JAVASCRIPT> 
        Our evaluator is tail-recursive, because in order to evaluate the expression that
        computes the return value of a function, we transfer directly to
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> with nothing more on the stack
        than right before the function call. <!-- Thus, return expressions that do not -->
        <!-- lead to deferred operations will result in tair-recursive  -->

        We accomplish this by undoing any saves to the stack by the function (which are
        useless as we are returning) using
        <JAVASCRIPTINLINE>restore_marker</JAVASCRIPTINLINE>.

        Then, rather than arranging for <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE>
        to return here and then restore <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>
        from the stack and continuing at that entry point, we restore
        <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> from the stack before going to
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> so that
        <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> will continue at that entry
        point after evaluating the expression. 

        Finally, we transfer to <JAVASCRIPTINLINE>eval_dispatch</JAVASCRIPTINLINE> without
        saving any information on the stack. Thus, when we proceed to evaluate a return
        expression, the stack is the same as just before the call to the function whose
        return value we are about to compute.

        Hence, evaluating a return expression<EMDASH/>even if it is a function call (as in
        <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>, where the conditional expression
        reduces to a call to <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE>)<EMDASH/>will
        not cause any information to be accumulated on the stack.<!-- --></JAVASCRIPT><!--
        --></SPLIT><FOOTNOTE>This implementation of tail recursion <SPLITINLINE><SCHEME>in
        <SCHEMEINLINE>ev-sequence</SCHEMEINLINE></SCHEME></SPLITINLINE> is one variety of
        a well-known optimization technique used by many compilers. In compiling a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that ends with a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        call, one can replace the call by a jump to the called
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><APOS/>s
        entry point. Building this strategy into the interpreter, as we have done in this
        section, provides the optimization uniformly throughout the language.
      </FOOTNOTE>

      <TEXT>
        <SPLIT>
          <SCHEME>
          If we did not think to take advantage of the fact that it was unnecessary to
          save information in this case, we might have implemented
          <SCHEMEINLINE>eval-sequence</SCHEMEINLINE>
          by treating all the expressions in a sequence in the same way<EMDASH/>saving
          the registers, evaluating the expression, returning to restore the registers,
          and repeating this until all the expressions have been
          evaluated:<FOOTNOTE>We can define
          <SCHEMEINLINE>no-more-exps?</SCHEMEINLINE>
          as follows:
          <SNIPPET EVAL="no">
            <SCHEME>
              (define (no-more-exps? seq) (null? seq))
            </SCHEME>
          </SNIPPET></FOOTNOTE>
          <INDEX><DECLARATION>ev-sequence</DECLARATION><SUBINDEX>without tail recursion</SUBINDEX></INDEX>
          <SNIPPET EVAL="no">
            <SCHEME>
            ev-sequence
            (test (op no-more-exps?) (reg unev))
            (branch (label ev-sequence-end))
            (assign exp (op first-exp) (reg unev))
            (save unev)
            (save env)
            (assign continue (label ev-sequence-continue))
            (goto (label eval-dispatch))
            ev-sequence-continue
            (restore env)
            (restore unev)
            (assign unev (op rest-exps) (reg unev))
            (goto (label ev-sequence))
            ev-sequence-end
            (restore continue)
            (goto (reg continue))
            </SCHEME>
          </SNIPPET>

        This may seem like a minor change to our previous code for evaluation of
        a sequence: The only difference is that we go through the save-restore
        cycle for the last expression in a sequence as well as for the others.
        The interpreter will still give the same value for any expression. But
        this change is fatal to the tail-recursive implementation, because we
        must now return after evaluating the final expression in a sequence in
        order to undo the (useless) register saves. These extra saves will
        accumulate during a nest of procedure calls. Consequently, processes
        such as <SCHEMEINLINE>sqrt-iter</SCHEMEINLINE> will require space
        proportional to the number of iterations rather than requiring constant
        space.
          </SCHEME>
     <JAVASCRIPT>
        If we did not think to take advantage of the fact that it is unnecessary to
        hold on to the useless information on the stack when evaluating a return expression,
        we might have implemented
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> as an operator, with the
        return expression as its operand
        (like in the metacircular evaluator). 
        A straightforward implementation would evaluate the return expression,
        come back to restore the registers,
        and finally continue at the entry point of the function call:
          <SNIPPET EVAL="no">
            <JAVASCRIPT>
"ev_return_alternative", 
      assign("comp", list(op("return_expression"), reg("comp"))),
      assign("continue", label("ev_restore_stack")),
      go_to(label("eval_dispatch")),

"ev_restore_stack",
      restore_marker(),    // undo saves in current function
      restore("continue"), // undo save at ev_application
      go_to(reg("continue")),
            </JAVASCRIPT>
          </SNIPPET>
          This may seem like a minor change to our previous code for evaluation of return
          statements: The only difference is that we delay undoing any register saves to
          the stack until after the evaluation of the return expression. The interpreter
          will still give the same value for any expression. But this change is fatal to
          the tail-recursive implementation, because we must now return after evaluating
          the return expression in order to undo the (useless) register saves. These extra
          saves will accumulate during a nest of procedure calls. Consequently, processes
          such as <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> would require space
          proportional to the number of iterations rather than requiring constant space.


<!--         Let us consider an implementation of the handling of -->
<!--         return statements in the spirit of -->
<!--         the metacircular evaluator. In ev_return, we evaluate the return -->
<!--         expression, place the result in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>, and then continue at -->
<!--         <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE> where a return -->
<!--         value object is created.  -->
        
<!--         For simplicity, assume that a function body does not continue once a -->
<!--         return statement has been -->
<!--         evaluated, and that all saves to the stack in the function body have -->
<!--         been restored when the body is fully evaluated, meaning there is no need -->
<!--         to use our marker trick.  -->

<!--         In this design <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE> installs -->
<!--         a continuation -->
<!--         <JAVASCRIPTINLINE>check_return_value</JAVASCRIPTINLINE>, and every function -->
<!--         call will eventually arrive here after its complete evaluation. -->
<!--         At <JAVASCRIPTINLINE>check_return_value</JAVASCRIPTINLINE>, we check -->
<!--         whether the function's return value stored in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>  -->
<!--         is a return value object or not. If it is, we extract the contents from the -->
<!--         object and place it in <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>. Otherwise, -->
<!--         the function did not return explicitly so we must assign -->
<!--         <JAVASCRIPTINLINE>undefined</JAVASCRIPTINLINE> to -->
<!--         <JAVASCRIPTINLINE>val</JAVASCRIPTINLINE>. We then restore -->
<!--         <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> and jump to the -->
<!--         <QUOTE>final</QUOTE> continuation, which was saved in -->
<!--         <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>. -->
<!--           <SNIPPET EVAL="no"> -->
<!--             <JAVASCRIPT> -->
<!-- "ev_return",  -->
<!--       assign("comp", list(op("return_expression"), reg("comp"))), -->
<!--       assign("continue", label("ev_make_return_value")), -->
<!--       go_to(label("eval_dispatch")), // evaluate the return expression -->

<!-- "ev_make_return_value", -->
<!--       // wrap contents of val in return value object  -->
<!--       assign("val", list(op("ev_make_return_value"), reg("val"))),  -->
<!--       restore("continue"), -->
<!--       go_to(reg("continue")),  -->

<!-- "compound_apply", -->
<!--       ... // as before (first 4 lines) -->
<!--       assign("continue", label("check_for_explicit_return")), // install return handler -->
<!--       go_to(label("eval_dispatch")), -->

<!-- "check_for_explicit_return", -->
<!--       test(list(op("is_return_value"), reg("val"))), -->
<!--       branch(label("explicit_return")), -->
<!--       assign("val", constant(undefined)), -->
<!--       go_to(label("return_from_function")), -->

<!-- "explicit_return", -->
<!--       // extract return value from wrapper -->
<!--       assign("val", list(op("return_value_content"), reg("val"))),  -->
      
<!-- "return_from_function", -->
<!--       restore("continue"), -->
<!--       go_to(reg("continue")), // jump to final continuation  -->
<!--             </JAVASCRIPT> -->
<!--           </SNIPPET> -->

<!--           This design is not tail-recursive as it introduces two deferred -->
<!--           operations: -->
<!--           <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE> and -->
<!--           <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE>. -->
<!--           The cost of these deferred operations will materialise on the stack through -->
<!--           saves of <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE>. -->
<!--           For example, assigning -->
<!--           <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE> to -->
<!--           <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> requires us to store its -->
<!--           previous value, the  -->
<!--           final continuation of the function call, on the stack during the -->
<!--           evaluation of its body. This save took place in <JAVASCRIPTINLINE>ev_application</JAVASCRIPTINLINE>. -->
<!--           Without <JAVASCRIPTINLINE>check_for_explicit_return</JAVASCRIPTINLINE>, this value -->
<!--           could have been restored in <JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>. -->
<!--           Similar reasoning applies to the assignment of <JAVASCRIPTINLINE>ev_make_return_value</JAVASCRIPTINLINE> -->
<!--           to <JAVASCRIPTINLINE>continue</JAVASCRIPTINLINE> in <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>. -->
          

<!--           These stores will accumulate during a nest of -->
<!--           function calls. Consequently, processes such as -->
<!--           <JAVASCRIPTINLINE>sqrt_iter</JAVASCRIPTINLINE> would require space -->
<!--           proportional to the number of iterations rather than requiring -->
<!--           constant space.  -->
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>
  <TEXT>
    This difference can be significant. For example,
    <INDEX>iterative process<SUBINDEX>implemented by <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE> call</SUBINDEX></INDEX>
    with tail recursion, an infinite loop can be expressed using only the
    <SPLITINLINE>
      <SCHEME>procedure-call mechanism:</SCHEME>
      <JAVASCRIPT>function-call and return mechanisms:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      (define (count n)
      (newline)
      (display n)
      (count (+ n 1)))
      </SCHEME>
      <JAVASCRIPT>
function count(n) {
    display(n);
    return count(n + 1);
}
      </JAVASCRIPT>
    </SNIPPET>
    Without tail recursion, such a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    would eventually run out of stack space, and expressing a true iteration
    would require some control mechanism other than
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    call.
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
        <!-- Because our explicit-control evaluator does not use a special return value -->
        <!-- object, we do not introduce any associated deferred operations. -->
        Notably, because the the undoing of the register saves takes place at
        <JAVASCRIPTINLINE>ev_return</JAVASCRIPTINLINE>, our JavaScript implementation
        requires use of <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> to be tail-recursive.
        Removing <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> from the
        <JAVASCRIPTINLINE>count</JAVASCRIPTINLINE> function above will cause it to
        eventually run out of stack space. This explains the use of
        <JAVASCRIPTINLINE>return</JAVASCRIPTINLINE> in the infinite driver loops in
        section<SPACE/>4.1.4 and elsewhere.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

    <INDEX>explicit-control evaluator for JavaScript<SUBINDEX>tail recursion<CLOSE/></SUBINDEX></INDEX>
    <INDEX>tail recursion<SUBINDEX>explicit-control evaluator and<CLOSE/></SUBINDEX></INDEX>
  </TEXT>
</SUBSECTION>

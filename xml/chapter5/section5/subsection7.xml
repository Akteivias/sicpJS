<SUBSECTION>
  <NAME>
    Interfacing Compiled Code to the Evaluator
  </NAME>

  <LABEL NAME="sec:interfacing-compiled-code"/>
  <INDEX>compiler for Scheme
  <SUBINDEX>interfacing to evaluator|(</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme
  <SUBINDEX>running compiled code|(</SUBINDEX></INDEX>
  <INDEX>explicit-control evaluator for Scheme
  <SUBINDEX>modified for compiled code|(</SUBINDEX></INDEX>
  <TEXT>
    We have not yet explained how to load compiled code into the evaluator
    machine or how to run it.  We will assume that the explicit-control-evaluator
    machine has been defined as in
    section<SPACE/><REF NAME="sec:running-evaluator"/>, with the additional
    operations specified in footnote<SPACE/><REF NAME="foot:compiler-ops"/>.
    We will implement a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <!--  \indcode{compile-and-go} -->
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-go</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    that compiles a Scheme expression, loads the
    resulting object code into the evaluator machine,
    and causes the machine to run the code in the
    evaluator global environment, print the result, and
    enter the evaluator<APOS/>s driver loop.  We will also modify the evaluator
    so that interpreted expressions can call compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well as interpreted ones.  We can then put a compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    into the machine and use the
    evaluator to call it:
    <SNIPPET>
      <SCHEME>
      (compile-and-go
      '(define (factorial n)
      (if (= n 1)
            1
            (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
      ;;; EC-Eval value:
      ok

      ;;; EC-Eval input:
      (factorial 5)
      ;;; EC-Eval value:
      120
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compile_and_go(
    parse(
        "function factorial(n) {
             return n === 1 
                 ? 1
                 : n * factorial(n - 1);
         }"));

;;; EC-Eval value:
ok

;;; EC-Eval input:
(factorial 5)
;;; EC-Eval value:
120
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    To allow the evaluator to handle compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (for example,
    to evaluate the call to <SCHEMEINLINE>factorial</SCHEMEINLINE> above),
    we need to change the code at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (section<SPACE/><REF NAME="sec:procedure-application"/>) so that it
    recognizes compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (as distinct from compound or primitive
    <SPLITINLINE>
      <SCHEME>procedures)</SCHEME>
      <JAVASCRIPT>functions)</JAVASCRIPT>
    </SPLITINLINE>
    and transfers control directly to the entry point of the
    compiled code:<FOOTNOTE>Of course, compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well as interpreted
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    are compound (nonprimitive).  For compatibility with the terminology used
    in the explicit-control evaluator, in this section we will use
    <QUOTE>compound</QUOTE> to mean interpreted (as opposed to
    compiled).</FOOTNOTE>
    <!--  \indcode*{apply-dispatch}[modified for compiled code] -->
    <!--  \indcode*{compiled-apply} -->
    <SNIPPET>
      <SCHEME>
      apply-dispatch
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-apply))
      (test (op compound-procedure?) (reg proc))  
      (branch (label compound-apply))
      (test (op compiled-procedure?) (reg proc))  
      (branch (label compiled-apply))
      (goto (label unknown-procedure-type))

      compiled-apply
      (restore continue)
      (assign val (op compiled-procedure-entry) (reg proc))
      (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
"apply_dispatch",
    test(op("primitive_function"), reg("fun")),
    branch(label("primitive_apply")),
    test(op("compound_function"), reg("fun")),
    branch(label("compound_apply")),
    test(op("is_compiled_function"), reg("fun")),
    branch(label("compiled_apply")),
    go_to(label("unknown_function_type")),
"compiled_apply",
    restore("continue"),
    assign("val", list(op("compiled_function_entry"), reg("fun"))),
    go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Note the restore of <LATEXINLINE>$\texttt{continue}$</LATEXINLINE> at
    <SPLITINLINE>
      <SCHEME>
      <SCHEMEINLINE>compiled-apply</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compiled_apply</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Recall that the evaluator was arranged so that at
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>apply-dispatch</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>apply_dispatch</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    the continuation would be at the top of the stack.  The compiled code entry
    point, on the other hand, expects the continuation to be in
    <LATEXINLINE>$\texttt{continue}$</LATEXINLINE>, so
    <LATEXINLINE>$\texttt{continue}$</LATEXINLINE> must be
    restored before the compiled code is executed.
  </TEXT>

  <TEXT>
    To enable us to run some compiled code when we start the evaluator
    machine, we add a <SCHEMEINLINE>branch</SCHEMEINLINE> instruction at
    the beginning of the evaluator machine, which causes the machine to
    go to a new entry point if the <SCHEMEINLINE>flag</SCHEMEINLINE> register 
    is set.<FOOTNOTE>Now that the evaluator machine starts
    with a <SCHEMEINLINE>branch</SCHEMEINLINE>, we must always initialize the
    <SCHEMEINLINE>flag</SCHEMEINLINE> register before starting the evaluator
    machine.  To start the machine at its ordinary read-eval-print loop, we
    could use
    <!--  \indcode*{start-eceval} -->
    <SNIPPET>
      <NAME>start_eceval</NAME>
      <SCHEME>
        (define (start-eceval)
        (set! the-global-environment (setup-environment))
        (set-register-contents! eceval 'flag false)
        (start eceval))
      </SCHEME>
      <JAVASCRIPT>
function start_eceval() {
    set_register_contents(eceval, "flag", false);
    return start(eceval);
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
function start_eceval() {
    set_register_contents(eceval, "flag", false);
    return start(eceval);
}
      </JAVASCRIPT_RUN>
    </SNIPPET></FOOTNOTE>
    <SNIPPET LATEX="yes">
      <SCHEME>
      (branch (label external-entry))      <EM>; branches if <SCHEMEINLINE>flag</SCHEMEINLINE> is set</EM>
      read-eval-print-loop
      (perform (op initialize-stack))
      ^$\ldots$^
      </SCHEME>
      <JAVASCRIPT>
branch(label("external_entry")), // branches if flag is set
"read_eval_print_loop",
perform(op("initialize_stack")),
$\langle\ldots\rangle$
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>External-entry</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>External_entry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    assumes that the machine is started with <SCHEMEINLINE>val</SCHEMEINLINE>
    containing the location of an instruction sequence that puts a result into
    <SCHEMEINLINE>val</SCHEMEINLINE> and ends with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(goto (reg continue))</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to(reg("continue"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Starting at this entry point jumps to the location designated
    by <SCHEMEINLINE>val</SCHEMEINLINE>, but first assigns
    <LATEXINLINE>$\texttt{continue}$</LATEXINLINE> so that execution will return to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>print-result</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>print_result</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    which prints the value in <SCHEMEINLINE>val</SCHEMEINLINE> and then goes to
    the beginning of the evaluator<APOS/>s read-eval-print loop.<FOOTNOTE>Since
    a compiled
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is an object that the system may try to print, we also modify the system
    print operation
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>user-print</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>user_print</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (from section<SPACE/><REF NAME="sec:running-eval"/>) so that it will not
    attempt to print the components of a compiled
    <SPLITINLINE>
      <SCHEME>procedure:</SCHEME>
      <JAVASCRIPT>function:</JAVASCRIPT>
      </SPLITINLINE>
      <!--  \indcode*{user-print}[modified for compiled code] -->
      <SNIPPET>
	<NAME>user_print_2</NAME>
      <SCHEME>
        <!--  \indcode*{user-print}[modified for compiled code] -->
        (define (user-print object)
        (cond ((compound-procedure? object)
              (display (list 'compound-procedure
              (procedure-parameters object)
              (procedure-body object)
              '&lt;procedure-env&gt;)))
              ((compiled-procedure? object)
              (display '&lt;compiled-procedure&gt;))
              (else (display object))))
      </SCHEME>
      <JAVASCRIPT>
function user_print(object) {
    if (is_compound_function(object)) {
        display(list(
            "compound_function",
            function_parameters(object),
            function_body(object),
            "&lt;compiler-env&gt;"));
    } else if (is_compiled_function(object)) {
        display("&lt;compiled-function&gt;");
    } else {
        display(object);
    }
}
      </JAVASCRIPT>
    </SNIPPET></FOOTNOTE>
    <SNIPPET>
      <SCHEME>
      <!--  \indcode*{external-entry} -->
      external-entry
      (perform (op initialize-stack))
      (assign env (op get-global-environment))
      (assign continue (label print-result))
      (goto (reg val))
      </SCHEME>
      <JAVASCRIPT>
<!--  \indcode*{external-entry} -->
"external_entry",
  perform(op("initialize_stack")),
  assign("env", list(op("get_global_environment"))),
  assign("continue", label("print_result")),
  go_to(reg("val")),
      </JAVASCRIPT>
    </SNIPPET>
    <INDEX>explicit-control evaluator for Scheme
    <SUBINDEX>modified for compiled code|)</SUBINDEX></INDEX>
  </TEXT>

  <TEXT>
    Now we can use the following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to compile a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    definition, execute the compiled code, and run the read-eval-print loop so
    we can try the
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    Because we want the compiled code to return to the location in
    <LATEXINLINE>$\texttt{continue}$</LATEXINLINE> with its result in
    <SCHEMEINLINE>val</SCHEMEINLINE>, we compile the expression with a
    target of <SCHEMEINLINE>val</SCHEMEINLINE> and a linkage of
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>return</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>"return"</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    In order to transform the
    object code produced by the compiler into executable instructions for the
    evaluator register machine, we use the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>assemble</SCHEMEINLINE> from the
    register-machine simulator
    (section<SPACE/><REF NAME="sec:assembler"/>).  We then initialize
    the <SCHEMEINLINE>val</SCHEMEINLINE> register to point to the list of
    instructions, set the
    <SCHEMEINLINE>flag</SCHEMEINLINE> so that the evaluator will go to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>external-entry</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>external_entry</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    and start the evaluator.
    <!--  \indcode*{compile-and-go} -->
    <SNIPPET HIDE="yes">
      <NAME>display_instructions</NAME>
      <JAVASCRIPT>
function stringify_list(xs) {
    return is_null(member(head(xs),
                   list("assign", "perform", "op", "label", "branch",
                        "go_to", "save", "restore", "reg", "constant")))
           ? "list(" + comma_separated(xs) + ")"
           : head(xs) + "(" + comma_separated(tail(xs)) + ")";
}
function comma_separated(elements) {
    return accumulate((s, acc) => stringify_instruction(s) + (acc === "" ? "" : ", " + acc),
                      "", elements);
}
function stringify_instruction(x) {
    return is_string(x) || is_number(x) || is_undefined(x) || is_null(x)
           ? stringify(x)
           : stringify_list(x);
}	   
function display_instructions(instructions) {
    return for_each(i => {display("", stringify_instruction(i) + ","); },
                    instructions);
}	
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <NAME>compile_and_go</NAME>
      <REQUIRES>display_instructions</REQUIRES>
      <SCHEME>
      (define (compile-and-go expression)
      (let ((instructions
            (assemble (statements
            (compile expression 'val 'return))
            eceval)))
      (set! the-global-environment (setup-environment))
      (set-register-contents! eceval 'val instructions)
      (set-register-contents! eceval 'flag true)
      (start eceval)))
      </SCHEME>
      <JAVASCRIPT>
function compile_and_go(stmt) {
    // display_instructions(instructions(compile(stmt, "val", "return")));
    const globals = scan_out_declarations(stmt);
    const unassigneds = list_of_unassigned(globals);
    const prelude =
        make_instruction_sequence(null, null,
            list(assign("env", list(op("get_global_environment"))),
                 assign("env", list(op("extend_environment"), 
                                    constant(globals),
                                    constant(unassigneds),
                                    reg("env"))),
                 perform(list(op("set_global_environment"), reg("env")))));
    const sequence_from_compile = compile(stmt, "val", "return");
    const sequence_with_prelude =
        append_instruction_sequences(prelude, sequence_from_compile);
    const instrs =
              assemble(instructions(sequence_with_prelude),
                       eceval);
    set_register_contents(eceval, "val", instrs);
    set_register_contents(eceval, "flag", true);
    return start(eceval);
}
      </JAVASCRIPT>

    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>compiler for Scheme
    <SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX>
    </INDEX>
    If we have set up stack monitoring, as at the end of
    section<SPACE/><REF NAME="sec:running-evaluator"/>, we can examine the
    stack usage of compiled code:
    <SNIPPET HIDE="yes">
      <NAME>eceval</NAME>
      <JAVASCRIPT>
function prompt_for_input(p) {
    const x = parse(prompt("enter program"));
    return x;
}

function get_global_environment() {
    return the_global_environment;
}
    
function set_global_environment(env) {
    the_global_environment = env;
}
    
function binary_function(f) {
  // f is binary
  return (arg_list) =>
    is_list(arg_list) &amp;&amp; length(arg_list) === 2
      ? apply_in_underlying_javascript(f, arg_list)
      : error(
          arg_list,
          "Incorrect number of arguments passed to binary function "
        );
}

const eceval =
  make_machine(
    list(
      "exp",
      "env",
      "val",
      "continue",
      "proc",
      "argl",
      "unev",
        "returned",
      "fun"
    ),
    list(
      // basic functions
      list(
        "rem",
        binary_function((a, b) => a % b)
      ),
	// CHANGE: not used
      // list(
      //   "=",
      //   binary_function((a, b) => a === b)
      // ),
      list(
        "is_returned",
        a => a === true
      ),
      list(
        "+",
        binary_function((a, b) => a + b)
      ),
	// CHANGE: - and * added
      list(
        "-",
        binary_function((a, b) => a - b)
      ),
      list(
        "*",
        binary_function((a, b) => a * b)
      ),
      list(
        "===",
        binary_function((a, b) => a === b)
      ),
      // args
      list("args"                , args),
      list("function_expression" , function_expression),
      list("has_no_operands"     , no_args),
      list("first_arg"           , first_arg),
      list(
        "is_last_operand",
        (a) => is_null(tail(a))
      ),
      list("rest_args", rest_args),

      //arg
      list(
        "empty_arglist",
        (_) => list()
      ),
      list(
        "adjoin_arg",
        (val, argl) => append(argl, list(val))
      ),

      // exp (sequence)
      list("first_statement"     , first_statement),
      list("rest_statements"     , rest_statements),
      list("is_last_statement"   , is_last_statement),
      list("sequence_statements" , sequence_statements),

      // eval functions from meta-circular evaluator
      list("is_self_evaluating"  , is_self_evaluating),
      list("is_name"             , is_name),
      list("symbol_of_name"      , symbol_of_name),
      list(
        "all_names_of_names",
        (names) => map(symbol_of_name, names)
      ),
      list("is_assignment"           , is_assignment),
      list("assignment_symbol"       , assignment_symbol),
      list("assignment_value"        , assignment_value),
      list("assign_symbol_value"     , assign_symbol_value),
      list("is_constant_declaration" , is_constant_declaration),
      list(
        "constant_declaration_symbol",
        constant_declaration_symbol
      ),
      list(
        "constant_declaration_value",
        constant_declaration_value
      ),
      list("is_variable_declaration", is_variable_declaration),
      list(
        "variable_declaration_symbol",
        variable_declaration_symbol
      ),
      list(
        "variable_declaration_value",
        variable_declaration_value
      ),
      list("declare_value"        , assign_symbol_value),
      list("is_lambda_expression" , is_lambda_expression),
      list(
        "lambda_parameters",
        lambda_parameters
      ),
      list("lambda_body"         , lambda_body),
	list("is_return_statement" , is_return_statement),
	// CHANGE: not used
	//      list("should_return"       , v => v !== undefined &amp;&amp; v !== "*unassigned*"),
	//      list("returned_value" , v => v !== no_value_yet),
      list("return_expression"   , return_expression),
      list(
        "is_conditional_expression",
        is_conditional_expression
      ),
      list("conditional_pred" , cond_expr_pred),
      list("conditional_cons" , cond_expr_cons),
      list("conditional_alt"  , cond_expr_alt),

      list("is_sequence"      , is_sequence),
      list("make_sequence"    , make_sequence),
      list("is_block"         , is_block),
      list("block_body"       , block_body),
	list("scan_out_declarations"      , scan_out_declarations),
	// CHANGED: get_temp_block_values renamed to:
      list("list_of_unassigned", list_of_unassigned),
      list("is_application"           , is_application),
      list("is_primitive_function"    , is_primitive_function),
      list("apply_primitive_function" , apply_primitive_function),
      list("is_compound_function"     , is_compound_function),
      list("function_parameters"      , function_parameters),
      list("function_environment"     , function_environment),
	list("function_body"            , function_body),
	// CHANGED: not used
	//      list("insert_all"               , insert_all),
      list("extend_environment"       , extend_environment),
      list("make_function"            , make_function),

      list(
        "lookup_symbol_value",
        (stmt, env) => lookup_symbol_value(symbol_of_name(stmt), env)
      ),
      list("get_global_environment", get_global_environment),
      list("set_global_environment", set_global_environment),

      // generic helpers
      list("is_true", is_true),
	list("is_null", is_null),
	// CHANGED: use host language
	list("is_pair", is_pair),
	// CHANGED: simplified
	list( "is_number", is_number),
	list("append", append),

	// CHANGED: not used
	//      list("vector_ref", vector_ref),
	//      list("vector_set", vector_set),
      list("pair", pair),

      list("prompt_for_input", prompt_for_input),
      list("user_print", user_print),
      list("display", display),
      // CHANGED: added
      list("make_compiled_function", make_compiled_function),
      list("compiled_function_env", compiled_function_env),
      list("compiled_function_entry", compiled_function_entry),
      list("list", list),
      list("is_false", x => ! is_true(x))
    ),
    list(
      assign("returned", constant(false)),
      assign("continue", label("evaluator_done")),
      assign("env", list(op("get_global_environment"))),
      "ev_begin",
      
      go_to(label("read_eval_print_loop")),
      
      "eval_dispatch",
      test(list(op("is_self_evaluating"), reg("exp"), constant(true))),
      branch(label("ev_self_eval")),

      test(list(op("is_name"), reg("exp"), constant(true))),
      branch(label("ev_name")),

      // Treat let/const the same
      test(list(op("is_variable_declaration"), reg("exp"), constant(true))),
      branch(label("ev_variable_declaration")),
      test(list(op("is_constant_declaration"), reg("exp"), constant(true))),
      branch(label("ev_constant_declaration")),
      test(list(op("is_assignment"), reg("exp"), constant(true))),
      branch(label("ev_assignment")),

      test(list(op("is_return_statement"), reg("exp"), constant(true))),
      branch(label("ev_return")),

      test(list(op("is_conditional_expression"), reg("exp"), constant(true))),
      branch(label("ev_if")),
      test(list(op("is_lambda_expression"), reg("exp"), constant(true))),
      branch(label("ev_lambda")),
      test(list(op("is_sequence"), reg("exp"), constant(true))),
      branch(label("ev_seq")),
      test(list(op("is_block"), reg("exp"), constant(true))),
      branch(label("ev_block")),
      test(list(op("is_application"), reg("exp"), constant(true))),
      branch(label("ev_application")),
      go_to(label("unknown_expression_type")),

      "ev_return",
        assign("returned", constant(true)),
        assign("exp", list(op("return_expression"), reg("exp"))),
        restore("continue"),
        go_to(label("eval_dispatch")),

      "ev_self_eval",
      assign("val", reg("exp")),
      go_to(reg("continue")),
      
      "ev_name",
      assign("val", list(op("lookup_symbol_value"), reg("exp"), reg("env"))),
      go_to(reg("continue")),
      
      "ev_lambda",
      assign("unev", list(op("lambda_parameters"), reg("exp"))),
      assign("exp", list(op("lambda_body"), reg("exp"))),
      assign(
      "val",
      list(op("make_function"), reg("unev"), reg("exp"), reg("env"))
      ),
      go_to(reg("continue")),
      
      "ev_application",
      save("continue"),
      save("env"),
      assign("unev", list(op("args"), reg("exp"))),
      save("unev"),
      assign("exp", list(op("function_expression"), reg("exp"))),
      assign("continue", label("ev_appl_did_operator")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_did_operator",
      restore("unev"), // the args
      restore("env"),
      assign("argl", list(op("empty_arglist"))),
      assign("fun", reg("val")), // the function_expression
      test(list(op("has_no_operands"), reg("unev"), constant(true))),
      branch(label("apply_dispatch")),
      save("fun"),
      
      "ev_appl_operand_loop",
      save("argl"),
      assign("exp", list(op("first_arg"), reg("unev"))),
      test(list(op("is_last_operand"), reg("unev"), constant(true))),
      branch(label("ev_appl_last_arg")),
      save("env"),
      save("unev"),
      assign("continue", label("ev_appl_accumulate_arg")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_accumulate_arg",
      restore("unev"),
      restore("env"),
      restore("argl"),
      assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),
      assign("unev", list(op("rest_args"), reg("unev"))),
      go_to(label("ev_appl_operand_loop")),
      
      "ev_appl_last_arg",
      assign("continue", label("ev_appl_accum_last_arg")),
      go_to(label("eval_dispatch")),
      
      "ev_appl_accum_last_arg",
      restore("argl"),
      assign("argl", list(op("adjoin_arg"), reg("val"), reg("argl"))),
      restore("fun"),
      go_to(label("apply_dispatch")),
      
      // function application needs to distinguish between
      // primitive functions (which are evaluated using the
      // underlying JavaScript), and compound functions.
      // An application of the latter needs to evaluate the
      // body of the function value with respect to an
      // environment that results from extending the function
      // object`s environment by a binding of the function
      // parameters to the arguments and of local names to
      // the special value no_value_yet
      
      // function apply(fun, args) {
      //   if (is_primitive_function(fun)) {
      //     return apply_primitive_function(fun, args);
      //   } else if (is_compound_function(fun)) {
      //     const body = function_body(fun);
      //     const locals = scan_out_declarations(body);
      //     const names = insert_all(function_parameters(fun), locals);
      //     const temp_values = map((x) => no_value_yet, locals);
      //     const values = append(args, temp_values);
      //     const result = evaluate(
      //       body,
      //       extend_environment(names, values, function_environment(fun))
      //     );
      //     if (is_return_value(result)) {
      //       return return_value_content(result);
      //     } else {
      //       return undefined;
      //     }
      //   } else {
      //     error(fun, "Unknown function type in apply");
      //   }
      // }
      "apply_dispatch",
      test(list(op("is_primitive_function"), reg("fun"), constant(true))),
      branch(label("primitive_apply")),
      test(list(op("is_compound_function"), reg("fun"), constant(true))),
      branch(label("compound_apply")),
      go_to(label("unknown_procedure_type")),

      "primitive_apply",
      assign("val", list(op("apply_primitive_function"), 
                         reg("fun"), 
                         reg("argl"))),
      // go_to(label("return_from_apply")),
      restore("continue"),
      go_to(reg("continue")),
      
        "compound_apply",
          assign("unev", list(op("function_parameters"), reg("fun"))), // params
          assign("env", list(op("function_environment"), reg("fun"))),
          assign("env", list(op("extend_environment"), 
                             reg("unev"), 
                             reg("argl"), 
                             reg("env"))),
          assign("unev", list(op("function_body"), reg("fun"))),
        assign("returned", constant(false)),
          go_to(label("ev_sequence")),
    
      // to evaluate a sequence, we need to evaluate
      // its statements one after the other, and return
      // the value of the last statement.
      // An exception to this rule is when a return
      // statement is encountered. In that case, the
      // remaining statements are ignored and the
      // return value is the value of the sequence.
      
      // function eval_sequence(stmts, env) {
      //   if (is_empty_sequence(stmts)) {
      //     return undefined;
      //   } else if (is_last_statement(stmts)) {
      //     return evaluate(first_statement(stmts), env);
      //   } else {
      //     const first_stmt_value = evaluate(first_statement(stmts), env);
      //     if (is_return_value(first_stmt_value)) {
      //       return first_stmt_value;
      //     } else {
      //       return eval_sequence(rest_statements(stmts), env);
      //     }
      //   }
      // }
      "ev_seq",
      save("continue"),
      assign("unev", list(op("sequence_statements"), reg("exp"))),
      
      "ev_sequence",
      assign("exp", list(op("first_statement"), reg("unev"))),
      test(list(op("is_return_statement"), reg("exp"), constant(true))),
      branch(label("ev_return")),
      test(list(op("is_last_statement"), reg("unev"), constant(true))),
      branch(label("ev_sequence_last_exp")),
      save("unev"),
      save("env"),
      assign("continue", label("ev_sequence_continue")),
      go_to(label("eval_dispatch")),
      
      "ev_sequence_continue",
      restore("env"),
      restore("unev"),
      assign("unev", list(op("rest_statements"), reg("unev"))),
      go_to(label("ev_sequence")),
      
      "ev_sequence_last_exp",
      assign("continue", label("check_return")),
      go_to(label("eval_dispatch")),

        "check_return",
        test(list(op("is_returned"), reg("returned"), constant(true))), /// FIXME: ugly
        branch(label("explicit_return")),
      assign("val", constant(undefined)),

      "explicit_return",
      restore("continue"),
      go_to(reg("continue")),
        


      // evaluation of blocks evaluates the body of the block
      // with respect to the current environment extended by
      // a binding of all local names to the special value
      // no_value_yet
      
      // function eval_block(stmt, env) {
      //   const body = block_body(stmt);
      //   const locals = scan_out_declarations(body);
      //   const temp_values = map((x) => no_value_yet, locals);
      //   return evaluate(body, extend_environment(locals, temp_values, env));
      // }
      "ev_block",
      assign("exp", list(op("block_body"), reg("exp"))),
      assign("val", list(op("scan_out_declarations"), reg("exp"))),

      save("exp"), // Temporarily store to exp
      assign("exp", list(op("list_of_unassigned"), reg("val"))),
      assign("env", list(op("extend_environment"), 
                         reg("val"), 
                         reg("exp"), 
                         reg("env"))),
      restore("exp"),
      go_to(label("eval_dispatch")),
      
      // the meta-circular evaluation of conditional expressions
      // evaluates the predicate and then the appropriate
      // branch, depending on whether the predicate evaluates to
      // true or not
      
      // function eval_conditional_expression(stmt, env) {
      //   return is_true(evaluate(cond_expr_pred(stmt), env))
      //     ? evaluate(cond_expr_cons(stmt), env)
      //     : evaluate(cond_expr_alt(stmt), env);
      // }
      "ev_if",
      save("exp"), // save expression for later
      save("env"),
      save("continue"),
      assign("continue", label("ev_if_decide")),
      assign("exp", list(op("conditional_pred"), reg("exp"))),
      go_to(label("eval_dispatch")), // evaluate the predicate
      
      "ev_if_decide",
      restore("continue"),
      restore("env"),
      restore("exp"),
      test(list(op("is_true"), reg("val"), constant(true))),
      branch(label("ev_if_consequent")),
      
      "ev_if_alternative",
      assign("exp", list(op("conditional_alt"), reg("exp"))),
      go_to(label("eval_dispatch")),
      
      "ev_if_consequent",
      assign("exp", list(op("conditional_cons"), reg("exp"))),
      go_to(label("eval_dispatch")),
      
      // function eval_assignment(stmt, env) {
      //   const value = evaluate(assignment_value(stmt), env);
      //   assign_symbol_value(assignment_symbol(stmt), value, env);
      //   return value;
      // }
      "ev_assignment",
      assign("unev", list(op("assignment_symbol"), reg("exp"))),
      save("unev"), // save variable for later
      assign("exp", list(op("assignment_value"), reg("exp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_assignment_1")),
      go_to(label("eval_dispatch")), // evaluate the assignment value
      
      "ev_assignment_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(
      list(op("assign_symbol_value"), reg("unev"), reg("val"), reg("env"))
      ),
      assign("val", constant("ok")),
      go_to(reg("continue")),
      
      // evaluation of a constant declaration evaluates
      // the right-hand expression and binds the
      // name to the resulting value in the
      // first (innermost) frame
      
      // function eval_constant_declaration(stmt, env) {
      //   assign_symbol_value(
      //     constant_declaration_symbol(stmt),
      //     evaluate(constant_declaration_value(stmt), env),
      //     env
      //   );
      // }
      "ev_variable_declaration",
      assign("unev", list(op("variable_declaration_symbol"), reg("exp"))),
      save("unev"), // save variable for later
      assign("exp", list(op("variable_declaration_value"), reg("exp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_variable_declaration_1")),
      go_to(label("eval_dispatch")), // evaluate the declaration value
      
      "ev_variable_declaration_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("declare_value"), reg("unev"), reg("val"), reg("env"))),
      assign("val", constant("ok")),
      go_to(reg("continue")),
      
      "ev_constant_declaration",
      assign("unev", list(op("constant_declaration_symbol"), reg("exp"))),
      save("unev"), // save constant for later
      assign("exp", list(op("constant_declaration_value"), reg("exp"))),
      save("env"),
      save("continue"),
      assign("continue", label("ev_constant_declaration_1")),
      go_to(label("eval_dispatch")), // evaluate the declaration value
      
      "ev_constant_declaration_1",
      restore("continue"),
      restore("env"),
      restore("unev"),
      perform(list(op("declare_value"), reg("unev"), reg("val"), reg("env"))),
      assign("val", constant("ok")),
      go_to(reg("continue")),
      
      // Error handling
      "unknown_expression_type",
      assign("val", constant("unknown_expression_type_error")),
      assign("val", reg("exp")),
      go_to(label("signal_error")),
      
      "unknown_procedure_type",
      restore("continue"), /// clean up stack (from apply_dispatch)
      assign("val", constant("unknown_procedure_type_error")),
      go_to(label("signal_error")),
      
      "signal_error",
      perform(list(op("user_print"), constant("EC_eval error:"), reg("val"))),
      go_to(label("evaluator_done")),
      
      "read_eval_print_loop",
      assign("exp", list(op("prompt_for_input"), constant("/// EC_Eval input:"))),
      assign("continue", label("print_result")),
      go_to(label("eval_dispatch")),
      "print_result",
      
      perform(list(op("user_print"), constant("EC-evaluate value:"), reg("val"))),
      //go_to(label("read_eval_print_loop")), /// Comment out to avoid infinite loop
      
      "evaluator_done"
      )
  );
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>compile_and_go_example</NAME>
      <REQUIRES>headline_4_1_1</REQUIRES>
      <REQUIRES>scan_out_declarations</REQUIRES>
      <REQUIRES>list_of_unassigned</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <REQUIRES>make_machine</REQUIRES>
      <REQUIRES>start</REQUIRES>
      <REQUIRES>compile</REQUIRES>
      <REQUIRES>make_instruction_sequence</REQUIRES>
      <REQUIRES>empty_instruction_sequence</REQUIRES>
      <REQUIRES>compile_linkage</REQUIRES>
      <REQUIRES>end_with_linkage</REQUIRES>
      <REQUIRES>compile_self_evaluating</REQUIRES>
      <REQUIRES>compile_assignment</REQUIRES>
      <REQUIRES>make_label</REQUIRES>
      <REQUIRES>compile_conditional_expression</REQUIRES>
      <REQUIRES>compile_sequence</REQUIRES>
      <REQUIRES>make_compiled_function</REQUIRES>
      <REQUIRES>compile_lambda</REQUIRES>
      <REQUIRES>compile_lambda_body</REQUIRES>
      <REQUIRES>compile_return</REQUIRES>
      <REQUIRES>compile_block</REQUIRES>
      <REQUIRES>compile_application</REQUIRES>
      <REQUIRES>construct_arglist</REQUIRES>
      <REQUIRES>compile_function_call</REQUIRES>
      <REQUIRES>all_regs</REQUIRES>
      <REQUIRES>compile_fun_appl</REQUIRES>
      <REQUIRES>registers_needed</REQUIRES>
      <REQUIRES>needs_register</REQUIRES>
      <REQUIRES>append_instruction_sequences</REQUIRES>
      <REQUIRES>list_union</REQUIRES>
      <REQUIRES>preserving</REQUIRES>
      <REQUIRES>tack_on_instruction_sequence</REQUIRES>
      <REQUIRES>parallel_instruction_sequences</REQUIRES>
      <REQUIRES>user_print_2</REQUIRES>
      <REQUIRES>eceval</REQUIRES>
      <REQUIRES>compile_and_go</REQUIRES>
      <SCHEME>
      (compile-and-go
      '(define (factorial n)
      (if (= n 1)
            1
            (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
      (total-pushes = 0 maximum-depth = 0)
      ;;; EC-Eval value:
      ok

      ;;; EC-Eval input:
      (factorial 5)
      (total-pushes = 31 maximum-depth = 14)
      ;;; EC-Eval value:
      120

      ;;; EC-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compile_and_go(
    parse(
        "function factorial(n) {           \
             return n === 1                \
                 ? 1                       \
                 : factorial(n - 1) * n;   \
                                          }"));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
(total-pushes = 0 maximum-depth = 0)
EC-evaluate value:
"ok"

EC-evaluate input:
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <SCHEME>
(factorial 5)
      </SCHEME>
      <SCHEMEOUTPUT>
(total-pushes = 31 maximum-depth = 14)
;;; EC-Eval value:
120
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
factorial(5);	
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
(total-pushes = 31 maximum-depth = 14)
EC-evaluate value:
120
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <INDEX>compiler for Scheme
    <SUBINDEX>explicit-control evaluator vs.</SUBINDEX></INDEX>
    Compare this example with the evaluation of
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(factorial 5)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>factorial(5)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    using the interpreted version of the same
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>function,</JAVASCRIPT>
    </SPLITINLINE>
    shown at the end of section<SPACE/><REF NAME="sec:running-evaluator"/>.
    The interpreted version required 144 pushes and a maximum stack depth of 28.
    This illustrates the optimization that results from our compilation strategy.
  </TEXT>

  <SUBHEADING>
    <NAME>Interpretation and compilation</NAME>
  </SUBHEADING>

  <INDEX>interpreter<SUBINDEX>compiler vs.</SUBINDEX></INDEX>
  <INDEX>compiler<SUBINDEX>interpreter vs.</SUBINDEX></INDEX>
  <TEXT>
    With the programs in this section, we can now experiment with the
    alternative execution strategies of interpretation and
    compilation.<FOOTNOTE>We can do even better by extending the compiler
    to allow compiled code to call interpreted
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    See exercise<SPACE/><REF NAME="ex:compiled-call-interpreted"/>.</FOOTNOTE>
    An interpreter raises the machine to the level of the user program; a
    compiler lowers the user program to the level of the machine language.
    We can regard the Scheme language (or any programming language) as a
    coherent family of abstractions erected on the machine language.
    Interpreters are good for interactive program development and debugging
    because the steps of
    program execution are organized in terms of these abstractions, and
    are therefore more intelligible to the programmer.  Compiled code can
    execute faster, because the steps of program execution are organized
    in terms of the machine language, and the compiler is free to make
    optimizations that cut across the higher-level
    abstractions.<FOOTNOTE>Independent of the strategy of execution, we
    <INDEX>error handling<SUBINDEX>in compiled code</SUBINDEX></INDEX>
    incur significant overhead if we insist that errors encountered in
    execution of a user program be detected and signaled, rather than being
    allowed to kill the system or produce wrong answers.  For example, an
    out-of-bounds array reference can be detected by checking the validity
    of the reference before performing it.  The overhead of checking,
    however, can be many times the cost of the array reference itself, and
    a programmer should weigh speed against safety in determining whether
    such a check is desirable.  A good compiler should be able to produce
    code with such checks, should avoid redundant checks, and should allow
    programmers to control the extent and type of error checking in the
    compiled code.
  </FOOTNOTE>
  </TEXT>

  <TEXT>
    <INDEX>C<SUBINDEX>error handling</SUBINDEX></INDEX>
    Compilers for popular languages, such as C and C++,
    put hardly any error-checking operations into
    running code, so as to make things run as fast as possible.  As a
    result, it falls to programmers to explicitly provide error checking.
    Unfortunately, people often neglect to do this, even in
    critical applications where speed is not a constraint.  Their programs
    lead fast and dangerous lives.  For example, the notorious 
    <INDEX>Internet <QUOTE>Worm</QUOTE></INDEX>
    <QUOTE>Worm</QUOTE>
    that paralyzed the Internet in 1988 exploited the 
    <INDEX>UNIX</INDEX>
    UNIX<LATEXINLINE>$^{\textrm{TM}}$</LATEXINLINE>
    operating system<APOS/>s failure to check whether the input buffer has
    <INDEX>Spafford, Eugene H.</INDEX>
    overflowed in the finger daemon. (See <CITATION>Spafford 1989</CITATION>.)
  </TEXT>

  <TEXT>
    The alternatives of interpretation and compilation also lead to
    <INDEX>porting a language</INDEX>
    different strategies for porting languages to new computers. Suppose
    that we wish to implement
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    for a new machine.  One strategy is
    to begin with the explicit-control evaluator of
    section<SPACE/><REF NAME="sec:eceval"/>
    and translate its instructions to instructions for the
    new machine.  A different strategy is to begin with the compiler and
    change the code generators so that they generate code for the new
    machine.  The second strategy allows us to run any
    <SPLITINLINE><SCHEME>Lisp</SCHEME>
    <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    program on the new machine by first compiling it with the compiler running
    on our
    original <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> system, and linking it with a compiled version of the run-time
    library.<FOOTNOTE>Of course, with either the interpretation or the
    compilation strategy we must also implement for the new machine storage
    allocation, input and output, and all the various operations that we took
    as <QUOTE>primitive</QUOTE> in our discussion of
    the evaluator and compiler.  One strategy for minimizing work here is
    to write as many of these operations as possible in
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    and then compile them for the new machine.  Ultimately, everything reduces
    to a small kernel (such as garbage collection and the mechanism for
    applying actual machine primitives) that is hand-coded for the new
    machine.</FOOTNOTE>  Better yet, we can compile the compiler itself, and run
    this on the new machine to compile other
    <SPLITINLINE><SCHEME>Lisp</SCHEME><JAVASCRIPT>JavaScript</JAVASCRIPT></SPLITINLINE> programs.<FOOTNOTE>
    This strategy leads to amusing tests of correctness of
    the compiler, such as checking
    whether the compilation of a program on the new machine, using the
    compiled compiler, is identical with the
    compilation of the program on the original
    <SPLITINLINE>
      <SCHEME>Lisp</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    system.  Tracking down the source of differences is fun but often
    frustrating, because the results are extremely sensitive to minuscule
    details.</FOOTNOTE>  Or we can compile one of the interpreters of
    section<SPACE/><REF NAME="sec:mc-eval"/> to produce an interpreter that
    runs on the new machine.
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:measure-factorial-ratio"/>
    <INDEX>compiler for Scheme
    <SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX>
    </INDEX>
    <!--  \indcode{factorial}[stack usage, compiled] -->
    By comparing the stack operations used by compiled code to the stack
    operations used by the evaluator for the same computation, we can
    determine the extent to which the compiler optimizes use of the stack,
    both in speed (reducing the total number of stack operations) and in
    space (reducing the maximum stack depth).  Comparing this optimized
    stack use to the performance of a special-purpose machine for the same
    computation gives some indication of the quality of the compiler.

    <OL>
      <LI>
	Exercise<SPACE/><REF NAME="ex:rec-fact"/> asked you to determine, as a
	function of <LATEXINLINE>$n$</LATEXINLINE>, the number of pushes and
	the maximum stack depth needed by the evaluator to compute
	<LATEXINLINE>$n!$</LATEXINLINE> using the recursive factorial
	<SPLITINLINE>
	  <SCHEME>procedure</SCHEME>
	  <JAVASCRIPT>function</JAVASCRIPT>
	</SPLITINLINE>
	given above.  Exercise<SPACE/><REF NAME="ex:measure-fact"/> asked you
	to do the same measurements for the special-purpose factorial machine
	shown in figure<SPACE/><REF NAME="fig:fact-machine"/>. Now perform the
	same analysis using the compiled <SCHEMEINLINE>factorial</SCHEMEINLINE>
	<SPLITINLINE>
	  <SCHEME>procedure.</SCHEME>
	  <JAVASCRIPT>function.</JAVASCRIPT>
	</SPLITINLINE>
	<P/>
	Take the ratio of the number of pushes in the compiled version to the
	number of pushes in the interpreted version, and do the same for the
	maximum stack depth.  Since the number of operations and the stack
	depth used to compute <LATEXINLINE>$n!$</LATEXINLINE> are linear in
	<LATEXINLINE>$n$</LATEXINLINE>, these ratios should
	approach constants as <LATEXINLINE>$n$</LATEXINLINE> becomes large.
	What are these constants? Similarly, find the ratios of the stack usage
	in the special-purpose machine to the usage in the interpreted version.
	<P/>
	Compare the ratios for special-purpose versus interpreted code to the
	ratios for compiled versus interpreted code.  You should find that the
	special-purpose machine does much better than the compiled code, since
	the hand-tailored controller code should be much better than what is
	produced by our rudimentary general-purpose compiler.
      </LI>
      <LI>
	Can you suggest improvements to the compiler that would help it
	generate code that would come closer in performance to the
	hand-tailored version?
      </LI>
    </OL>
  </EXERCISE>


  <EXERCISE>
    <INDEX>compiler for Scheme
    <SUBINDEX>monitoring performance (stack use) of compiled code</SUBINDEX>
    </INDEX>
    <!--  \indcode{fib}[stack usage, compiled] -->
    Carry out an analysis like the one in
    exercise<SPACE/><REF NAME="ex:measure-factorial-ratio"/> to determine the
    effectiveness of compiling the tree-recursive Fibonacci
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <SCHEME>
      (define (fib n)
      (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
      </SCHEME>
      <JAVASCRIPT>
function fib(n) {
    return n &lt; 2 
        ? n
        : fib(n - 1) + fib(n - 2);
}
      </JAVASCRIPT>
    </SNIPPET>
    compared to the effectiveness of using the special-purpose Fibonacci machine
    of figure<SPACE/><REF NAME="fig:fib-machine"/>.  (For measurement of the
    interpreted performance, see exercise<SPACE/><REF NAME="ex:rec-fib"/>.)
    For Fibonacci, the time resource used is not linear in
    <LATEXINLINE>$n$</LATEXINLINE>; hence the ratios of stack operations will not
    approach a limiting value that is independent of
    <LATEXINLINE>$n$</LATEXINLINE>.
    <LABEL NAME="ex:measure-fib-ratio"/>
  </EXERCISE>

  <EXERCISE>
    This section described how to modify the explicit-control evaluator so
    that interpreted code can call compiled
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
    <JAVASCRIPT>functions.</JAVASCRIPT></SPLITINLINE>
    Show how to modify the compiler so that compiled
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    can call not only primitive
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    and compiled
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    but interpreted
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    as well.  This requires modifying
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-procedure-call</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_function_call</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to handle the case of compound (interpreted)
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>functions.</JAVASCRIPT>
    </SPLITINLINE>
    Be sure to handle all the same <SCHEMEINLINE>target</SCHEMEINLINE> and
    <SCHEMEINLINE>linkage</SCHEMEINLINE> combinations
    as in
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>compile-proc-appl</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_fun_appl</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    To do the actual
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    application,
    the code needs to jump to the evaluator<APOS/>s
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compound-apply</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>compound_apply</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    entry point. This label cannot be directly referenced in object code
    (since the assembler requires that all labels referenced by the
    code it is assembling be defined there), so we will add a register
    called <SCHEMEINLINE>compapp</SCHEMEINLINE> to the evaluator machine to
    hold this entry point, and add an instruction to initialize it:
    <SNIPPET LATEX="yes">
      <SCHEME>
      (assign compapp (label compound-apply))
      (branch (label external-entry))      <EM>; branches if <SCHEMEINLINE>flag</SCHEMEINLINE> is set</EM>
      read-eval-print-loop
      ^$\ldots$^
      </SCHEME>
      <JAVASCRIPT>
  assign("compapp", label("compound_apply")),
  branch(label("external_entry")),     // branches if flag is set
"read_eval_print_loop"
  $\ldots$
      </JAVASCRIPT>
    </SNIPPET>
    To test your code, start by defining a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>f</SCHEMEINLINE> that calls a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
    <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
    <SCHEMEINLINE>g</SCHEMEINLINE>.  Use
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-go</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to compile the definition of <SCHEMEINLINE>f</SCHEMEINLINE> and start the
    evaluator.  Now, typing at the evaluator, define
    <SCHEMEINLINE>g</SCHEMEINLINE> and try to call
    <SCHEMEINLINE>f</SCHEMEINLINE>.
    <LABEL NAME="ex:compiled-call-interpreted"/>
  </EXERCISE>

  <EXERCISE>
    <!--  \indcode{compile-and-run} -->
    The
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-go</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_go</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    interface implemented in this section is
    awkward, since the compiler can be called only once (when the
    evaluator machine is started).  Augment the compiler-interpreter
    interface by providing a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>compile-and-run</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>compile_and_run</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    primitive that can be called from within the explicit-control evaluator
    as follows:
    <SNIPPET EVAL="no">
      <SCHEMEOUTPUT>
;;; EC-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT_OUTPUT>
EC-evaluate input:
     </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEME>
      (compile-and-run
      '(define (factorial n)
      (if (= n 1)
            1
            (* (factorial (- n 1)) n))))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; EC-Eval value:
ok

;;; EC-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
compile_and_run(
    parse(
        "function factorial(n) {          \
             return n === 1               \
                 ? 1                      \
                 : n * factorial(n - 1);  \
         }                                "));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-evaluate value:
ok

EC-evaluate input:
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET>
      <SCHEME>
(factorial 5)
      </SCHEME>
      <SCHEMEOUTPUT>
      ;;; EC-Eval value:
      120
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
factorial(5)
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
EC-Eval value:
120
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    As an alternative to using the explicit-control evaluator<APOS/>s
    read-eval-print loop, design a register machine that performs a
    read-compile-execute-print loop.  That is, the machine should run a
    loop that reads an expression, compiles it, assembles and
    executes the resulting code, and prints the result.  This is easy to
    run in our simulated setup, since we can arrange to call the
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>compile</SCHEMEINLINE> and
    <SCHEMEINLINE>assemble</SCHEMEINLINE> as <QUOTE>register-machine
    operations.</QUOTE>
    <LABEL NAME="ex:read-compile-execute"/>
  </EXERCISE>

  <EXERCISE>
    <INDEX>metacircular evaluator for Scheme
    <SUBINDEX>compilation of</SUBINDEX></INDEX>
    Use the compiler to compile the metacircular evaluator of
    section<SPACE/><REF NAME="sec:mc-eval"/> and run this program using the
    register-machine simulator.  (To compile more than one definition at a time,
    you can package the definitions in a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>begin</SCHEMEINLINE>.)</SCHEME>
      <JAVASCRIPT>sequence.)</JAVASCRIPT>
    </SPLITINLINE>
    The resulting interpreter will run very slowly because of the multiple
    levels of interpretation, but getting all the details to work is an
    instructive exercise.
  </EXERCISE>

  <EXERCISE>
    <INDEX>C<SUBINDEX>Scheme interpreter written in</SUBINDEX></INDEX>
    Develop a rudimentary implementation of
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    in C (or some other low-level language of your choice) by translating the
    explicit-control evaluator of section<SPACE/><REF NAME="sec:eceval"/>
    into C.  In order to run this code you will need to also
    provide appropriate storage-allocation routines and other run-time
    support.
    <LABEL NAME="ex:interp-in-C"/>
  </EXERCISE>

  <EXERCISE>
    <INDEX>C<SUBINDEX>compiling Scheme into</SUBINDEX></INDEX>
    <INDEX>C<SUBINDEX>Scheme interpreter written in</SUBINDEX></INDEX>
    <INDEX>metacircular evaluator for Scheme
    <SUBINDEX>compilation of</SUBINDEX></INDEX>
    As a counterpoint to exercise<SPACE/><REF NAME="ex:interp-in-C"/>, modify
    the compiler so that it compiles 
    <SPLITINLINE>
      <SCHEME>Scheme procedures</SCHEME>
      <JAVASCRIPT>JavaScript functions</JAVASCRIPT>
    </SPLITINLINE>
    into sequences of C instructions.  Compile the metacircular evaluator of
    section<SPACE/><REF NAME="sec:mc-eval"/> to produce a
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>  
    interpreter written in C.
    <LABEL NAME="ex:compiler-in-C"/>
  </EXERCISE>
  <INDEX>compiler for Scheme
  <SUBINDEX>interfacing to evaluator|)</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme<SUBINDEX>running compiled code|)</SUBINDEX></INDEX>
  <INDEX>compiler for Scheme|)</INDEX>
</SUBSECTION>

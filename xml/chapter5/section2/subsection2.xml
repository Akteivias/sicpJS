<SUBSECTION>
  <NAME>
    The Assembler
  </NAME>

  <LABEL NAME="sec:assembler"/>
  <INDEX>assembler|(</INDEX>

  <SPLIT>
    <SCHEME>
      <TEXT>
        The assembler transforms the sequence of controller expressions for a
        machine into a corresponding list of machine instructions, each with its
        execution procedure. Overall, the assembler is much like the evaluators
        we studied in chapter<SPACE/>4<EMDASH/>there is an input language (in
        this case, the register-machine language) and we must perform an
        appropriate action for each type of expression in the language.
      </TEXT>
    </SCHEME>
    <JAVASCRIPT>
      <TEXT>
        The assembler transforms the controller for a machine into a
        corresponding list of machine instructions, each with its execution
        function. Overall, the assembler is much like the evaluators we studied
        in chapter<SPACE/>4<EMDASH/>there is an input language (in this case,
        the register-machine language) and we must perform an appropriate action
        for each type of component in the language.
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
   
  <TEXT>
    <INDEX>syntactic analysis, separated from execution
    <SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
    The technique of producing an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for each instruction is just what we used in
    section<SPACE/><REF NAME="sec:separating-analysis"/> to speed
    up the evaluator by separating analysis from runtime execution.  As we
    saw in chapter<SPACE/>4, much useful analysis of
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    expressions could
    be performed without knowing the actual values of
    <SPLITINLINE>
      <SCHEME>variables.</SCHEME>
      <JAVASCRIPT>names.</JAVASCRIPT>
    </SPLITINLINE>
    Here, analogously, much useful analysis of register-machine-language
    expressions can be performed without knowing the actual contents of
    machine registers.  For example, we can replace references to
    registers by pointers to the register objects, and we can
    replace references to labels by pointers to the place in the
    instruction sequence that the label designates.
  </TEXT>

  <SPLIT>
    <JAVASCRIPT>
      The assembler operates on the controller specification in an <EM>intermediate
      representation</EM> format where each machine instruction is constructed as a
      tagged list.<FOOTNOTE>This is a common design choice: compilers,
      interpreters and virtual machines typically do not work directly on the
      source code of a program, but on some intermediate representation
      (intermediate in the sense of between the source code and the machine
      code).</FOOTNOTE> The tag is a string that identifies the instruction
      type, such as <JAVASCRIPTINLINE>"go_to"</JAVASCRIPTINLINE>, and the
      remaining elements of the list contains the <QUOTE>arguments,</QUOTE> such
      as the destination of the <JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE>.
      For each instruction of the register-machine language, there is a 
      function whose name matches the syntax of the instruction, such as
      <JAVASCRIPTINLINE>go_to(destination)</JAVASCRIPTINLINE>, and that acts as
      a constructor for the corresponding intermediate representation. This
      reduces clutter and provides a minimal amount of sanity checks for things
      like the number of arguments.
    </JAVASCRIPT>
  </SPLIT>
  
  <TEXT>
    Before it can generate the instruction execution
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
    <JAVASCRIPT>functions,</JAVASCRIPT></SPLITINLINE>
    the assembler must know what all the labels refer to, so it begins by
    scanning the <SPLITINLINE><SCHEME>controller text</SCHEME><JAVASCRIPT>intermediate representation of the controller</JAVASCRIPT></SPLITINLINE> to separate the labels from the
    instructions.  As it scans the <SPLITINLINE><SCHEME>text</SCHEME><JAVASCRIPT>controller</JAVASCRIPT></SPLITINLINE>, it constructs both a list of
    instructions and a table that associates each label with a pointer
    into that list.  Then the assembler augments the instruction list by
    inserting the execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for each instruction.
  </TEXT>

  <TEXT>
    The <SCHEMEINLINE>assemble</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is the main entry to the assembler. It takes the controller
    <SPLITINLINE><SCHEME>text</SCHEME></SPLITINLINE> and the
    machine model as arguments and returns the instruction sequence to be stored
    in the model.
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Assemble</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>assemble</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to build the initial instruction list and label table from the supplied
    controller<SPLITINLINE><SCHEME> text</SCHEME></SPLITINLINE>.  The second argument
    to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be called to process these results: This
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    uses
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-insts!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>update_insts</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to generate the instruction execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    and insert them into the instruction list, and returns the modified list.
    <!--  \indcode*{assemble} -->
    <SNIPPET>
      <NAME>assemble</NAME>
      <REQUIRES>update_insts</REQUIRES>
      <REQUIRES>extract_labels</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (assemble controller-text machine)
  (extract-labels controller-text
                  (lambda (insts labels)
                    (update-insts! insts labels machine)
                    insts)))
      </SCHEME>
      <JAVASCRIPT>
function assemble(controller_ir, machine) {
    return extract_labels(controller_ir,
        (insts, labels) => {
           update_insts(insts, labels, machine);
           return insts;
        });
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
        <SCHEMEINLINE>Extract-labels</SCHEMEINLINE> takes as arguments a list
        <SCHEMEINLINE>text</SCHEMEINLINE> (the sequence of controller instruction
        expressions) and a <SCHEMEINLINE>receive</SCHEMEINLINE> procedure.
        <SCHEMEINLINE>Receive</SCHEMEINLINE> will be called with two values: (1) a
        list <SCHEMEINLINE>insts</SCHEMEINLINE> of instruction data structures,
        each containing an instruction from <SCHEMEINLINE>text</SCHEMEINLINE>; and
        (2) a table called <SCHEMEINLINE>labels</SCHEMEINLINE>, which associates
        each label from <SCHEMEINLINE>text</SCHEMEINLINE> with the position in the
        list <SCHEMEINLINE>insts</SCHEMEINLINE> that the label designates.
      </SCHEME>
      <JAVASCRIPT>
	      The function <JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE> takes
	      as arguments the controller<APOS/>s intermediate representation as a
	      list of instructions and a <JAVASCRIPTINLINE>receive</JAVASCRIPTINLINE>
	      function. The function <JAVASCRIPTINLINE>receive</JAVASCRIPTINLINE> will
	      be called with two values: (1) a list <JAVASCRIPTINLINE>insts</JAVASCRIPTINLINE>
	      of instruction data structures, each containing an instruction from
	      <JAVASCRIPTINLINE>controller_ir</JAVASCRIPTINLINE>; and (2) a table called
	      <JAVASCRIPTINLINE>labels</JAVASCRIPTINLINE>, which associates each label from
	      <JAVASCRIPTINLINE>controller_ir</JAVASCRIPTINLINE> with the position in the list
	      <JAVASCRIPTINLINE>insts</JAVASCRIPTINLINE> that the label designates.
      </JAVASCRIPT>
    </SPLIT>
    
    <!--  \indcode*{extract-labels} -->
    <SNIPPET>
      <NAME>extract_labels</NAME>
      <REQUIRES>make_label_entry</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (extract-labels text receive)
   (if (null? text)
       (receive '() '())
       (extract-labels (cdr text)
        (lambda (insts labels)
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (receive insts
                         (cons (make-label-entry next-inst
                                                 insts)
                               labels))
                (receive (cons (make-instruction next-inst)
                               insts)
                         labels)))))))
      </SCHEME>
      <JAVASCRIPT>
function extract_labels(controller_ir, receive) {
    return is_null(controller_ir)
           ? receive(null, null)
           : extract_labels(tail(controller_ir), 
               (insts, labels) => {
                   const next_inst = head(controller_ir);
                   return is_string(next_inst)
                          ? receive(insts, 
                                    pair(make_label_entry(next_inst, 
                                                          insts), 
                                         labels))
                          : receive(pair(make_instruction(next_inst), 
                                         insts),
                                    labels); 
               });
}
      </JAVASCRIPT>
    </SNIPPET>
    
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>The function
      <JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    works by sequentially scanning the elements of the
    <SCHEMEINLINE>text</SCHEMEINLINE> and accumulating the
    <SCHEMEINLINE>insts</SCHEMEINLINE> and the
    <SCHEMEINLINE>labels</SCHEMEINLINE>. If an element is a
    <SPLITINLINE>
      <SCHEME>symbol</SCHEME>
      <JAVASCRIPT>string</JAVASCRIPT>
    </SPLITINLINE>
    (and thus a label) an appropriate entry is added to the
    <SCHEMEINLINE>labels</SCHEMEINLINE> table.  Otherwise the element is
    accumulated onto the <SCHEMEINLINE>insts</SCHEMEINLINE>
    list.<FOOTNOTE>
    <!-- \indcodeplus{receive}{<SPLITINLINE><SCHEME>procedure</SCHEME>
	 <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>} -->
    Using the
    <SCHEMEINLINE>receive</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    here is a way to get
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to effectively return two
    values<EMDASH/><SCHEMEINLINE>labels</SCHEMEINLINE> and
    <SCHEMEINLINE>insts</SCHEMEINLINE><EMDASH/>without explicitly making a
    compound data structure to hold them.  An alternative implementation, which
    returns an explicit pair of values, is
    <!--  \indcode*{extract-labels} -->
    <SNIPPET EVAL="no">
      <NAME>extract_labels_alternative</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
      </SCHEME>
  <JAVASCRIPT>
function extract_labels(instructions) { 
    if (is_null(instructions)) {
        return pair(null, null);
    } else {
        const result = extract_labels(tail(instructions));
        const insts = head(result);
        const labels = tail(result);
        const next_inst = head(instructions);
        return is_string(next_inst)
               ? pair(insts, 
                      pair(make_label_entry(next_inst, insts), labels))
               : pair(pair(make_instruction(next_inst), insts), 
                      labels);
    }
}
  </JAVASCRIPT>
    </SNIPPET>
    which would be called by <SCHEMEINLINE>assemble</SCHEMEINLINE> as follows:
    <!--  \indcode*{assemble} -->
    <SNIPPET EVAL="no">
      <NAME>assemble_alternative</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
      </SCHEME>
  <JAVASCRIPT>
function assemble(controller_ir, machine) {
    const result = extract_labels(controller_ir);
    const insts = head(result);
    const labels = tail(result);

    update_insts(insts, labels, machine);

    return insts;
}
  </JAVASCRIPT>
    </SNIPPET>

    <INDEX>returning multiple values</INDEX>
    <INDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>returning multiple values</SUBINDEX></INDEX>
    <INDEX>continuation<SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
    You can consider our use of <SCHEMEINLINE>receive</SCHEMEINLINE> as
    demonstrating an elegant way to return multiple values, or simply an excuse
    to show off a programming trick.  An argument like
    <SCHEMEINLINE>receive</SCHEMEINLINE> that is the next
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    to be invoked is called a <QUOTE>continuation.</QUOTE>  Recall that we
    also used continuations to implement the backtracking control
    structure in the <SCHEMEINLINE>amb</SCHEMEINLINE> evaluator in
    section<SPACE/><REF NAME="sec:amb-implementation"/>.</FOOTNOTE>
  </TEXT>

  <TEXT>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Update-insts!</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
      <JAVASCRIPTINLINE>update_insts</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    modifies the instruction list, which initially contains only 
    <SPLITINLINE>
      <SCHEME>the text of the instructions,</SCHEME>
      <JAVASCRIPT>an intermediate representation of the instructions</JAVASCRIPT>
    </SPLITINLINE>
    to include the corresponding execution
    <SPLITINLINE>
      <SCHEME>procedures:</SCHEME>
      <JAVASCRIPT>functions:</JAVASCRIPT>
    </SPLITINLINE>
    <!--  \indcode*{update-insts!} -->
    <SNIPPET>
      <NAME>update_insts</NAME>
      <REQUIRES>get_register</REQUIRES>
      <REQUIRES>make_execution_function</REQUIRES>
      <REQUIRES>make_instruction</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
      </SCHEME>
      <JAVASCRIPT>
function update_insts(insts, labels, machine) {
    const pc = get_register(machine, "pc");
    const flag = get_register(machine, "flag");
    const stack = machine("stack");
    const ops = machine("operations");
    return for_each(
        inst => set_instruction_execution_fun(
            inst,
            make_execution_function(instruction_text(inst),
                                    labels, machine, pc,
                                    flag, stack, ops)),
        insts);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The machine instruction data structure simply pairs the
    instruction <SPLITINLINE><SCHEME>text</SCHEME></SPLITINLINE> with the corresponding execution
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is not yet available when
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    constructs the instruction, and is inserted later by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>update-insts!</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>update_insts</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
      <!--  \indcode*{make-instruction} -->
      <!--  \indcode*{instruction-text} -->
      <!--  \indcode*{instruction-execution-proc} -->
      <!--  \indcode*{set-instruction-execution-proc!} -->
    <SNIPPET>
      <NAME>make_instruction</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-instruction text)
  (cons text <APOS/>()))

(define (instruction-text inst)
  (car inst))

(define (instruction-execution-proc inst)
  (cdr inst))

(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
      </SCHEME>
      <JAVASCRIPT>
function make_instruction(text) {
    return pair(text, null);
}
function instruction_text(inst) {
    return head(inst);
}
function instruction_execution_fun(inst) {
    return tail(inst);
}
function set_instruction_execution_fun(inst, proc) {
    set_tail(inst, proc); 
}
      </JAVASCRIPT>
    </SNIPPET>

    The instruction text is not used by our simulator, but it is handy to keep
    around for debugging (see
    exercise<SPACE/><REF NAME="ex:reg-machine-instruction-trace"/>).
  </TEXT>

  <TEXT>
    Elements of the label table are pairs:
    <!--  \indcode*{make-label-entry} -->
    <SNIPPET>
      <NAME>make_label_entry</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-label-entry label-name insts)
  (cons label-name insts))
      </SCHEME>
      <JAVASCRIPT>
function make_label_entry(label_name, insts) {
    return pair(label_name, insts);
}
      </JAVASCRIPT>
    </SNIPPET>
    Entries will be looked up in the table with
    <!--  \indcode*{lookup-label} -->
    <SNIPPET>
      <NAME>lookup_label</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label - - ASSEMBLE" label-name))))
      </SCHEME>
      <JAVASCRIPT>
function lookup_label(labels, label_name) {
    const val = assoc(label_name, labels);
    return is_undefined(val)
           ? error(label_name, "undefined label -- assemble")
           : tail(val);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    The following register-machine code is ambiguous, because the label
    <SCHEMEINLINE>here</SCHEMEINLINE> is defined more than once:
    <SNIPPET EVAL="no">
      <SCHEME>
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
      </SCHEME>
      <JAVASCRIPT>
"start",
  go_to(label("here")),
"here",
  assign("a", constant(3)),
  go_to(label("there")),
"here",
  assign("a", constant(4)),
  go_to(label("there")),
"there",
      </JAVASCRIPT>
    </SNIPPET>
    With the simulator as written, what will the contents of register
    <SCHEMEINLINE>a</SCHEMEINLINE> be when control reaches
    <SCHEMEINLINE>there</SCHEMEINLINE>?  Modify the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>extract-labels</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>extract_labels</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    so that the assembler will signal an error if the same label
    name is used to indicate two different locations.
  </EXERCISE>

<SPLIT>
  <JAVASCRIPT>
    <SUBHEADING>
      <NAME>The controller intermediate representation</NAME>
    </SUBHEADING>

    <TEXT>
      In the beginning of this chapter, the controller for the GCD machine was
      specified as a list of string labels and function calls. Each function
      call corresponds to a constructor for the controller<APOS/>s intermediate
      representation. Each constructor for an instruction simply returns a
      tagged list, and does not perform any instruction in the machine. To
      extract arguments from an instruction, we use selector functions, which
      introduce meaningful names such as
      <JAVASCRIPTINLINE>perform_action</JAVASCRIPTINLINE> to get the action from
      a <JAVASCRIPTINLINE>perform</JAVASCRIPTINLINE> instruction.
    </TEXT>
    
    <TEXT>
      The function <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> constructs
      <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instructions.
      The selector functions <JAVASCRIPTINLINE>assign_reg_name</JAVASCRIPTINLINE> and
      <JAVASCRIPTINLINE>assign_value_exp</JAVASCRIPTINLINE> extract the register name
      and value expression from an assign instruction.
      <SNIPPET>
        <NAME>assign_constructor</NAME>
        <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
        <JAVASCRIPT>
function assign(register_name, source) {
    return list("assign", register_name, source);
}
function assign_reg_name(assign_instruction) {
    return head(tail(assign_instruction));
}
function assign_value_exp(assign_instruction) { 
    return head(tail(tail(assign_instruction)));
}
        </JAVASCRIPT>
      </SNIPPET>
    
      The function <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> constructs
      <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE> instructions. The selector
      <JAVASCRIPTINLINE>test_condition</JAVASCRIPTINLINE> extracts the condition
      from a test.

      <SNIPPET>
        <NAME>test_instruction_syntax</NAME>
        <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
        <JAVASCRIPT>
function test(condition) { return list("test", condition); }
function test_condition(test_inst) { return head(tail(test_inst)); }
        </JAVASCRIPT>
      </SNIPPET>
      
      
      The function <JAVASCRIPTINLINE>branch</JAVASCRIPTINLINE>
      constructs <JAVASCRIPTINLINE>branch</JAVASCRIPTINLINE> instructions. The
      selector 
      <JAVASCRIPTINLINE>branch_dest</JAVASCRIPTINLINE> extracts
      the destination from a branch.
      <SNIPPET>
        <NAME>branch_branch_dest</NAME>
        <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
        <JAVASCRIPT>
function branch(label) { return list("branch", label); }
function branch_dest(branch_inst) { return head(tail(branch_inst)); }
        </JAVASCRIPT>
      </SNIPPET>

      The function <JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE> is constructs
      <JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE> instructions. The selector function
      <JAVASCRIPTINLINE>go_to_dest</JAVASCRIPTINLINE> extracts the destination from a
      <JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE> instruction.
      
      <SNIPPET>
        <NAME>go_to_go_to_dest</NAME>
        <REQUIRES>make_go_to</REQUIRES>
        <EXAMPLE>go_to_go_to_dest</EXAMPLE>
        <JAVASCRIPT>
function go_to(label) { return list("go_to", label); }
function go_to_dest(go_to_inst) { return head(tail(go_to_inst)); }
        </JAVASCRIPT>
      </SNIPPET>

      The functions <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and
      <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> construct
      <JAVASCRIPTINLINE>save</JAVASCRIPTINLINE> and <JAVASCRIPTINLINE>restore</JAVASCRIPTINLINE> instructions. The
      selector
      <JAVASCRIPTINLINE>stack_inst_reg_name</JAVASCRIPTINLINE>
      extracts the register name from such instructions.

    <SNIPPET>
      <NAME>save_restore</NAME>
      <REQUIRES>make_save</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <JAVASCRIPT>
function save(reg) { return list("save", reg); }
function restore(reg) { return list("restore", reg); }
function stack_inst_reg_name(stack_instruction) {
    return head(tail(stack_instruction));
}
      </JAVASCRIPT>
    </SNIPPET>

      The function <JAVASCRIPTINLINE>perform</JAVASCRIPTINLINE> 
      constructs <JAVASCRIPTINLINE>perform</JAVASCRIPTINLINE> instructions. The
      selector 
      <JAVASCRIPTINLINE>perform_action</JAVASCRIPTINLINE> extracts
      the action from a <JAVASCRIPTINLINE>perform</JAVASCRIPTINLINE> instruction.

      <SNIPPET>
        <NAME>perform_perform_action</NAME>
        <REQUIRES>make_perform</REQUIRES>
        <EXAMPLE>perform_perform_action</EXAMPLE>
        <JAVASCRIPT>
function perform(action) { return list("perform", action); }
function perform_action(inst) { return head(tail(inst)); }
        </JAVASCRIPT>
      </SNIPPET>

      The syntax of <JAVASCRIPTINLINE>reg</JAVASCRIPTINLINE>,
      <JAVASCRIPTINLINE>label</JAVASCRIPTINLINE>, and <JAVASCRIPTINLINE>constant</JAVASCRIPTINLINE>
        expressions is determined by the following constructor functions, along with
        corresponding predicates and selectors.
      <!--  \indcode*{register-exp} -->
      <!--  \indcode*{register-exp-reg} -->
      <!--  \indcode*{constant-exp} -->
      <!--  \indcode*{constant-exp-value} -->
      <!--  \indcode*{label-exp} -->
      <!--  \indcode*{label-exp-label} -->
      <!--  \indcode*{operation-exp} -->
      <!--  \indcode*{operation-exp-op} -->
      <!--  \indcode*{operation-exp-operands} -->
    <SNIPPET>
      <NAME>is_register_exp0</NAME>
      <REQUIRES>tagged_list</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <JAVASCRIPT>
function reg(name) { return list("reg", name); }
function is_register_exp(exp) { return is_tagged_list(exp, "reg"); }
function register_exp_reg(exp) { return head(tail(exp)); }

function constant(value) { return list("constant", value); }
function is_constant_exp(exp) { return is_tagged_list(exp, "constant"); }
function constant_exp_value(exp) { return head(tail(exp)); }

function label(name) { return list("label", name); }
function is_label_exp(exp) { return is_tagged_list(exp, "label"); }
function label_exp_label(exp) { return head(tail(exp)); }
      </JAVASCRIPT>
    </SNIPPET>

    In the register-machine language, an operation is expressed as a list with an
    operator followed by operands,
    <SNIPPET>
      <NAME>is_register_exp</NAME>
      <REQUIRES>is_register_exp0</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <JAVASCRIPT>
function op(name) { return list("op", name); }
function is_operation_exp(exp) {
    return is_pair(exp) &amp;&amp; is_tagged_list(head(exp), "op");
}
function operation_exp_op(op_exp) { return head(tail(head(op_exp))); }
function operation_exp_operands(op_exp) { return tail(op_exp); }
      </JAVASCRIPT>
    </SNIPPET>

      Finally, we use the function <JAVASCRIPTINLINE>type</JAVASCRIPTINLINE> to extract
      an instruction<APOS/>s type, which is always the first element of the list.
      
      <SNIPPET>
        <NAME>type_function</NAME>
        <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
        <JAVASCRIPT>
function type(instruction) { return head(instruction); }
        </JAVASCRIPT>
      </SNIPPET>

      In section<SPACE/><REF NAME="sec:ex-proc"/>, we will
      describe functions that give semantics to the intermediate
      representations of the instructions in the register machine. 

    </TEXT>
  </JAVASCRIPT>
</SPLIT>



  <INDEX>assembler|)</INDEX>
</SUBSECTION>



    <SUBSECTION>
      <NAME>
  The Machine Model
      </NAME>

      <LABEL NAME="sec:machine-model"/>

      <TEXT>
  The machine model generated by <SCHEMEINLINE>make-machine</SCHEMEINLINE> is represented as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state using the message-passing techniques
  developed in chapter<SPACE/>3.  To build this model, <SCHEMEINLINE>make-machine</SCHEMEINLINE>
  begins by calling the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-new-machine</SCHEMEINLINE> to construct
  the parts of the machine model that are common to all register
  machines.  This basic machine model constructed by <SCHEMEINLINE>make-new-machine</SCHEMEINLINE> is essentially a container for some registers and a
  stack, together with an execution mechanism that processes the controller
  instructions one by one.
      </TEXT>

      <TEXT>
  <SCHEMEINLINE>Make-machine</SCHEMEINLINE> then extends this basic model (by sending it
  messages) to include the registers, operations, and controller of the
  particular machine being defined.  First it allocates a register in
  the new machine for each of the supplied register names and installs
  the designated operations in the machine.  Then it uses an 
  <INDEX>assembler</INDEX>
  <EM>
    assembler</EM> (described below in section<SPACE/><REF NAME="sec:assembler"/>) to
  transform the controller list into instructions for the new machine
  and installs these as the machine<APOS/>s instruction sequence.  <SCHEMEINLINE>Make-machine</SCHEMEINLINE> returns as its value the modified machine model.

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-machine} -->
      (define (make-machine register-names ops controller-text)
      (let ((machine (make-new-machine)))
      (for-each (lambda (register-name)
            ((machine 'allocate-register) register-name))
            register-names)
      ((machine 'install-operations) ops)    
      ((machine 'install-instruction-sequence)
      (assemble controller-text machine))
      machine))
    </SCHEME>
  <JAVASCRIPT>
function make_machine(register_names, ops, controller_text) {
    const machine = make_new_machine();

    map(reg_name => machine("allocate_register")(reg_name), register_names);
    machine("install_operations")(ops);
    machine("install_instruction_sequence")(assemble(controller_text, machine));

    return machine;
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>Registers</NAME>
      </SUBHEADING>

      <INDEX>register(s)<SUBINDEX>representing</SUBINDEX></INDEX>

      <TEXT>
  We will represent a register as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state, as in
  chapter<SPACE/>3.  The
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-register</SCHEMEINLINE> creates a register that
  holds a value that can be accessed or changed:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-register} -->
      (define (make-register name)
      (let ((contents '*unassigned*))
      (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
            (lambda (value) (set! contents value)))
            (else
            (error "Unknown request - - REGISTER" message))))
      dispatch))
    </SCHEME>
  <JAVASCRIPT>
function make_register(name) {
    let contents = "*unassigned*";

    function dispatch(message) {
        if (message === "get") {
            return contents;

        } else {
            if (message === "set") {
                return value => { contents = value; };

            } else {
                error(message, "Unknown request: REGISTER");
            }
        }
    }

    return dispatch;
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The following
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  are used to access registers:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{get-contents} -->
      (define (get-contents register)
      (register 'get))

      <!--  \indcode*{set-contents!} -->
      (define (set-contents! register value)
      ((register 'set) value))
    </SCHEME>
  <JAVASCRIPT>
function get_contents(register) {
    return register("get");
}

function set_contents(register, value) {
    return register("set")(value);
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>The stack</NAME>
      </SUBHEADING>

      <INDEX>stack<SUBINDEX>representing</SUBINDEX></INDEX>

      <TEXT>
  We can also represent a stack as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state.  The
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-stack</SCHEMEINLINE> creates a stack whose local state consists
  of a list of the items on the stack.  A stack accepts requests to <SCHEMEINLINE>push</SCHEMEINLINE> an item onto the stack, to <SCHEMEINLINE>pop</SCHEMEINLINE> the top item off the stack
  and return it, and to <SCHEMEINLINE>initialize</SCHEMEINLINE> the stack to empty.

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-stack} -->
      (define (make-stack)
      (let ((s '()))
      (define (push x)
      (set! s (cons x s)))
      (define (pop)
      (if (null? s)
            (error "Empty stack - - POP")
            (let ((top (car s)))
            (set! s (cdr s))
            top)))
      (define (initialize)
      (set! s '())
      'done)
      (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request - - STACK"
            message))))
      dispatch))
    </SCHEME>
  <JAVASCRIPT>
function make_stack() {
    let stack = null;

    function push(x) { 
        stack = pair(x, stack); 
        return "done";
    }

    function pop() {
        if (is_null(stack)) {
            error("Empty stack: POP");

        } else {
            const top = head(stack);
            stack = tail(stack);
            return top;
        }
    }

    function initialize() {
        stack = null;
        return "done";
    }

    function dispatch(message) {
        return message === "push"
            ? push
            : message === "pop"
            ? pop()
            : message === "initialize"
            ? initialize()
            : error("Unknown request: STACK", message);
    }

    return dispatch;
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The following
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  are used to access stacks:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{pop} -->
      (define (pop stack)
      (stack 'pop))

      <!--  \indcode*{push} -->
      (define (push stack value)
      ((stack 'push) value))
    </SCHEME>
  <JAVASCRIPT>
function pop(stack) {
    return stack("pop");
}

function push(stack, value) {
    return stack("push")(value);
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>The basic machine</NAME>
      </SUBHEADING>

      <TEXT>
  The <SCHEMEINLINE>make-new-machine</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, shown in
  figure<SPACE/><REF NAME="fig:make-new-machine"/>, constructs an object whose local
  state consists of a stack, an initially empty instruction sequence, a
  list of operations that initially contains an operation to 
  <!-- \indcodeplus{initialize-stack}{operation in register machine}-->
  initialize
  the stack, and a 
  <INDEX>register table, in simulator</INDEX>
  <EM>register table</EM> that initially contains two
  <!-- \indcodeplus{flag}{register}-->
  <!-- \indcodeplus{pc}{register}-->
  registers, named <SCHEMEINLINE>flag</SCHEMEINLINE> and <SCHEMEINLINE>pc</SCHEMEINLINE> 
  <INDEX>program counter</INDEX>
  (for <QUOTE>program counter</QUOTE>).
  The internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>allocate-register</SCHEMEINLINE> adds new entries to the
  register table, and the internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>lookup-register</SCHEMEINLINE> looks
  up registers in the table.
      </TEXT>

      <TEXT>
  The <SCHEMEINLINE>flag</SCHEMEINLINE> register is used to control branching in the simulated
  machine.  <SCHEMEINLINE>Test</SCHEMEINLINE> instructions set the contents of <SCHEMEINLINE>flag</SCHEMEINLINE> to
  the result of the test (true or false).  <SCHEMEINLINE>Branch</SCHEMEINLINE> instructions
  decide whether or not to branch by examining the contents of <SCHEMEINLINE>flag</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  The <SCHEMEINLINE>pc</SCHEMEINLINE> register determines the sequencing of instructions as
  the machine runs.  This sequencing is implemented by the internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>execute</SCHEMEINLINE>.
  In the simulation model, each machine instruction is a data structure
  that includes a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  of no arguments, called the 
  <INDEX>instruction execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></INDEX>
  <INDEX>execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
  <EM>instruction
    execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></EM>, such that calling this
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  simulates
  executing the instruction.  As the simulation runs, <SCHEMEINLINE>pc</SCHEMEINLINE> points to
  the place in the instruction sequence beginning with the next
  instruction to be executed.  
  <!--  \indcode{execute} -->
  <SCHEMEINLINE>Execute</SCHEMEINLINE> gets that instruction,
  executes it by calling the instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, and
  repeats this cycle until there are no more instructions to execute
  (i.e., until <SCHEMEINLINE>pc</SCHEMEINLINE> points to the end of the instruction sequence).

  \begin{figure}
  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-new-machine} -->
      (define (make-new-machine)
      (let ((pc (make-register 'pc))
            (flag (make-register 'flag))
            (stack (make-stack))
            (the-instruction-sequence '()))
      (let ((the-ops
            (list (list 'initialize-stack
            (lambda () (stack 'initialize)))))
            (register-table
            (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
            (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
            (cons (list name (make-register name))
            register-table)))
            'register-allocated)
      (define (lookup-register name)
            (let ((val (assoc name register-table)))
            (if val
            (cadr val)
            (error "Unknown register:" name))))
      (define (execute)
            (let ((insts (get-contents pc)))
            (if (null? insts)
            'done
            (begin
            ((instruction-execution-proc (car insts)))
            (execute)))))
      (define (dispatch message)
            (cond ((eq? message 'start)
            (set-contents! pc the-instruction-sequence)
            (execute))
            ((eq? message 'install-instruction-sequence)
            (lambda (seq) (set! the-instruction-sequence seq)))
            ((eq? message 'allocate-register) allocate-register)
            ((eq? message 'get-register) lookup-register)
            ((eq? message 'install-operations)
            (lambda (ops) (set! the-ops (append the-ops ops))))
            ((eq? message 'stack) stack)
            ((eq? message 'operations) the-ops)
            (else (error "Unknown request - - MACHINE" message))))
      dispatch)))
    </SCHEME>
  <JAVASCRIPT>
function make_new_machine() {
    const pc = make_register("pc");
    const flag = make_register("flag");
    const stack = make_stack();
    let the_instruction_sequence = null;
    let the_ops = list(list("initialize_stack", () => stack("initialize")));
    let register_table = list(list("pc", pc), list("flag", flag));
    
    function allocate_register(name) {
        if (assoc(name, register_table) === undefined) {
            register_table = pair(list(name, make_register(name)), register_table);

        } else {
            error(name, "Multiply defined register: ");
        }

        return "register_allocated";
    }

    function lookup_register(name) {
        const val = assoc(name, register_table);
        
        return val === undefined
            ? error(name, "Unknown register:")
            : head(tail(val));
    }

    function execute() {
        const insts = get_contents(pc);

        if (is_null(insts)) {
            return "done";

        } else {
            const proc = instruction_execution_proc(head(insts)); 
            proc(); /// FIXME: delete intermediate step? Added by Tobias for clarity.
            return execute();
        }
    }

    function dispatch(message) {
        return message === "start"
                ? () => { set_contents(pc, the_instruction_sequence); return execute(); }
            : message === "install_instruction_sequence"
                ? seq => { the_instruction_sequence = seq; }
            : message === "allocate_register"
                ? allocate_register
            : message === "get_register"
                ? lookup_register
            : message === "install_operations"
                ? ops => { the_ops = append(the_ops, ops); }
            : message === "stack"
                ? stack
            : message === "operations"
                ? the_ops
            : error(message, "Unknown request: MACHINE");
    }
    
    return dispatch;
}
  </JAVASCRIPT>
  </SNIPPET>
  \vskip -10pt
  \figcaption {The <SCHEMEINLINE>make-new-machine</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, which implements
  the basic machine model.}
  <LABEL NAME="fig:make-new-machine"/>
  \end{figure}
      </TEXT>

      <TEXT>
  As part of its operation, each instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  modifies <SCHEMEINLINE>pc</SCHEMEINLINE> to indicate the next instruction to be executed.
  <SCHEMEINLINE>Branch</SCHEMEINLINE> and <SCHEMEINLINE>goto</SCHEMEINLINE> instructions change <SCHEMEINLINE>pc</SCHEMEINLINE> to point to
  the new destination.  All other instructions simply advance <SCHEMEINLINE>pc</SCHEMEINLINE>,
  making it point to the next instruction in the sequence.  Observe that
  each call to <SCHEMEINLINE>execute</SCHEMEINLINE> calls <SCHEMEINLINE>execute</SCHEMEINLINE> again, but this does
  not produce an infinite loop because running the instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  changes the contents of <SCHEMEINLINE>pc</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  <SCHEMEINLINE>Make-new-machine</SCHEMEINLINE> returns a
  <SCHEMEINLINE>dispatch</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that implements message-passing
  access to the internal state.  Notice that starting the machine is
  accomplished by setting <SCHEMEINLINE>pc</SCHEMEINLINE> to the beginning of the instruction
  sequence and calling <SCHEMEINLINE>execute</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  For convenience, we provide an alternate procedural interface to a
  machine<APOS/>s <SCHEMEINLINE>start</SCHEMEINLINE> operation,
  as well as
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  to set and examine register contents,
  as specified at the beginning of section<SPACE/><REF NAME="sec:simulator"/>:

  <SNIPPET>
    <SCHEME>
      <!-- \indcodeplus*{start}{register machine}-->
      (define (start machine)
      (machine 'start))

      <!--  \indcode*{get-register-contents} -->
      (define (get-register-contents machine register-name)
      (get-contents (get-register machine register-name)))

      <!--  \indcode*{set-register-contents!} -->
      (define (set-register-contents! machine register-name value)
      (set-contents! (get-register machine register-name) value)
      'done)
    </SCHEME>
  <JAVASCRIPT>
function start(machine) {
    return machine("start")();
}

function get_register_contents(machine, register_name) {
    return get_contents(get_register(machine, register_name));
}

function set_register_contents(machine, register_name, value) {
    set_contents(get_register(machine, register_name), value);
    return "done";
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

      <TEXT>
  These
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  (and many
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  in sections<SPACE/><REF NAME="sec:assembler"/>
  and <REF NAME="sec:ex-proc"/>) use the following to look up the register with a
  given name in a given machine:
  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{get-register} -->
      (define (get-register machine reg-name)
      ((machine 'get-register) reg-name))
    </SCHEME>
  <JAVASCRIPT>
function get_register(machine, reg_name) {
    return machine("get_register")(reg_name);
}
  </JAVASCRIPT>
  </SNIPPET>
      </TEXT>

    </SUBSECTION>

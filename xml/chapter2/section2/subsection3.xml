    <SUBSECTION>
      <NAME>
        Sequences as Conventional Interfaces
      </NAME>

      <LABEL NAME="sec:sequences-conventional-interfaces"/>
      <INDEX>sequence(s)<SUBINDEX>as conventional interface|(</SUBINDEX></INDEX>
      <INDEX>conventional interface<SUBINDEX>sequence as|(</SUBINDEX></INDEX>

      <TEXT>
        In working with compound data, we<APOS/>ve stressed how data abstraction
        permits us to design programs without becoming enmeshed in the details
        of data representations, and how abstraction preserves for us the
        flexibility to experiment with alternative representations.  In this
        section, we introduce another powerful design principle for working
        with data structures<EMDASH/>the use of <EM>conventional interfaces</EM>.
      </TEXT>

      <TEXT>
        In Section<SPACE/><REF NAME="sec:higher-order-procedures"/> we saw how program
        abstractions, implemented as higher-order
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>, can capture
        common patterns in programs that deal with numerical data.  Our
        ability to formulate analogous operations for working with compound
        data depends crucially on the style in which we manipulate our data
        structures.  Consider, for example, the following
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, analogous
        to the <SPLITINLINE><SCHEME><SCHEMEINLINE>count-leaves</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        of Section<SPACE/><REF NAME="sec:trees"/>, which
        takes a tree as argument and computes the sum of the squares of the
        leaves that are odd:

        <SNIPPET HIDE="yes">
          <NAME>odd_definition</NAME>
          <SCHEME>
(define (odd? n)
  (= (remainder n 2) 1))
          </SCHEME>
          <JAVASCRIPT>
function is_odd(n) {
    return n % 2 === 1;
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>odd_definition</REQUIRES>
          <EXAMPLE>sum_odd_squares_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{sum-odd-squares} -->
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
          (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
          (sum-odd-squares (cdr tree))))))
          </SCHEME>
          <JAVASCRIPT>
function sum_odd_squares(tree) {
    return is_empty_list(tree)
           ? 0
           : !is_pair(tree)
             ? (is_odd(tree) ? square(tree) : 0)
             : sum_odd_squares(head(tree))
               +
               sum_odd_squares(tail(tree));
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>sum_odd_squares_example</NAME>
          <SCHEME>
            <!-- \indcode*{sum-odd-squares} -->
(sum-odd-squares (list (list 2 3) (list 4 5)))
          </SCHEME>
          <JAVASCRIPT>
sum_odd_squares(list(list(2, 3), list(4, 5)));
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        On the surface, this
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        is very different from the following
        one, which constructs a list of all the even Fibonacci numbers
        <LATEXINLINE>${\rm Fib}(k)$</LATEXINLINE>, where <LATEXINLINE>$k$</LATEXINLINE> is less than or equal to a given integer <LATEXINLINE>$n$</LATEXINLINE>:
        <SNIPPET>
          <REQUIRES>even_definition</REQUIRES>
          <REQUIRES>fib_definition</REQUIRES>
          <EXAMPLE>even_fibs_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{even-fibs} -->
(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
      nil
      (let ((f (fib k)))
        (if (even? f)
          (cons f (next (+ k 1)))
          (next (+ k 1))))))
  (next 0))
          </SCHEME>
          <JAVASCRIPT>
function even_fibs(n) {
    function next(k) {
        if (k &gt; n) {
            return [];
        } else {
            const f = fib(k);
            return is_even(f)
                   ? pair(f, next(k + 1))
                   : next(k + 1);
        }
    }
    return next(0);
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>even_fibs_example</NAME>
          <SCHEME>
            <!-- \indcode*{even-fibs} -->
(even-fibs 9)
          </SCHEME>
          <JAVASCRIPT>
even_fibs(9);
        </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <TEXT>
        Despite the fact that these two
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        are structurally very
        different, a more abstract description of the two computations reveals
        a great deal of similarity.  The first program
        <UL>
          <LI>enumerates the leaves of a tree;
          </LI>
          <LI>filters them, selecting the odd ones;
          </LI>
          <LI>squares each of the selected ones; and
          </LI>
          <LI>accumulates the results using <SPLITINLINE><SCHEME><SCHEMEINLINE>+</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>+</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, starting with 0.
          </LI>
        </UL>
      </TEXT>

      <TEXT>
        The second program
        <UL>
          <LI>enumerates the integers from 0 to <LATEXINLINE>$n$</LATEXINLINE>;
          </LI>
          <LI>computes the Fibonacci number for each integer;
          </LI>
          <LI>filters them, selecting the even ones; and
          </LI>
          <LI>accumulates the results using <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,  starting with the
            empty list.
          </LI>
        </UL>
      </TEXT>

      <TEXT>
        <INDEX>signal-processing view of computation</INDEX>
        <INDEX>signal-flow diagram</INDEX>
        A signal-processing engineer would find it natural to conceptualize
        these processes in terms of signals flowing through a cascade of
        stages, each of which implements part of the program plan, as shown in
        Figure<SPACE/><REF NAME="fig:signal-flow-plans"/>.  In <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we
        begin with an 
        <INDEX>enumerator</INDEX>
        <EM>enumerator</EM>, which generates a <QUOTE>signal</QUOTE>
        consisting of the leaves of a given tree.  This signal is passed
        through a 
        <INDEX>filter</INDEX>
        <EM>filter</EM>, which eliminates all but the odd elements.
        The resulting signal is in turn passed through a 
        <INDEX>mapping<SUBINDEX>trans@as a transducer</SUBINDEX></INDEX>
        <EM>map</EM>, which is a
        <QUOTE>transducer</QUOTE> that applies the <SCHEMEINLINE>square</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to each
        element.  The output of the map is then fed to an 
        <INDEX>accumulator</INDEX>
        <EM>accumulator</EM>,
        which combines the elements using <SPLITINLINE><SCHEME><SCHEMEINLINE>+</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>+</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, starting from an initial 0.
        The plan for <SPLITINLINE><SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>even_fibs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is analogous.


              <FIGURE>
                <FIGURE src="img_original/ch2-Z-G-17.gif"></FIGURE>
                <LABEL NAME="fig:signal-flow-plans"/>
                <CAPTION>The signal-flow plans for the
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> (top) and <SPLITINLINE><SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>even_fibs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> (bottom) reveal the
        commonality between the two programs.
                </CAPTION>
              </FIGURE>
      </TEXT>

      <TEXT>
        Unfortunately, the two
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        definitions above fail to exhibit this
        signal-flow structure.  For instance, if we examine the <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, we find that the enumeration is
        implemented partly by the <SPLITINLINE><SCHEME><SCHEMEINLINE>null?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_empty_list</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>pair?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> tests and partly
        by the tree-recursive structure of the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  Similarly, the
        accumulation is found partly in the tests and partly in the addition used
        in the recursion.  In general, there are no distinct parts of either
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that correspond to the elements in the signal-flow
        description.
        Our two
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        decompose the computations in a different way,
        spreading the enumeration over the program and mingling it with the
        map, the filter, and the accumulation.  If we could organize our
        programs to make the signal-flow structure manifest in the
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        we write, this would increase the conceptual clarity of the resulting
        code.
      </TEXT>

      <SUBHEADING>
        <NAME>Sequence Operations</NAME>
      </SUBHEADING>

      <LABEL NAME="sec:sequence-operations"/>
      <INDEX>sequence(s)<SUBINDEX>operations on|(</SUBINDEX></INDEX>

      <TEXT>
        The key to organizing programs so as to more clearly reflect the
        signal-flow structure is to concentrate on the <QUOTE>signals</QUOTE> that flow
        from one stage in the process to the next.  If we represent these
        signals as lists, then we can use list operations to implement the
        processing at each of the stages.  For instance, we can implement the
        mapping stages of the signal-flow diagrams using the <SPLITINLINE><SCHEME><SCHEMEINLINE>map</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>map</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        from Section<SPACE/><REF NAME="sec:sequences"/>:
        <SNIPPET>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <SCHEME>
(map square (list 1 2 3 4 5))
          </SCHEME>
          <JAVASCRIPT>
map(square, list(1, 2, 3, 4, 5));
          </JAVASCRIPT>
          <SCHEMEOUTPUT>
            (1 4 9 16 25)
          </SCHEMEOUTPUT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Filtering a sequence to select only those elements that satisfy a
        given predicate is accomplished by
        <SNIPPET>
          <NAME>filter</NAME>
          <EXAMPLE>filter_odd</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{filter} -->
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
          (cons (car sequence)
                (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
          </SCHEME>
          <JAVASCRIPT>
function filter(predicate, sequence) {
    return is_empty_list(sequence)
           ? []
           : predicate(head(sequence))
             ? pair(head(sequence), 
                    filter(predicate, tail(sequence)))
             : filter(predicate, tail(sequence));
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>filter_odd</NAME>
          <SCHEME>
(define (odd? n)
  (= (remainder n 2) 1))

(filter odd? (list 1 2 3 4 5))
          </SCHEME>
          <JAVASCRIPT>
function is_odd(n) {
    return n % 2 === 1;
}
filter(is_odd, list(1, 2, 3, 4, 5));
        </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <TEXT>
        For example,
        <SNIPPET>
          <REQUIRES>filter</REQUIRES>
          <REQUIRES>odd_definition</REQUIRES>
          <SCHEME>
(filter odd? (list 1 2 3 4 5))
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 3 5)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
filter(is_odd, list(1, 2, 3, 4, 5));
        </JAVASCRIPT>
        </SNIPPET>


        Accumulations can be implemented by
        <!-- \indcode*{accumulate} -->
        <SNIPPET>
          <NAME>accumulate</NAME>
          <SCHEME>
(define (accumulate op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (accumulate op initial (cdr sequence)))))
          </SCHEME>
          <JAVASCRIPT>
function accumulate(op, initial, sequence) {
    return is_empty_list(sequence)
           ? initial
           : op(head(sequence), 
                accumulate(op, initial, tail(sequence)));
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>simple_plus</NAME>
          <SCHEME>
;; in Scheme, the operator symbol + is procedure name
          </SCHEME>
          <JAVASCRIPT>
function plus(x, y) {
    return x + y;
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>simple_plus</REQUIRES>
          <SCHEME>
(accumulate + 0 (list 1 2 3 4 5))
          </SCHEME>
          <SCHEMEOUTPUT>
15
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
accumulate(plus, 0, list(1, 2, 3, 4, 5));
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>simple_times</NAME>
          <SCHEME>
;; in Scheme, the operator symbol * is procedure name
          </SCHEME>
          <JAVASCRIPT>
function times(x, y) {
    return x * y;
}
          </JAVASCRIPT>
        </SNIPPET>


        <SNIPPET>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>simple_times</REQUIRES>
          <SCHEME>
(accumulate * 1 (list 1 2 3 4 5))
          </SCHEME>
          <SCHEMEOUTPUT>
            120
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
accumulate(times, 1, list(1, 2, 3, 4, 5));
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
          <REQUIRES>accumulate</REQUIRES>
          <SCHEME>
(accumulate cons nil (list 1 2 3 4 5))
          </SCHEME>
          <SCHEMEOUTPUT>
(1 2 3 4 5)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
accumulate(pair, [], list(1, 2, 3, 4, 5));
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        All that remains to implement signal-flow diagrams is to enumerate the
        sequence of elements to be processed.  For <SPLITINLINE><SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>even_fibs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we need to
        generate the sequence of
        integers in a given range, which we can do as follows:
        <SNIPPET>
          <NAME>enumerate_interval</NAME>
          <EXAMPLE>enumerate_interval_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{enumerate-interval} -->
(define (enumerate-interval low high)
   (if (&gt; low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
          </SCHEME>
          <JAVASCRIPT>
function enumerate_interval(low, high) {
    return low > high
           ? []
           : pair(low,
                  enumerate_interval(low + 1, high));
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>enumerate_interval_example</NAME>
          <SCHEME>
(enumerate-interval 2 7)
          </SCHEME>
          <SCHEMEOUTPUT>
(2 3 4 5 6 7)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
enumerate_interval(2, 7);
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        To enumerate the leaves of a tree, we can use<FOOTNOTE>This 
          is, in fact, precisely the 
          <!-- \indcode{fringe}[as a tree enumeration] -->
          <SPLITINLINE><SCHEME><SCHEMEINLINE>fringe</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fringe</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
          <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
          from
          Exercise<SPACE/><REF NAME="ex:fringe"/>.  Here we<APOS/>ve renamed it to emphasize that
          it is part of a family of general sequence-manipulation
          <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.</FOOTNOTE>

            <INDEX>tree<SUBINDEX>enumerating leaves of</SUBINDEX></INDEX>

        <SNIPPET>
          <NAME>enumerate_tree</NAME>
          <REQUIRES>append</REQUIRES>
          <EXAMPLE>enumerate_tree_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{enumerate-tree} -->
(define (enumerate-tree tree)
   (cond ((null? tree) nil)
         ((not (pair? tree)) (list tree))
         (else (append (enumerate-tree (car tree))
                       (enumerate-tree (cdr tree))))))
          </SCHEME>
          <JAVASCRIPT>
function enumerate_tree(tree) {
    return is_empty_list(tree)
           ? []
           : !is_pair(tree)
             ? list(tree)
             : append(enumerate_tree(head(tree)),
                      enumerate_tree(tail(tree)));
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>enumerate_tree_example</NAME>
          <SCHEME>
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
          </SCHEME>
          <SCHEMEOUTPUT>
            (1 2 3 4 5)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
enumerate_tree(list(1, list(2, list(3, 4)), 5));
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Now we can reformulate <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>even_fibs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> as in
        the signal-flow diagrams.  For <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we enumerate the
        sequence of leaves of the tree, filter this to keep only the odd
        numbers in the sequence, square each element, and sum the results:
        <SNIPPET>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>simple_plus</REQUIRES>
          <REQUIRES>filter</REQUIRES>
          <REQUIRES>odd_definition</REQUIRES>
          <REQUIRES>enumerate_tree</REQUIRES>
          <EXAMPLE>sum_odd_squares_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{sum-odd-squares} -->
(define (sum-odd-squares tree)
   (accumulate +
               0
               (map square
                 (filter odd?
                  (enumerate-tree tree)))))
          </SCHEME>
          <JAVASCRIPT>
function sum_odd_squares(tree) {
    return accumulate(plus, 
                      0, 
                      map(square, 
                          filter(is_odd, 
                                 enumerate_tree(tree))));
}
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        For <SPLITINLINE><SCHEME><SCHEMEINLINE>even-fibs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>even_fibs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we enumerate the integers from 0 to <LATEXINLINE>$n$</LATEXINLINE>, generate
        the Fibonacci number for each of these integers, filter the resulting
        sequence to keep only the even elements, and accumulate the results
        into a list:
        <SNIPPET>
          <REQUIRES>even_definition</REQUIRES>        
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>filter</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>fib_definition</REQUIRES>
          <REQUIRES>enumerate_interval</REQUIRES>
          <EXAMPLE>even_fibs_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{even-fibs} -->
(define (even-fibs n)
   (accumulate cons
               nil
               (filter even?
                 (map fib
                      (enumerate-interval 0 n)))))
          </SCHEME>
          <JAVASCRIPT>
function even_fibs(n) {
    return accumulate(pair, 
                      [], 
                      filter(is_even, 
                             map(fib, 
                                 enumerate_interval(0, n))));
}
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The value of expressing programs as sequence operations is that this
        helps us make program designs that are modular, that is, designs that
        are constructed by combining relatively independent pieces.  We can
        encourage modular design by providing a library of standard components
        together with a conventional interface for connecting the components
        in flexible ways.
      </TEXT>

      <TEXT>
        <INDEX>modularity</INDEX>
        <INDEX>sequence(s)<SUBINDEX>as source of modularity</SUBINDEX></INDEX>
        Modular construction is a powerful strategy for
        controlling complexity in engineering design.  In real
        signal-processing applications, for example, designers regularly build
        systems by cascading elements selected from standardized families of
        filters and transducers.  Similarly, sequence operations provide a
        library of standard program elements that we can mix and match.  For
        instance, we can reuse pieces from the <SPLITINLINE><SCHEME><SCHEMEINLINE>sum-odd-squares</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>sum_odd_squares</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SCHEMEINLINE>even-fibs</SCHEMEINLINE>
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        in a program that constructs a list of the
        squares of the first <LATEXINLINE>$n+1$</LATEXINLINE> Fibonacci numbers:
        <SNIPPET>
          <NAME>list_fib_squares</NAME>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>fib_definition</REQUIRES>
          <REQUIRES>enumerate_interval</REQUIRES>
          <EXAMPLE>list_fib_squares_example</EXAMPLE>
          <SCHEME>
(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
          </SCHEME>
          <JAVASCRIPT>
function list_fib_squares(n) {
    return accumulate(pair, 
                      [], 
                      map(square, 
                          map(fib, 
                              enumerate_interval(0, n))));
}                         
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>list_fib_squares_example</NAME>
          <SCHEME>
(list-fib-squares 10)
          </SCHEME>
          <SCHEMEOUTPUT>
            (0 1 1 4 9 25 64 169 441 1156 3025)
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
list_fib_squares(10);
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        We can rearrange the pieces and use them in computing the product of
        the odd integers in a sequence:
        <SNIPPET>
          <NAME>product_of_squares_of_odd_elements</NAME>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>square_definition</REQUIRES>
          <REQUIRES>filter</REQUIRES>
          <REQUIRES>odd_definition</REQUIRES>
          <REQUIRES>simple_times</REQUIRES>
          <EXAMPLE>product_of_squares_of_odd_elements_example</EXAMPLE>
          <SCHEME>
(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                (filter odd? sequence))))
          </SCHEME>
          <JAVASCRIPT>
function product_of_squares_of_odd_elements(sequence) {
    return accumulate(times, 
                      1, 
                      map(square, 
                          filter(is_odd, sequence)));
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>product_of_squares_of_odd_elements_example</NAME>
          <SCHEME>
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
          </SCHEME>
          <SCHEMEOUTPUT>
            225
          </SCHEMEOUTPUT>
          <JAVASCRIPT>
product_of_squares_of_odd_elements(list(1, 2, 3, 4, 5));
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        We can also formulate conventional data-processing applications in
        terms of sequence operations.  Suppose we have a sequence of personnel
        records and we want to find the salary of the highest-paid programmer.
        Assume that we have a selector <SPLITINLINE><SCHEME><SCHEMEINLINE>salary</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>salary</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> that returns the salary of
        a record, and a predicate <SPLITINLINE><SCHEME><SCHEMEINLINE>programmer?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_programmer</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> that tests if a record is
        for a programmer.  Then we can write
        <SNIPPET EVAL="no">
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>filter</REQUIRES>
          <SCHEME>
(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
          </SCHEME>
          <JAVASCRIPT>
function salary_of_highest_paid_programmer(records) {
    return accumulate(math_max, 
                      0, 
                      map(salary, 
                          filter(is_programmer, records)));
}
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        These examples give just a hint of the vast range of operations that
        can be expressed as sequence operations.<FOOTNOTE>
          <INDEX>Waters, Richard C.</INDEX>
          Richard Waters (1979)
          developed a program that automatically analyzes traditional 
          <INDEX>Fortran</INDEX>
          Fortran
          programs, viewing them in terms of maps, filters, and accumulations.
          He found that fully 90 percent of the code in the Fortran Scientific
          Subroutine Package fits neatly into this paradigm.  One of the reasons
          for the success of Lisp as a programming language is that lists
          provide a standard medium for expressing ordered collections so that
          they can be manipulated using higher-order operations.  The
          programming language 
          <INDEX>APL</INDEX>
          APL owes much of its power and appeal to a
          similar choice. In APL all data are represented as arrays, and there is a
          universal and convenient set of generic operators for all sorts of
          array operations.</FOOTNOTE>
      </TEXT>

      <TEXT>
        Sequences, implemented here as lists, serve
        as a conventional interface that permits us to combine processing
        modules.  Additionally, when we uniformly represent structures as
        sequences, we have localized the data-structure dependencies in our
        programs to a small number of sequence operations.  By changing these, 
        we can experiment with alternative representations of sequences, while
        leaving the overall design of our programs intact.  We will exploit
        this capability in Section<SPACE/><REF NAME="sec:streams"/>, when we generalize the
        sequence-processing paradigm to admit infinite sequences.
      </TEXT>

      <EXERCISE>
        Fill in the missing expressions to complete the following definitions
        of some basic list-manipulation operations as accumulations:
        <SNIPPET EVAL="no">
          <REQUIRES>accumulate</REQUIRES>
          <SCHEME>
            <!-- \indcode{map}[as accumulation] -->
(define (map p sequence)
  (accumulate (lambda (x y) ^??^) nil sequence))

            <!-- \indcode{append}[accumulation@as accumulation] -->
(define (append seq1 seq2)
  (accumulate cons ^??^ ^??^))

            <!-- \indcode{length}[as accumulation] -->
(define (length sequence)
  (accumulate ^??^ 0 sequence))
          </SCHEME>
          <JAVASCRIPT>
function map(p, sequence) {
    return accumulate((x, y) => ?? , 
                      [], sequence);
}

function append(seq1, seq2) {
    return accumulate(pair, ??, ??);
}

function length(sequence) {
    return accumulate(??, 0, sequence);
}
        </JAVASCRIPT>
        </SNIPPET>
	<SOLUTION>
    <SNIPPET >
	  <REQUIRES>accumulate</REQUIRES>
    <JAVASCRIPT>
function map(p, sequence) {
    return accumulate((x, y) => pair(p(x), y),
                      [], 
                      sequence);
}
function append(seq1, seq2) {
    return accumulate(pair, seq2, seq1);
}
function length(sequence) {
    return accumulate((x, y) => y + 1,
                      0, 
                      sequence);
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET></SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:horner"/>
        <INDEX>polynomial(s)<SUBINDEX>evaluating with Horner<APOS/>s rule</SUBINDEX></INDEX>
        Evaluating a polynomial in <LATEXINLINE>$x$</LATEXINLINE> at a given value of <LATEXINLINE>$x$</LATEXINLINE> can be
        formulated as an accumulation.  We evaluate the polynomial
        <LATEX>
          \[ a_{n} x^n +a_{n-1}x^{n-1}+\cdots + a_{1} x+a_{0} \]
        </LATEX>
        using a well-known algorithm called 
        <INDEX>Horner<APOS/>s rule</INDEX>
        <EM>Horner<APOS/>s rule</EM>, which
        structures the computation as
        <LATEX>
          \[ \left(\cdots (a_{n}  x+a_{n-1})x+\cdots +a_{1}\right) x+a_{0} \]
        </LATEX>
        In other words, we start with <LATEXINLINE>$a_{n}$</LATEXINLINE>, multiply by <LATEXINLINE>$x$</LATEXINLINE>, add <LATEXINLINE>$a_{n-1}$</LATEXINLINE>, 
        multiply by <LATEXINLINE>$x$</LATEXINLINE>, and so on, until we reach <LATEXINLINE>$a_{0}$</LATEXINLINE>.<FOOTNOTE>According to 
          <INDEX>Knuth, Donald E.</INDEX>
          Knuth (1981), this rule was formulated by
          <INDEX>Horner@Horner, W. G.</INDEX>
          W. G. Horner early in the nineteenth century, but the method was
          actually used by Newton over a hundred years earlier.  Horner<APOS/>s rule
          evaluates the polynomial using fewer additions and multiplications
          than does the straightforward method of first computing <LATEXINLINE>$a_{n} x^n$</LATEXINLINE>, 
          then adding <LATEXINLINE>$a_{n-1}x^{n-1}$</LATEXINLINE>, and so on.  In fact, it is possible to
          prove that any algorithm for evaluating arbitrary polynomials must use
          at least as many additions and multiplications as does Horner<APOS/>s rule, 
          and thus Horner<APOS/>s rule is an 
          <INDEX>algorithm<SUBINDEX>optimal</SUBINDEX></INDEX>
          <INDEX>optimality<SUBINDEX>of Horner<APOS/>s rule</SUBINDEX></INDEX>
          optimal algorithm for polynomial
          evaluation.  This was proved (for the number of additions) by
          <INDEX>Ostrowski, A. M.</INDEX>
          A. M. Ostrowski in a 1954 paper that essentially founded the modern
          study of optimal algorithms.  The analogous statement for
          multiplications was proved by 
          <INDEX>Pan, V. Y.</INDEX>
          V. Y. Pan in 1966.  The book by 
          <INDEX>Borodin, Alan</INDEX>
          <INDEX>Munro, Ian</INDEX>
          <CITATION><TEXT>Borodin and Munro (1975)</TEXT>Borodin and Munro 1975</CITATION> 
          provides an overview of these and other results about
          optimal algorithms.</FOOTNOTE>

        Fill in the following template to produce a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        that evaluates a
        polynomial using Horner<APOS/>s rule.
        Assume that the coefficients of the
        polynomial are arranged in a sequence, from <LATEXINLINE>$a_{0}$</LATEXINLINE> through <LATEXINLINE>$a_{n}$</LATEXINLINE>.
        <SNIPPET EVAL="no">
          <NAME>horner_eval</NAME>
          <REQUIRES>accumulate</REQUIRES>
          <SCHEME>
(define (horner-eval x coefficient-sequence)
   (accumulate (lambda (this-coeff higher-terms) ^??^)
               0
               coefficient-sequence))
          </SCHEME>
          <JAVASCRIPT>
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) => ??,
                      0, 
                      coefficient_sequence);
}
        </JAVASCRIPT>
        </SNIPPET>

        For example, to compute <LATEXINLINE>$1+3x+5x^3+x^5$</LATEXINLINE> at <LATEXINLINE>$x=2$</LATEXINLINE> you would evaluate
        <SNIPPET>
          <REQUIRES>horner_eval</REQUIRES>
          <SCHEME>
(horner-eval 2 (list 1 3 0 5 0 1))
          </SCHEME>
          <JAVASCRIPT>
horner_eval(2, list(1, 3, 0, 5, 0, 1));
          </JAVASCRIPT>
        </SNIPPET>
	<SOLUTION>
    <SNIPPET>
	  <REQUIRES>accumulate</REQUIRES>
    <JAVASCRIPT>
function horner_eval(x, coefficient_sequence) {
    return accumulate((this_coeff, higher_terms) 
                      => x * higher_terms + this_coeff,
                      0, 
                      coefficient_sequence);
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET></SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:countleaves-as-accumulation"/>
        Redefine <SPLITINLINE><SCHEME><SCHEMEINLINE>count-leaves</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>count_leaves</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> from Section<SPACE/><REF NAME="sec:trees"/> as an
        accumulation:
        <SNIPPET EVAL="no">
          <REQUIRES>accumulate</REQUIRES>
          <SCHEME>
            <!-- \indcode{count-leaves}[as accumulation] -->
(define (count-leaves t)
   (accumulate ^??^ ^??^ (map ^??^ ^??^)))
          </SCHEME>
          <JAVASCRIPT>
function count_leaves(t) {
    return accumulate(??, ??, map(??, ??));
}
          </JAVASCRIPT>
        </SNIPPET>
	<SOLUTION>
    <SNIPPET>
	  <REQUIRES>accumulate</REQUIRES>
	  <JAVASCRIPT>
function count_leaves(t) {
    return accumulate((leaves, total) => leaves + total,
                      0, 
		      map(sub_tree
		          => is_pair(sub_tree)
		             ? count_leaves(sub_tree)
                             : 1,
			  t));
}
	  </JAVASCRIPT>
	  <SCHEME>
	  </SCHEME>
	</SNIPPET></SOLUTION>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:accumulate-n"/>
        The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>accumulate-n</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate_n</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is similar to <SPLITINLINE><SCHEME><SCHEMEINLINE>accumulate</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> except
        that it takes as its third argument a sequence of sequences, which are all
        assumed to have the same number of elements.  It applies the
        designated accumulation
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to combine all the first elements of
        the sequences, all the second elements of the sequences, and so on, and
        returns a sequence of the results.  For instance, if <SCHEMEINLINE>s</SCHEMEINLINE> is a sequence
         containing four sequences, <SPLITINLINE><SCHEME><SCHEMEINLINE>((1 2 3) (4 5 6) (7 8 9) (10 11 12)), </SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>[[1, [2, [3, []]]], [[4, [5, [6, []]]], [[7, [8, [9, []]]], [[10, [11, [12, []]]], []]]]]</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        then the value of <SPLITINLINE><SCHEME><SCHEMEINLINE>(accumulate-n + 0 s)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate_n(plus, 0, s)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> should be the sequence <SPLITINLINE><SCHEME><SCHEMEINLINE>(22 26 30)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>[22, [26, [30, []]]]</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  Fill in the missing expressions
        in the following definition of <SPLITINLINE><SCHEME><SCHEMEINLINE>accumulate-n</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate_n</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>:
        <SNIPPET EVAL="no">
          <SCHEME>
            <!-- \indcode{accumulate-n} -->
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
     nil
     (cons (accumulate op init ^??^)
           (accumulate-n op init ^??^))))
          </SCHEME>
          <JAVASCRIPT>
function accumulate_n(op, init, seqs) {
    return is_empty_list(head(seqs))
           ? []
           : pair(accumulate(op, init, ??), 
                  accumulate_n(op, init, ??));
}
        </JAVASCRIPT>
        </SNIPPET>
	<SOLUTION>
    <SNIPPET>
	  <NAME>accumulate_n</NAME>
	  <REQUIRES>accumulate</REQUIRES>
	  <EXAMPLE>example_2.37</EXAMPLE>
	  <JAVASCRIPT>
function add(a, b) {
    return a + b;
}
function accumulate_n(op, init, seqs) {
    return is_empty_list(head(seqs))
           ? []
           : pair(accumulate(op, init, map(x => head(x), seqs)),
                  accumulate_n(op, init, map(x => tail(x), seqs)));
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET></SOLUTION>
    <SNIPPET HIDE="yes">
    <NAME>example_2.37</NAME>
    <JAVASCRIPT>
const v = list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9), list(10, 11, 12))
accumulate_n(add, 0, v)
    </JAVASCRIPT>
    </SNIPPET>
    </EXERCISE>

      <EXERCISE><LABEL NAME="ex:matrix-ops"/>
        <INDEX>matrix, represented as sequence</INDEX>
        <INDEX>vector (mathematical)<SUBINDEX>represented as sequence</SUBINDEX></INDEX>
        <INDEX>vector (mathematical)<SUBINDEX>operations on</SUBINDEX></INDEX>
        Suppose we represent vectors <LATEXINLINE>$v=(v_{i})$</LATEXINLINE> as sequences of numbers, and
        matrices <LATEXINLINE>$m=(m_{ij})$</LATEXINLINE> as sequences of vectors (the rows of the matrix).
        For example, the matrix
        <LATEX>
          \[ \left[ 
          \begin{array}{llll}
          1 &amp; 2 &amp; 3 &amp; 4\\
          4 &amp; 5 &amp; 6 &amp; 6\\
          6 &amp; 7 &amp; 8 &amp; 9\\
          \end{array}
          \right] \]
        </LATEX>
        is represented as the sequence <SPLITINLINE><SCHEME><SCHEMEINLINE>((1 2 3 4) (4 5 6 6) (6 7 8 9))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>[[1, [2, [3, [4, []]]]], [[4, [5, [6, [6, []]]]], [[6, [7, [8, [9, []]]]], []]]]</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.
        With this representation, we can use sequence operations to concisely
        express the basic matrix and vector operations.  These operations
        (which are described in any book on matrix algebra) are the following:


        <UL>
          <LI>
          <SPLITINLINE><SCHEME><SCHEMEINLINE>(dot-product </SCHEMEINLINE><LATEXINLINE>$v$\ $w$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>dot_product(</JAVASCRIPTINLINE><LATEXINLINE>$v$</LATEXINLINE><JAVASCRIPTINLINE>, </JAVASCRIPTINLINE><LATEXINLINE>$w$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns the sum <LATEXINLINE>$\sum_{i}v_{i}
            w_{i}$</LATEXINLINE>.
          </LI>
          <LI>
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(matrix-*-vector </SCHEMEINLINE><LATEXINLINE>$m$</LATEXINLINE> <LATEXINLINE>$v$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>matrix_times_vector(</JAVASCRIPTINLINE><LATEXINLINE>$m$</LATEXINLINE><JAVASCRIPTINLINE>, </JAVASCRIPTINLINE><LATEXINLINE>$v$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns the vector <LATEXINLINE>$t$</LATEXINLINE>, where <LATEXINLINE>$t_{i} =\sum_{j}m_{ij}v_{j}$</LATEXINLINE>.
          </LI>
          <LI>
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(matrix-*-matrix </SCHEMEINLINE><LATEXINLINE>$m\ n$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>matrix_times_matrix(</JAVASCRIPTINLINE><LATEXINLINE>$m$</LATEXINLINE><JAVASCRIPTINLINE>, </JAVASCRIPTINLINE><LATEXINLINE>$n$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns the matrix <LATEXINLINE>$p$</LATEXINLINE>, where <LATEXINLINE>$p_{ij}=\sum_{k} m_{ik}n_{kj}$</LATEXINLINE>.
          </LI>
          <LI>
            <SPLITINLINE><SCHEME><SCHEMEINLINE>(transpose <LATEXINLINE>$m$</LATEXINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>transpose(</JAVASCRIPTINLINE><LATEXINLINE>$m$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns the matrix <LATEXINLINE>$n$</LATEXINLINE>, where <LATEXINLINE>$n_{ij}=m_{ji}$</LATEXINLINE>.
          </LI>
        </UL>
        We can define the dot product as<FOOTNOTE>This definition uses the
          extended version of <SPLITINLINE><SCHEME><SCHEMEINLINE>map</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>map</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> described in footnote<SPACE/><REF NAME="foot:generalmap"/>.</FOOTNOTE>
        <SNIPPET EVAL="no">
          <EXAMPLE>dot_product_example</EXAMPLE>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>simple_plus</REQUIRES>
          <REQUIRES>simple_times</REQUIRES>
          <SCHEME>
            <!-- \indcode*{dot-product} -->
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
          </SCHEME>
          <JAVASCRIPT>
function dot_product(v, w) {
    return accumulate(plus, 0, map(times, v, w));
}
        </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>dot_product_example</NAME>
          <SCHEME>
(dot-product (list 1 2) (list 3 4))
          </SCHEME>
          <JAVASCRIPT>
dot_product(list(1, 2), list(3, 4))
          </JAVASCRIPT>
        </SNIPPET>

        Fill in the missing expressions in the following
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        for
        computing the other matrix operations.  (The
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>accumulate-n</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate_n</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is
        defined in Exercise<SPACE/><REF NAME="ex:accumulate-n"/>.)
        <SNIPPET EVAL="no">
          <SCHEME>
            <!-- \indcode{matrix-*-vector} -->
(define (matrix-*-vector m v)
  (map ^??^ m))

            <!--\indcodeplus{transpose}{a matrix}-->
(define (transpose mat)
  (accumulate-n ^??^ ^??^ mat))

            <!-- \indcode{matrix-*-matrix} -->
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ^??^ m)))
          </SCHEME>
          <JAVASCRIPT>
function matrix_times_vector(m, v) {
    return map(??, m);
}

function transpose(mat) {
    return accumulate_n(??, ??, mat);
}

function matrix_times_matrix(n, m) {
    const cols = transpose(n);
    return map(??, m);
}
          </JAVASCRIPT>
        </SNIPPET>
  <SOLUTION>
    <SNIPPET>
      <REQUIRES>accumulate</REQUIRES>
      <REQUIRES>accumulate_n</REQUIRES>
    <EXAMPLE>example_2.38</EXAMPLE>
    <JAVASCRIPT>
function plus(x, y) {
    return x + y;
}
function times(x, y) {
    return x * y;
}
function dot_product(v, w) {
    return accumulate(plus, 0, map(times, v, w));
}
function matrix_times_vector(m, v) {
    return map(row => dot_product(row, v), m);
}
function transpose(mat) {
    return accumulate_n(pair, [], mat);
}
function matrix_times_matrix(n, m) {
    const cols = transpose(m);
    return map(x => map(y => dot_product(x, y), cols), n);
}
   </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET></SOLUTION>
    <SNIPPET HIDE="yes">
    <NAME>example_2.38</NAME>
    <JAVASCRIPT>
const m1 = list(list(1, 2, 3), list(3, 5, 1), list(1, 1, 1));
const m2 = list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9));
matrix_times_matrix(m1, m2);
     </JAVASCRIPT>
     <SCHEME>
     </SCHEME>
     </SNIPPET>
      </EXERCISE>

      <EXERCISE><LABEL NAME="ex:fold-right-left"/>
        <!-- \indcode{accumulate}[same as fold-right@same as <SCHEMEINLINE>fold-right</SCHEMEINLINE>] -->
        <!-- \indcode{fold-right} -->
        The <SPLITINLINE><SCHEME><SCHEMEINLINE>accumulate</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>accumulate</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        is also known as <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_right</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, 
        because it combines the first element of the sequence with the result
        of combining all the elements to the right.  There is also a <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_left</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which is 
        similar to <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_right</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, except
        that it combines elements working in the opposite direction:
        <SNIPPET>
          <NAME>fold_left</NAME>
          <EXAMPLE>fold_left_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{fold-left} -->
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
      result
      (iter (op result (car rest))
            (cdr rest))))
  (iter initial sequence))
          </SCHEME>
          <JAVASCRIPT>
function fold_left(op, initial, sequence) {
    function iter(result, rest) {
        return is_empty_list(rest)
               ? result
               : iter(op(result, head(rest)), 
                      tail(rest));
    }
    return iter(initial, sequence);
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>fold_right</NAME>
          <EXAMPLE>fold_right_example</EXAMPLE>
          <SCHEME>
;; same as accumulate
(define (fold-right op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (fold-right op initial (cdr sequence)))))
          </SCHEME>
          <JAVASCRIPT>
// same as accumulate
function fold_right(op, initial, sequence) {
    return is_empty_list(sequence)
           ? initial
           : op(head(sequence), 
                fold_right(op, initial, tail(sequence)));
}
          </JAVASCRIPT>
        </SNIPPET>

        What are the values of
        <SNIPPET HIDE="yes">
          <NAME>simple_divide</NAME>
          <SCHEME>
;; in Scheme, the operator symbol * is procedure name
          </SCHEME>
          <JAVASCRIPT>
function divide(x, y) {
    return x / y;
}
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET>
          <REQUIRES>fold_right</REQUIRES>
          <REQUIRES>simple_divide</REQUIRES>
          <SCHEME>
(fold-right / 1 (list 1 2 3))
          </SCHEME>
          <JAVASCRIPT>
fold_right(divide, 1, list(1, 2, 3));
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET>
          <REQUIRES>fold_left</REQUIRES>
          <REQUIRES>simple_divide</REQUIRES>
          <SCHEME>
(fold-left / 1 (list 1 2 3))
          </SCHEME>
          <JAVASCRIPT>
fold_left(divide, 1, list(1, 2, 3));
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET>
          <NAME>fold_right_example</NAME>
          <REQUIRES>fold_right</REQUIRES>
          <SCHEME>
(fold-right list nil (list 1 2 3))
          </SCHEME>
          <JAVASCRIPT>
fold_right(list, [], list(1, 2, 3));
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET>
          <NAME>fold_left_example</NAME>
          <REQUIRES>fold_left</REQUIRES>
          <SCHEME>
(fold-left list nil (list 1 2 3))
          </SCHEME>
          <JAVASCRIPT>
fold_left(list, [], list(1, 2, 3));
          </JAVASCRIPT>
        </SNIPPET>

        Give a property that <SPLITINLINE><SCHEME><SCHEMEINLINE>op</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>op</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> should satisfy to guarantee that <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_right</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_left</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> will produce the same values for any
        sequence.
        
   <SOLUTION>
   <TEXT>
   
To guarantee the fold_right and fold_left will produce the same values for any sequence, op must be commutative.
 </TEXT> 

 <SNIPPET >
  <REQUIRES>simple_plus</REQUIRES>
  <REQUIRES>fold_right</REQUIRES>
    <JAVASCRIPT>
fold_right(plus, 0, list(1, 2, 3));
</JAVASCRIPT>
    </SNIPPET>
<SNIPPET >
  <REQUIRES>simple_plus</REQUIRES>
  <REQUIRES>fold_left</REQUIRES>
    <JAVASCRIPT>

fold_left(plus, 0, list(1, 2, 3));
    </JAVASCRIPT>
    </SNIPPET>
 
</SOLUTION>
      </EXERCISE>

      <EXERCISE>
        Complete the following definitions of <SPLITINLINE><SCHEME><SCHEMEINLINE>reverse</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>reverse</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <!-- \indcode{reverse}[as folding] -->
        (Exercise<SPACE/><REF NAME="ex:reverse"/>) in terms of <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-right</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_right</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>fold-left</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>fold_left</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> from Exercise<SPACE/><REF NAME="ex:fold-right-left"/>:
        <SNIPPET EVAL="no">
          <SCHEME>
(define (reverse sequence)
  (fold-right (lambda (x y) ^??^) nil sequence))

(define (reverse sequence)
  (fold-left (lambda (x y) ^??^) nil sequence))
          </SCHEME>
          <JAVASCRIPT>
function reverse(sequence) {
    return fold_right((x, y) => ??, [], sequence);
}

function reverse(sequence) {
    return fold_left((x, y) => ??, [], sequence);
}
        </JAVASCRIPT>
        </SNIPPET>
<SOLUTION>
  <SNIPPET>
    <REQUIRES>fold_right</REQUIRES>
    <REQUIRES>append</REQUIRES>
    <EXAMPLE>reverse_example</EXAMPLE>
<JAVASCRIPT>
function reverse(sequence) {
    return fold_right((x, y) => append(y, list(x)), [], sequence);
}
</JAVASCRIPT>
</SNIPPET>

<SNIPPET>
  <REQUIRES>fold_left</REQUIRES>
  <EXAMPLE>reverse_example</EXAMPLE>
<JAVASCRIPT>
function reverse(sequence) {
    return fold_left((x, y) => pair(y, x), [], sequence);
}
</JAVASCRIPT>
</SNIPPET>
</SOLUTION>
      </EXERCISE>
      <INDEX>sequence(s)<SUBINDEX>operations on|)</SUBINDEX></INDEX>

      <SUBHEADING>
        <NAME>Nested Mappings</NAME>
      </SUBHEADING>

      <LABEL NAME="sec:nested-mappings"/>
      <INDEX>mapping<SUBINDEX>nested|(</SUBINDEX></INDEX>

      <TEXT>
        We can extend the sequence paradigm to include many
        computations that are commonly expressed using nested 
        loops.<FOOTNOTE>This approach to nested mappings was shown
          to us by 
          <INDEX>Turner, David</INDEX>
          David Turner, whose languages 
          <INDEX>KRC</INDEX>
          KRC and 
          <INDEX>Miranda</INDEX>
          Miranda provide elegant
          formalisms for dealing with these constructs.  The examples in this
          section (see also Exercise<SPACE/><REF NAME="ex:8queens"/>) are adapted from Turner
          1981.  In Section<SPACE/><REF NAME="sec:exploiting-streams"/>, we<APOS/>ll see how this
          approach generalizes to infinite sequences.</FOOTNOTE>
      </TEXT>

      <TEXT>
        Consider
        this problem: Given a positive integer <LATEXINLINE>$n$</LATEXINLINE>, find all ordered pairs of
        distinct positive integers <LATEXINLINE>$i$</LATEXINLINE> and <LATEXINLINE>$j$</LATEXINLINE>, where <LATEXINLINE>$1\leq j&lt; i\leq n$</LATEXINLINE>, such
        that <LATEXINLINE>$i +j$</LATEXINLINE> is prime.  For example, if <LATEXINLINE>$n$</LATEXINLINE> is 6, then the pairs are
        the following:
        <LATEX>
          \[
          \begin{array}{c|ccccccc}
          i     &amp; 2 &amp; 3 &amp; 4 &amp; 4 &amp; 5 &amp; 6 &amp; 6 \\
          j     &amp; 1 &amp; 2 &amp; 1 &amp; 3 &amp; 2 &amp; 1 &amp; 5 \\
          \hline
          i+j   &amp; 3 &amp; 5 &amp; 5 &amp; 7 &amp; 7 &amp; 7 &amp; 11
          \end{array}
          \]
        </LATEX>
      </TEXT>

      <TEXT>
        A natural way to organize this computation is to generate the sequence
        of all ordered pairs of positive integers less than or equal to <LATEXINLINE>$n$</LATEXINLINE>, 
        filter to select those pairs whose sum is prime, and
        then, for each pair <LATEXINLINE>$(i, j)$</LATEXINLINE> that passes through the filter, produce the triple
        <LATEXINLINE>$(i, j, i+j)$</LATEXINLINE>.
      </TEXT>

      <TEXT>
        Here is a way to generate the sequence of pairs: For each integer
        <LATEXINLINE>$i\leq n$</LATEXINLINE>, enumerate the integers <LATEXINLINE>$j&lt;i$</LATEXINLINE>, and for each such <LATEXINLINE>$i$</LATEXINLINE> and <LATEXINLINE>$j$</LATEXINLINE>
        generate the pair <LATEXINLINE>$(i, j)$</LATEXINLINE>.  In terms of sequence operations, we map
        along the sequence <SPLITINLINE><SCHEME><SCHEMEINLINE>(enumerate-interval 1 n)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>enumerate_interval(1, n)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  For each <LATEXINLINE>$i$</LATEXINLINE> in
        this sequence, we map along the sequence <SPLITINLINE><SCHEME><SCHEMEINLINE>(enumerate-interval 1 (- i 1))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>enumerate_interval(1, i-1)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  For each <LATEXINLINE>$j$</LATEXINLINE> in this latter sequence, we generate the pair
        <SPLITINLINE><SCHEME><SCHEMEINLINE>(list i j)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list(i, j)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  This gives us a sequence of pairs for each <LATEXINLINE>$i$</LATEXINLINE>.
        Combining all the sequences for all the <LATEXINLINE>$i$</LATEXINLINE> (by accumulating with <SPLITINLINE><SCHEME><SCHEMEINLINE>append</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>append</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>) produces the required sequence of pairs:<FOOTNOTE>We<APOS/>re
          representing a pair here as a list of two elements rather than as
          <SPLITINLINE><SCHEME>a Lisp pair</SCHEME><JAVASCRIPT>an ordinary pair</JAVASCRIPT></SPLITINLINE>.  Thus, the <QUOTE>pair</QUOTE> <LATEXINLINE>$(i, j)$</LATEXINLINE> is represented as <SPLITINLINE><SCHEME><SCHEMEINLINE>(list i j)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list(i, j)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, not <SPLITINLINE><SCHEME><SCHEMEINLINE>(cons i j)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair(i, j)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.</FOOTNOTE>

        <SNIPPET HIDE="yes">
          <NAME>enumerate_interval_comment</NAME>
          <SCHEME>
;; replace n below by the desired number
          </SCHEME>
          <JAVASCRIPT>
// replace n below by the desired number
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>append</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>enumerate_interval</REQUIRES>
          <REQUIRES>enumerate_interval_comment</REQUIRES>
          <SCHEME>
(accumulate append
  nil
  (map (lambda (i)
         (map (lambda (j) (list i j))
              (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))
          </SCHEME>
          <JAVASCRIPT>
accumulate(append, 
           [], 
           map(i => map(j => list(i, j),
                        enumerate_interval(1, i-1)),
               enumerate_interval(1, n)));
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        The combination of mapping and accumulating with <SPLITINLINE><SCHEME><SCHEMEINLINE>append</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>append</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is so common in this
        sort of program that we will isolate it as a separate
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:
        <SNIPPET>
          <NAME>flatmap</NAME>
          <REQUIRES>accumulate</REQUIRES>
          <REQUIRES>append</REQUIRES>
          <REQUIRES>map</REQUIRES>
          <EXAMPLE>flatmap_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{flatmap} -->
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
          </SCHEME>
          <JAVASCRIPT>
function flatmap(proc, seq) {
    return accumulate(append, [], map(proc, seq));
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>flatmap_example</NAME>
          <SCHEME>
            <!-- \indcode*{flatmap} -->
(flatmap (lambda (x) (+ x 1)) (list (list 1 2) (list 3 4)))
          </SCHEME>
          <JAVASCRIPT>
flatmap(x => x + 1, list(list(1, 2), list(3, 4)));
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Now filter this sequence of pairs to find those whose sum is prime. The
        filter predicate is called for each element of the sequence; its
        argument is a pair and it must extract the integers from the pair.
        Thus, the predicate to apply to each element in the sequence is
        <SNIPPET>
          <NAME>prime_sum</NAME>
          <REQUIRES>prime_definition</REQUIRES>
          <EXAMPLE>prime_sum_example</EXAMPLE>
          <SCHEME>
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
          </SCHEME>
          <JAVASCRIPT>
function is_prime_sum(pair) {
    return is_prime(head(pair) + head(tail(pair)));
}
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>prime_sum_example</NAME>
          <SCHEME>
(prime-sum? (list 8 9))
          </SCHEME>
          <JAVASCRIPT>
is_prime_sum(list(8, 9));
          </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Finally, generate the sequence of results by mapping over the filtered
        pairs using the following
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, which constructs a triple
        consisting of the two elements of the pair along with their sum:
        <SNIPPET>
          <NAME>make_pair_sum</NAME>
          <EXAMPLE>make_pair_sum_example</EXAMPLE>
          <SCHEME>
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
          </SCHEME>
          <JAVASCRIPT>
function make_pair_sum(pair) {
    return list(head(pair), head(tail(pair)), 
                head(pair) + head(tail(pair)));
}
        </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>make_pair_sum_example</NAME>
          <SCHEME>
(make-pair-sum (list 8 9))
          </SCHEME>
          <JAVASCRIPT>
make_pair_sum(list(8, 9));
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <TEXT>
        Combining all these steps yields the complete
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:
        <SNIPPET>
          <REQUIRES>map</REQUIRES>
          <REQUIRES>make_pair_sum</REQUIRES>
          <REQUIRES>filter</REQUIRES>
          <REQUIRES>prime_sum</REQUIRES>
          <REQUIRES>flatmap</REQUIRES>
          <REQUIRES>enumerate_interval</REQUIRES>
          <EXAMPLE>prime_sum_pairs_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{prime-sum-pairs} -->
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                 (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))))
          </SCHEME>
          <JAVASCRIPT>
function prime_sum_pairs(n) {
    return map(make_pair_sum, 
               filter(is_prime_sum, 
                      flatmap(i => map(j => list(i, j), 
                                       enumerate_interval(1, i - 1)),
                              enumerate_interval(1, n))));
}
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>prime_sum_pairs_example</NAME>
          <SCHEME>
            <!-- \indcode*{prime-sum-pairs} -->
(prime-sum-pairs 15)
          </SCHEME>
          <JAVASCRIPT>
prime_sum_pairs(15);
          </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <TEXT>
        Nested mappings are also useful for sequences other than those that
        enumerate intervals.  Suppose we wish to generate all the 
        <INDEX>set<SUBINDEX>permutations of</SUBINDEX></INDEX>
        <INDEX>permutations of a set</INDEX>
        permutations
        of a set <LATEXINLINE>$S$</LATEXINLINE>; that is, all the ways of ordering the items in
        the set.  For instance, the permutations of <LATEXINLINE>$\{1, 2, 3\}$</LATEXINLINE> are
        <LATEXINLINE>$\{1, 2, 3\}$</LATEXINLINE>, <LATEXINLINE>$\{ 1, 3, 2\}$</LATEXINLINE>, <LATEXINLINE>$\{2, 1, 3\}$</LATEXINLINE>, <LATEXINLINE>$\{ 2, 3, 1\}$</LATEXINLINE>, <LATEXINLINE>$\{ 3, 1, 2\}$</LATEXINLINE>, and
        <LATEXINLINE>$\{ 3, 2, 1\}$</LATEXINLINE>.  Here is a plan for generating the permutations of<SPACE/><LATEXINLINE>$S$</LATEXINLINE>:
        For each item <LATEXINLINE>$x$</LATEXINLINE> in <LATEXINLINE>$S$</LATEXINLINE>, recursively generate the sequence of
        permutations of <LATEXINLINE>$S-x$</LATEXINLINE>, <FOOTNOTE>The set <LATEXINLINE>$S-x$</LATEXINLINE> is the set of all elements
          of <LATEXINLINE>$S$</LATEXINLINE>, excluding <LATEXINLINE>$x$</LATEXINLINE>.</FOOTNOTE> and adjoin
        <LATEXINLINE>$x$</LATEXINLINE> to the front of each one.  This yields, for each <LATEXINLINE>$x$</LATEXINLINE> in <LATEXINLINE>$S$</LATEXINLINE>, the sequence
        of permutations of <LATEXINLINE>$S$</LATEXINLINE> that begin with<SPACE/><LATEXINLINE>$x$</LATEXINLINE>.  Combining these
        sequences for all <LATEXINLINE>$x$</LATEXINLINE> gives all the permutations of<SPACE/><LATEXINLINE>$S$</LATEXINLINE>:<FOOTNOTE>
          <INDEX>semicolon<SUBINDEX>comment introduced by</SUBINDEX></INDEX>
          <INDEX>comments in programs</INDEX>
          <INDEX>program<SUBINDEX>comments in</SUBINDEX></INDEX>
          <SPLITINLINE><SCHEME>Semicolons in Scheme code are</SCHEME><JAVASCRIPT>The character sequence <JAVASCRIPTINLINE>//</JAVASCRIPTINLINE> in JavaScript code is</JAVASCRIPT></SPLITINLINE> used to
          introduce <EM>comments</EM>.  Everything from <SPLITINLINE><SCHEME>the semicolon</SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>//</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to the end of
          the line is ignored by the interpreter.  In this book we don<APOS/>t use
          many comments; we try to make our programs self-documenting by using
          descriptive names.</FOOTNOTE>

        <SNIPPET>
          <REQUIRES>flatmap</REQUIRES>
          <REQUIRES>remove</REQUIRES>
          <EXAMPLE>permutations_example</EXAMPLE>
          <SCHEME>
            <!--\ind*{permutations of a set}[permutations@<SCHEMEINLINE>permutations</SCHEMEINLINE>]-->
(define (permutations s)
  (if (null? s)             ; empty set?
    (list nil)              ; sequence containing empty set
    (flatmap (lambda (x)
               (map (lambda (p) (cons x p))
                    (permutations (remove x s))))
             s)))
          </SCHEME>
          <JAVASCRIPT>
function permutations(s) {
    return is_empty_list(s)
           ? list([])
           : flatmap(x => map(p => pair(x, p),
                              permutations(remove(x, s))),
                     s);
}
        </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET HIDE="yes">
          <NAME>permutations_example</NAME>
          <SCHEME>
(permutations (list 1 2 3))
          </SCHEME>
          <JAVASCRIPT>
permutations(list(1, 2, 3));
        </JAVASCRIPT>
        </SNIPPET>

      </TEXT>

      <TEXT>
        Notice how this strategy reduces the problem of generating
        permutations of <LATEXINLINE>$S$</LATEXINLINE> to the problem of generating the permutations of
        sets with fewer elements than <LATEXINLINE>$S$</LATEXINLINE>.  In the terminal case, we work our
        way down to the empty list, which represents a set of no elements.
        For this, we generate <SPLITINLINE><SCHEME><SCHEMEINLINE>(list nil)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list([])</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which is a sequence with one
        item, namely the set with no elements.  The <SPLITINLINE><SCHEME><SCHEMEINLINE>remove</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>remove</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        used in <SPLITINLINE><SCHEME><SCHEMEINLINE>permutations</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>permutations</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> returns all the items in a given sequence
        except for a given item.  This can be expressed as a simple filter:
        <SNIPPET>
          <NAME>remove</NAME>
          <REQUIRES>filter</REQUIRES>
          <EXAMPLE>remove_example</EXAMPLE>
          <SCHEME>
            <!-- \indcode*{remove} -->
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
          </SCHEME>
          <JAVASCRIPT>
function remove(item, sequence) {
    return filter(x => !(x === item),
                  sequence);
}
        </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>remove_example</NAME>
          <SCHEME>
(remove 3 (list 1 2 3 4 5))
          </SCHEME>
          <JAVASCRIPT>
remove(3, list(1, 2, 3, 4, 5));
        </JAVASCRIPT>
        </SNIPPET>
      </TEXT>

      <EXERCISE>
        Define a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!-- \indcode{unique-pairs} -->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>unique-pairs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>unique_pairs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> that, given an integer <LATEXINLINE>$n$</LATEXINLINE>, 
        generates the sequence of pairs <LATEXINLINE>$(i, j)$</LATEXINLINE> with <LATEXINLINE>$1\leq j&lt; i\leq n$</LATEXINLINE>.  Use <SPLITINLINE><SCHEME><SCHEMEINLINE>unique-pairs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>unique_pairs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to simplify the definition of <SPLITINLINE><SCHEME><SCHEMEINLINE>prime-sum-pairs</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>prime_sum_pairs</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        given above.
   <SOLUTION>
    <SNIPPET>
      <REQUIRES>append</REQUIRES>
      <REQUIRES>filter</REQUIRES>
      <REQUIRES>accumulate</REQUIRES>
      <REQUIRES>enumerate_interval</REQUIRES>
      <REQUIRES>flatmap</REQUIRES>
      <REQUIRES>square_definition</REQUIRES>
      <REQUIRES>prime_definition</REQUIRES>
    <EXAMPLE>example_2.41</EXAMPLE>
    <JAVASCRIPT>
function is_prime_sum(pair) {
    return is_prime(head(pair) + head(tail(pair)));
}
function prime_sum_pairs(n) {
    return map(make_pair_sum, 
               filter(is_prime_sum, 
                      flatmap(i => map(j => list(i, j), 
                                       enumerate_interval(1, i-1)), 
                              enumerate_interval(1, n))));
}
function unique_pairs(n) {
    return flatmap(i => map(j => list(i, j), 
                            enumerate_interval(1, i-1)), 
                   enumerate_interval(1, n));
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET></SOLUTION>
    <SNIPPET HIDE="yes">
    <NAME>example_2.41</NAME>
    <JAVASCRIPT>
    unique_pairs(3)
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
      </EXERCISE>

      <EXERCISE>
        Write a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        to find all ordered
        triples of distinct positive integers <LATEXINLINE>$i$</LATEXINLINE>, <LATEXINLINE>$j$</LATEXINLINE>, and<SPACE/><LATEXINLINE>$k$</LATEXINLINE> less than or
        equal to a given integer <LATEXINLINE>$n$</LATEXINLINE> that sum to a given integer <LATEXINLINE>$s$</LATEXINLINE>.
    <SOLUTION>
      <SNIPPET >
    <EXAMPLE>example_2.42</EXAMPLE>
    <REQUIRES>filter</REQUIRES>
    <REQUIRES>accumulate</REQUIRES>
    <REQUIRES>append</REQUIRES>
    <REQUIRES>enumerate_interval</REQUIRES>
    <REQUIRES>flatmap</REQUIRES>
    <JAVASCRIPT>
function triples_that_sum_to(s, n) {
    return filter(list 
                  => (accumulate(add, 0, list) === s)
                     ? 1
  		               : 0,
                  unique_triples(n));
}
function add(x, y) {
    return x + y;
}
function unique_triples(n) {
    return flatmap(i => flatmap(j => map(k => list(i, j, k),
                                         enumerate_interval(1, j-1)),
                                enumerate_interval(1, i-1)),
                   enumerate_interval(1, n));
}
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
    <SNIPPET HIDE="yes">
    <NAME>example_2.42</NAME>
    <JAVASCRIPT>
triples_that_sum_to(10, 6);
    </JAVASCRIPT>
    <SCHEME>
    </SCHEME>
    </SNIPPET>
    </SOLUTION>
      </EXERCISE>

      <EXERCISE>
        <LABEL NAME="ex:8queens"/>

              <FIGURE>
                <FIGURE src="img_original/ch2-Z-G-23.gif"></FIGURE>
                <LABEL NAME="fig:8queens"/>
                <CAPTION>A solution to the eight-queens puzzle.
                </CAPTION>
              </FIGURE>
        The 
        <INDEX>eight-queens puzzle</INDEX><INDEX>chess, eight-queens puzzle</INDEX>
        <INDEX>puzzles<SUBINDEX>eight-queens puzzle</SUBINDEX></INDEX>
        <QUOTE>eight-queens puzzle</QUOTE> asks how to place eight queens on a
        chessboard so that no queen is in check from any other (i.e., no two
        queens are in the same row, column, or diagonal).  One possible
        solution is shown in Figure<SPACE/><REF NAME="fig:8queens"/>.  One way to solve the
        puzzle is to work across the board, placing a queen in each column.
        Once we have placed <LATEXINLINE>$k-1$</LATEXINLINE> queens, we must place the <LATEXINLINE>$k$</LATEXINLINE>th queen in a
        position where it does not check any of the queens already on the
        board.  We can formulate this approach recursively: Assume that we
        have already generated the sequence of all possible ways to place
        <LATEXINLINE>$k-1$</LATEXINLINE> queens in the first <LATEXINLINE>$k-1$</LATEXINLINE> columns of the board.  For each of
        these ways, generate an extended set of positions by placing a queen
        in each row of the <LATEXINLINE>$k$</LATEXINLINE>th column.  Now filter these, keeping only
        the positions for which the queen in the <LATEXINLINE>$k$</LATEXINLINE>th column is safe with
        respect to the other queens.  This produces the sequence of all ways
        to place <LATEXINLINE>$k$</LATEXINLINE> queens in the first <LATEXINLINE>$k$</LATEXINLINE> columns.  By continuing this
        process, we will produce not only one solution, but all solutions to
        the puzzle.

        We implement this solution as a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>queens</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>queens</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which returns
        a sequence of all solutions to the problem of placing <LATEXINLINE>$n$</LATEXINLINE> queens on an
        <LATEXINLINE>$n\times n$</LATEXINLINE> chessboard.  <SPLITINLINE><SCHEME><SCHEMEINLINE>Queens</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>queens</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> has an internal
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>queen-cols</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>queens_cols</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> that returns the sequence of all ways to place queens in
        the first <LATEXINLINE>$k$</LATEXINLINE> columns of the board.

        <SNIPPET HIDE="yes">
          <NAME>adjoin_position</NAME>
          <SCHEME>
;; procedure adjoin-position to be written by student
          </SCHEME>
          <JAVASCRIPT>
// function adjoin_position to be written by student
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>empty_board</NAME>
          <SCHEME>
;; procedure empty-board to be written by student
          </SCHEME>
          <JAVASCRIPT>
// function empty_board to be written by student
          </JAVASCRIPT>
        </SNIPPET>
        <SNIPPET HIDE="yes">
          <NAME>safe</NAME>
          <SCHEME>
;; procedure safe? to be written by student
          </SCHEME>
          <JAVASCRIPT>
// function is_safe to be written by student
          </JAVASCRIPT>
        </SNIPPET>

        <SNIPPET>
          <REQUIRES>adjoin_position</REQUIRES>
          <REQUIRES>empty_board</REQUIRES>
          <REQUIRES>safe</REQUIRES>
          <REQUIRES>flatmap</REQUIRES>
          <SCHEME>
            <!-- \indcode*{queens} -->
(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
      (list empty-board)
      (filter
        (lambda (positions) (safe? k positions))
        (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
          </SCHEME>
          <JAVASCRIPT>
function queeens(board_size) {
    function queen_cols(k) {
        return k === 0
               ? list(empty_board)
               : filter(positions
                        => is_safe(k, positions), 
                        flatmap(rest_of_queens
	                        => map(new_row
                                       => adjoin_position(new_row, k, 
				                          rest_of_queens), 
                                       enumerate_interval(1, board_size)), 
                                queens_cols(k-1)));
   }
   return queen_cols(board_size);
}
          </JAVASCRIPT>
        </SNIPPET>

        In this
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>rest-of-queens</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>rest_of_queens</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is a way to place <LATEXINLINE>$k-1$</LATEXINLINE> queens
        in the first <LATEXINLINE>$k-1$</LATEXINLINE> columns, and <SPLITINLINE><SCHEME><SCHEMEINLINE>new-row</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>new_row</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is a proposed row in
        which to place the queen for the <LATEXINLINE>$k$</LATEXINLINE>th column.  Complete the program
        by implementing the representation for sets of board positions, 
        including the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>adjoin-position</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>adjoin_position</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which adjoins a new row-column
        position to a set of positions, and <SPLITINLINE><SCHEME><SCHEMEINLINE>empty-board</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>empty_board</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which
        represents an empty set of positions.  You must also write the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>safe?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_safe</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which determines for a set of positions, 
        whether the queen in the <LATEXINLINE>$k$</LATEXINLINE>th column is safe with respect to the
        others.  (Note that we need only check whether the new queen is
        safe<EMDASH/>the other queens are already guaranteed safe with respect to
        each other.)
      </EXERCISE>

      <EXERCISE>
        Louis Reasoner is having a terrible time doing Exercise<SPACE/><REF NAME="ex:8queens"/>.  His
        <SPLITINLINE><SCHEME><SCHEMEINLINE>queens</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>queens</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        seems to work, but it runs extremely slowly.
        (Louis never does manage to wait long enough for it to solve even the
        <LATEXINLINE>$6\times 6$</LATEXINLINE> case.)  When Louis asks Eva Lu Ator for help, she points
        out that he has interchanged the order of the nested mappings in the
        <SPLITINLINE><SCHEME><SCHEMEINLINE>flatmap</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>flatmap</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, writing it as
        <SNIPPET EVAL="no">
          <SCHEME>
(flatmap
  (lambda (new-row)
    (map (lambda (rest-of-queens)
           (adjoin-position new-row k rest-of-queens))
         (queen-cols (- k 1))))
  (enumerate-interval 1 board-size))
          </SCHEME>
          <JAVASCRIPT>
flatmap(new_row 
        =>  map(rest_of_queens 
                => adjoin_position(new_row, k, rest_of_queens), 
                queen_cols(k-1)), 
        enumerate_interval(1, board_size));
        </JAVASCRIPT>
        </SNIPPET>

        Explain why this interchange makes the program run slowly.  Estimate
        how long it will take Louis<APOS/>s program to solve the eight-queens
        puzzle, assuming that the program in Exercise<SPACE/><REF NAME="ex:8queens"/> solves
        the puzzle in time <LATEXINLINE>$T$</LATEXINLINE>.
      </EXERCISE>
      <INDEX>sequence(s)<SUBINDEX>as conventional interface|)</SUBINDEX></INDEX>
      <INDEX>conventional interface<SUBINDEX>sequence as|)</SUBINDEX></INDEX>
      <INDEX>mapping<SUBINDEX>nested|)</SUBINDEX></INDEX>
      
    </SUBSECTION>

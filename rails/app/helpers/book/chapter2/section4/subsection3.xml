    <SUBSECTION>
      <NAME>
        Data-Directed Programming and Additivity
      </NAME>

      <LABEL NAME="sec:data-directed"/>
      <INDEX>data-directed programming|(</INDEX>
      <INDEX>additivity|(</INDEX>

      <TEXT>
      <INDEX>modularity<SUBINDEX>through dispatching on type</SUBINDEX></INDEX>
      The general strategy of checking the type of a datum and calling an
      appropriate
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      is called 
      <INDEX>dispatching<SUBINDEX>on type</SUBINDEX></INDEX>
      <INDEX>type(s)<SUBINDEX>dispatching on</SUBINDEX></INDEX>
      <EM>dispatching on type</EM>.  This is a
      powerful strategy for obtaining modularity in system design.  On
      the other hand, implementing the dispatch as in
      Section<SPACE/><REF NAME="sec:manifest-types"/> has two significant weaknesses.  One
      weakness is that the generic interface
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      (<SPLITINLINE><SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
      <SPLITINLINE><SCHEME><SCHEMEINLINE>imag-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>imag_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>magnitude</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>magnitude</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>angle</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>angle</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>) must know about all
      the different representations.  For instance, suppose we wanted to
      incorporate a new representation for complex numbers into our
      complex-number system.  We would need to identify this new
      representation with a type, and then add a clause to each of the
      generic interface
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      to check for the new type and apply the
      appropriate selector for that representation.
      </TEXT>
      <TEXT>
      Another weakness of the technique is that even though the individual
      representations can be designed separately, we must guarantee that
      no two
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      in the entire system have the same name.  This is
      why Ben and Alyssa had to change the names of their original
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      from Section<SPACE/><REF NAME="sec:representations-complex-numbers"/>.
      </TEXT>
      <TEXT>
      The issue underlying both of these weaknesses is that the technique
      for implementing generic interfaces is not <EM>additive</EM>.  The person
      implementing the generic selector
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      must modify those
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      each time a new representation is installed, and the people
      interfacing the individual representations must modify their
      code to avoid name conflicts.  In each of these cases, the changes
      that must be made to the code are straightforward, but they must be
      made nonetheless, and this is a source of inconvenience and error.
      This is not much of a problem for the complex-number system as it
      stands, but suppose there were not two but hundreds of different
      representations for complex numbers.  And suppose that there were many
      generic selectors to be maintained in the abstract-data interface.
      Suppose, in fact, that no one programmer knew all the interface
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      or all the representations.  The problem is real and must
      be addressed in such programs as large-scale data-base-management
      systems.
      </TEXT>
      <TEXT>
      What we need is a means for modularizing the system design even
      further.  This is provided by the programming technique known as <EM>
        data-directed programming</EM>.  To understand how data-directed
      programming works, begin with the observation that whenever we deal
      with a set of generic operations that are common to a set of
      different types we are, in effect, dealing with a two-dimensional
      table that contains the possible operations on one axis and the
      possible types on the other axis.  The entries in the table are the
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      that implement each operation for each type of argument
      presented.  In the complex-number system developed in the previous
      section, the correspondence between operation name, data type, and
      actual
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      was spread out among the various conditional clauses
      in the generic interface
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.  But the same information could
      have been organized in a table, as shown in
      Figure<SPACE/><REF NAME="fig:operator-table"/>.
      </TEXT>
      <TEXT>
      <INDEX>table<SUBINDEX>for data-directed programming</SUBINDEX></INDEX>
      Data-directed programming is the technique of designing programs to
      work with such a table directly.  Previously, we implemented the
      mechanism that interfaces the complex-arithmetic code with the two
      representation packages as a set of
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      that each perform an
      explicit dispatch on type.  Here we will implement the interface as a single
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      that looks up the combination of the operation name and
      argument type in
      the table to find the correct
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      to apply, and then applies it
      to the contents of the argument.  If we do this, then to add a new
      representation package to the system we need not change any existing
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>; we need only add new entries to the table.
      </TEXT>
      <TEXT>

        <FIGURE>
        <SPLIT>
          <SCHEME>
            <IMAGE src="img_original/ch2-Z-G-63.gif"/>
          </SCHEME>
          <JAVASCRIPT>
            <TREETAB>
              \begin{tabular}{|l|l|l|} \hline
              Operations       &amp; \multicolumn{2}{c}{Types} \\ \hline
                               &amp; Polar        &amp; Rectangular \\ \hline
              \verb#real_part# &amp; \verb#real_part_polar#                &amp; \verb#real_part_rectangular# \\
              \verb#imag_part# &amp; \verb#imag_part_polar#                &amp; \verb#imag_part_rectangular# \\
              \verb#magnitude# &amp; \verb#magnitude_polar#                &amp; \verb#magnitude_rectangular# \\
              \verb#angle#     &amp; \verb#angle_polar#                    &amp; \verb#angle_rectangular# \\ \hline
              \end{tabular}
            </TREETAB>
          </JAVASCRIPT>
        </SPLIT>
          <CAPTION>Table of operations for the complex-number system.</CAPTION>
          <LABEL NAME="fig:operator-table"/>
        </FIGURE>

      To implement this plan, assume that we have two
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>,
      <SPLITINLINE><SCHEME><SCHEMEINLINE>put</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>put</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>get</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, for manipulating the 
      operation-and-type table:
      <INDEX>operation-and-type table</INDEX>

      <UL>
        <!-- \indcode{put} -->
        <LI><SPLITINLINE><SCHEME><SCHEMEINLINE>(put </SCHEMEINLINE><LATEXINLINE>$\langle \textit{op} \rangle\ \langle \textit{type} \rangle \ \langle \textit{item} \rangle$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>put(</JAVASCRIPTINLINE><LATEXINLINE>$\langle \textit{op} \rangle, \langle \textit{type} \rangle, \langle \textit{item} \rangle$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE><BREAK/>
        installs the <LATEXINLINE>$\langle \textit{item} \rangle$</LATEXINLINE> in the table, indexed by the
          <LATEXINLINE>$\langle \textit{op} \rangle$</LATEXINLINE> and the 
          <LATEXINLINE>$\langle \textit{type} \rangle$</LATEXINLINE>.
          <!-- \indcode{get} -->
        </LI>
        <LI><SPLITINLINE><SCHEME><SCHEMEINLINE>(get </SCHEMEINLINE><LATEXINLINE>$\langle \textit{op} \rangle\ \langle \textit{type}$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get(</JAVASCRIPTINLINE><LATEXINLINE>$\langle \textit{op} \rangle, \langle \textit{type} \rangle$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE><BREAK/>
          looks up the 
          <LATEXINLINE>$\langle \textit{op} \rangle$</LATEXINLINE>,
          <LATEXINLINE>$\langle \textit{type} \rangle$</LATEXINLINE>
          entry in the table
          and returns the item found there.  If no item is found, <SPLITINLINE><SCHEME><SCHEMEINLINE>get</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
          returns false.
        </LI>
      </UL>

      For now, we can assume that <SPLITINLINE><SCHEME><SCHEMEINLINE>put</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>put</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>get</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> are
      included in our language.  In Chapter<SPACE/>3 (Section<SPACE/><REF NAME="sec:tables"/>)
      we will see how to implement these and
      other operations for manipulating tables.
      </TEXT>
      <TEXT>
      Here is how data-directed programming can be used in the
      complex-number system.  Ben, who developed the rectangular
      representation, implements his code just as he did originally.  He defines a collection of
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>, or a 
      <INDEX>package</INDEX>
      <EM>package</EM>, and interfaces
      these to the rest of the system by adding entries to the table that
      tell the system how to operate on rectangular numbers.
      This is accomplished by calling the following
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>:
      <INDEX>package<SUBINDEX>rectangular representation</SUBINDEX></INDEX>
      <!--\indcodeplus{rectangular}{package}-->

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{install-rectangular-package} -->
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
        </SCHEME>
        <JAVASCRIPT>
function install_rectangular_package() {
   function real_part(z) { return head(z); }
   function imag_part(z) { return tail(z); }
   function make_from_real_imag(x,y) { return pair(x,y); }
   function magnitude(z) {
      return sqrt(square(real_part(z)) +
                  square(imag_part(z)));
   }
   function angle(z) {
      return atan(imag_part(z),real_part(z));
   }
   function make_from_mag_ang(r,a) {
      return pair(r * cos(a), r * sin(a));
   }
   // interface to the rest of the system
   function tag(x) {
      return attach_tag("rectangular",x);
   }
   put("real_part", list("rectangular"), real_part);
   put("imag_part", list("rectangular"), imag_part);
   put("magnitude", list("rectangular"), magnitude);
   put("angle", list("rectangular"), angle);
   put("make_from_real_imag", "rectangular",
       function(x,y) { return tag(make_from_real_imag(x,y)); });
   put("make_from_mag_ang", "rectangular",
       function(r,a) { return tag(make_from_mag_ang(r,a)); });
   return "done";
}
        </JAVASCRIPT>     
      </SNIPPET>

      Notice that the internal
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      here are the same
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      from
      Section<SPACE/><REF NAME="sec:representations-complex-numbers"/> that Ben wrote when
      he was working in isolation.  No changes are necessary in order to
      interface them to the rest of the system.  Moreover, since these
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      definitions are internal to the installation
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, Ben
      needn<APOS/>t worry about name conflicts with other
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      outside the
      rectangular package.  To interface these to the rest of the system,
      Ben installs his <SPLITINLINE><SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      under the operation name
      <SPLITINLINE><SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and the type <SPLITINLINE><SCHEME><SCHEMEINLINE>(rectangular)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list("rectangular")</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and similarly
      for the other selectors.<FOOTNOTE>We use the list <SPLITINLINE><SCHEME><SCHEMEINLINE>(rectangular)</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>list("rectangular")</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        rather than the <SPLITINLINE><SCHEME>symbol <SCHEMEINLINE>rectangular</SCHEMEINLINE></SCHEME><JAVASCRIPT>string <JAVASCRIPTINLINE>"rectangular"</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> to allow for the possibility
        of operations with multiple arguments, not all of the same
        type.</FOOTNOTE>  The interface also defines
      the constructors to be used by the external system.<FOOTNOTE>The
        type the constructors are installed under needn<APOS/>t be a list because
        a constructor is always used to make an object of one particular
        type.</FOOTNOTE>
      These are
      identical to Ben<APOS/>s internally defined constructors, except that they
      attach the tag.

      <INDEX>package<SUBINDEX>polar representation</SUBINDEX></INDEX>
      <!--\indcodeplus{polar}{package}-->
      Alyssa<APOS/>s polar package is analogous:
      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{install-polar-package} -->
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
        </SCHEME>
        <JAVASCRIPT>
function install_polar_package() {
   // internal functions
   function magnitude(z) { return head(z); }
   function angle(z) { return tail(z); }
   function make_from_mag_ang(r,a) { return pair(r,a); }
   function real_part(z) {
      return magnitude(z) * cos(angle(z));
   }
   function imag_part(z) {
      return magnitude(z) * sin(angle(z));
   }
   function make_from_real_imag(x,y) {
      return pair(sqrt(square(x) + square(y)),
                  atan(y,x));
   }

   // interface to teh rest of the system
   function tag(x) { return attach_tag("polar",x); }
   put("real_part",list("polar"),real_part);
   put("imag_part",list("polar"),imag_part);
   put("magnitude",list("polar"),magnitude);
   put("angle",list("polar"),angle);
   put("make_from_real_imag", "polar",
       function(x,y) { return tag(make_from_real_imag(x,y)); });
   put("make_from_mag_ang", "polar",
       function(r,a) { return tag(make_from_mag_ang(r,a)); });
}
        </JAVASCRIPT>
      </SNIPPET>
      </TEXT>
      <TEXT>
      Even though Ben and Alyssa both still use their original
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      defined with the same names as each other<APOS/>s (e.g., <SPLITINLINE><SCHEME><SCHEMEINLINE>real-part</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>real_part</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>), these 
      definitions are now internal to different
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
      (see
      Section<SPACE/><REF NAME="sec:block-structure"/>), so there is no name
      conflict.
      </TEXT>
      <TEXT>
      The complex-arithmetic selectors access the table by means of a
      general <QUOTE>operation</QUOTE>
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      called <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, which
      applies a generic operation to some arguments.  <SPLITINLINE><SCHEME><SCHEMEINLINE>Apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
      looks in the table under the name of the operation and the types of the
      arguments and applies the resulting
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      if one is present:<FOOTNOTE><SPLITINLINE><SCHEME><SCHEMEINLINE>Apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> uses the 
        <INDEX>dotted-tail notation<SUBINDEX><SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>@for
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            parameters</SUBINDEX></INDEX>
        dotted-tail notation described in
        Exercise<SPACE/><REF NAME="ex:dotted-arglist"/>, because different generic operations
        may take different numbers of arguments.  In <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>op</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>op</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> has as its value the first argument to <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and
        <SPLITINLINE><SCHEME><SCHEMEINLINE>args</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>args</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> has as its value a list of the remaining arguments.
        <BREAK/>
        <SPLITINLINE><SCHEME><SCHEMEINLINE>Apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> also uses the primitive
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>

        <!--\indprim*{apply}-->
        <!--\ind*{primitive
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            (those marked <EM>ns</EM> are not in the IEEE Scheme standard)}[apply@<SCHEMEINLINE>apply</SCHEMEINLINE>]
            -->
        <SPLITINLINE><SCHEME><SCHEMEINLINE>apply</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>,
        which takes two arguments, a
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        and a list.  <SPLITINLINE><SCHEME><SCHEMEINLINE>Apply</SCHEMEINLINE></SCHEME><JAVASCRIPT>The function <JAVASCRIPTINLINE>apply</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        applies the
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, using the elements in the list as arguments.
        For example,
        <SNIPPET>
          <SCHEME>
(apply + (list 1 2 3 4))
          </SCHEME>
          <JAVASCRIPT>
apply(sum_of_squares,list(1,3))
        </JAVASCRIPT>
        </SNIPPET>
        returns 10.</FOOTNOTE>

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{apply-generic} -->
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply proc (map contents args))
        (error
          "No method for these types -- APPLY-GENERIC"
          (list op type-tags))))))
        </SCHEME>
        <JAVASCRIPT>
function apply_generic(op,args) {
   var type_tags = map(type_tag,args);
   var fun = get(op,type_tags);
   if (fun != false)
      return fun(map(contents,args));
   else
      return error("No method for these types -- apply_generic",
                   list(op,type_tags));
}
        </JAVASCRIPT>
      </SNIPPET>
      Using <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, we can define our generic selectors as follows:

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{real-part}[data-directed] -->
(define (real-part z) (apply-generic 'real-part z))
          <!-- \indcode*{imag-part}[data-directed] -->
(define (imag-part z) (apply-generic 'imag-part z))
          <!-- \indcode*{magnitude}[data-directed] -->
(define (magnitude z) (apply-generic 'magnitude z))
          <!-- \indcode*{angle}[data-directed] -->
(define (angle z) (apply-generic 'angle z))
        </SCHEME>
        <JAVASCRIPT>
function real_part(z) {
   return apply_generic("real_part",list(z));
}
function imag_part(z) {
   return apply_generic("imag_part",list(z));
}
function magnitude(z) {
   return apply_generic("magnitude",list(z));
}
function angle(z) {
   return apply_generic("angle",list(z));
}
        </JAVASCRIPT>
      </SNIPPET>

      Observe that these do not change at all if a new representation is
      added to the system.
      </TEXT>
      <TEXT>
      We can also extract from the table the
      constructors to be used by the programs external to the packages in
      making complex numbers from real and imaginary parts and from
      magnitudes and angles.
      As in Section<SPACE/><REF NAME="sec:manifest-types"/>, we
      construct rectangular numbers whenever we have real and
      imaginary parts, and polar numbers whenever we have magnitudes and angles:

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{make-from-real-imag} -->
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))

          <!-- \indcode*{make-from-mag-ang} -->
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
        </SCHEME>
        <JAVASCRIPT>
function make_from_real_imag(x,y) {
   return get("make_from_real_imag","rectangular")(x,y);
}
function make_from_mag_ang(r,a) {
   return get("make_from_mag_ang","polar")(r,a);
}
        </JAVASCRIPT>
      </SNIPPET>
      </TEXT>

      <EXERCISE>
        Section<SPACE/><REF NAME="sec:symbolic-differentiation"/> described a program that
        performs symbolic differentiation:
        <INDEX>symbolic differentiation</INDEX>
        <INDEX>differentiation<SUBINDEX>symbolic</SUBINDEX></INDEX>
        <SNIPPET>
          <SCHEME>
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
          (make-sum (deriv (addend exp) var)
                    (deriv (augend exp) var)))
        ((product? exp)
          (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
        ;; more rules can be added here
        (else (error "unknown expression type -- DERIV" exp))))
          </SCHEME>
          <JAVASCRIPT>
function deriv(exp,var) {
   if (is_number(exp))
      return 0;
   else if (is_variable(exp))
      return (is_same_variable(exp,var)) ? 1 : 0;
   else if (is_sum(exp))
      return make_sum(deriv(addend(exp),var),
                      deriv(augend(exp),var));
   else if (is_product(exp)) 
      return make_sum(make_product(multiplier(exp),
                                   deriv(multiplicand(exp),variable)),
                      make_product(deriv(multiplier(exp),variable),
                                   multiplicand(exp)));
   // more rules can be added here
   else
      return error("unknown expression type -- deriv",exp);
}
        </JAVASCRIPT>
        </SNIPPET>

        We can regard this program as performing a dispatch on the type of the
        expression to be differentiated.  In this situation the <QUOTE>type tag</QUOTE> of the
          datum is the algebraic operator symbol (such as <LATEXINLINE>+</LATEXINLINE>) and the
          operation being performed is <SPLITINLINE><SCHEME><SCHEMEINLINE>deriv</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>deriv</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  We can transform this
        program into data-directed style by rewriting the basic derivative
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        as
        <SNIPPET>
          <SCHEME>
            <!--\indcodeplus*{deriv}{(symbolic)}[data-directed]-->
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp)
                                           var))))

(define (operator exp) (car exp))

(define (operands exp) (cdr exp))
          </SCHEME>
          <JAVASCRIPT>
function deriv(exp,var) {
   if (is_number(exp))
      return 0;
   else if (is_variable(exp))
      return (is_same_variable(exp,var)) ? 1 : 0;
   else
      return get("deriv",operator(exp))(operands(exp),var);
}
function operator(exp) {
   return head(exp);
}
function operands(exp) {
   return tail(exp);
}
        </JAVASCRIPT>
        </SNIPPET>

        <OL>
          <LI>
            Explain what was done above.
            Why can<APOS/>t we assimilate the predicates <SPLITINLINE><SCHEME><SCHEMEINLINE>number?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_number</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>same-variable?</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>is_same_variable</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> into the data-directed dispatch?
          </LI>
          <LI>
            Write the
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            for derivatives of sums and products, and the
            auxiliary code required to install them in the table used by the
            program above.
          </LI>
          <LI>
            Choose any additional differentiation rule that you like, such as
            the one for exponents (Exercise<SPACE/><REF NAME="ex:deriv-exponentiation"/>),
            and install it in this data-directed system.
          </LI>
          <LI>
            In this simple algebraic manipulator the type of an expression is
            the algebraic operator that binds it together.  Suppose, however, we
            indexed the
            <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
            in the opposite way, so that the dispatch line
            in <SPLITINLINE><SCHEME><SCHEMEINLINE>deriv</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>deriv</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> looked like

            <SNIPPET>
              <SCHEME>
((get (operator exp) 'deriv) (operands exp) var)
              </SCHEME>
              <JAVASCRIPT>
get(operator(exp),"deriv")(operands(exp),var)
            </JAVASCRIPT>
            </SNIPPET>

            What corresponding changes to the derivative system are required?
          </LI>
        </OL>
        <LABEL NAME="ex:data-directed-differentiation"/>
      </EXERCISE>

      <EXERCISE> 
        <INDEX>data base<SUBINDEX>data-directed programming and</SUBINDEX></INDEX>
        <INDEX>data base<SUBINDEX>Insatiable Enterprises personnel</SUBINDEX></INDEX>
        Insatiable Enterprises, Inc., is a highly decentralized conglomerate
        company consisting of a large number of independent divisions located
        all over the world.  The company<APOS/>s computer facilities have just been
        interconnected by means of a clever network-interfacing scheme that
        makes the entire network appear to any user to be a single computer.
        Insatiable<APOS/>s president, in her first attempt to exploit the ability of
        the network to extract administrative information from division files,
        is dismayed to discover that, although all the division files have
        been implemented as data structures in Scheme, the particular data
        structure used varies from division to division.  A meeting of
        division managers is hastily called to search for a strategy to
        integrate the files that will satisfy headquarters<APOS/> needs while
        preserving the existing autonomy of the divisions.

        Show how such a strategy can be implemented with data-directed
        programming.  As an example, suppose that each division<APOS/>s personnel
        records consist of a single file, which contains a set of records
        keyed on employees<APOS/> names.  The structure of the set varies from
        division to division.  Furthermore, each employee<APOS/>s record is itself a
        set (structured differently from division to division) that contains
        information keyed under identifiers such as <SPLITINLINE><SCHEME><SCHEMEINLINE>address</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>address</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> and <SPLITINLINE><SCHEME><SCHEMEINLINE>salary</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>salary</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.  In particular:
        <OL>
          <LI>
            Implement for headquarters a <SPLITINLINE><SCHEME><SCHEMEINLINE>get-record</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get_record</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            that
            retrieves a specified employee<APOS/>s record from a specified personnel
            file.  The
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            should be applicable to any division<APOS/>s file.
            Explain how the individual divisions<APOS/> files should be structured.  In
            particular, what type information must be supplied?
          </LI>
          <LI>
            Implement for headquarters a <SPLITINLINE><SCHEME><SCHEMEINLINE>get-salary</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>get_salary</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            that
            returns the salary information from a given employee<APOS/>s record from any
            division<APOS/>s personnel file.  How should the record be structured in
            order to make this operation work?
          </LI>
          <LI>
            Implement for headquarters a <SPLITINLINE><SCHEME><SCHEMEINLINE>find-employee-record</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>find_employee_record</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.
            This should search all the divisions<APOS/> files for the record of a given
            employee and return the record.  Assume that this
            <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
            takes as
            arguments an employee<APOS/>s name and a list of all the divisions<APOS/> files.
          </LI>
          <LI>
            When Insatiable takes over a new company, what changes must
            be made in order to incorporate the new personnel information into the
            central system?
          </LI>
        </OL>
      </EXERCISE>
      <INDEX>data-directed programming|)</INDEX>
      <INDEX>additivity|)</INDEX>


      <SUBHEADING>
        <NAME>Message passing</NAME>
      </SUBHEADING>

      <INDEX>message passing|(</INDEX>

      <TEXT>
      The key idea of data-directed programming is to handle generic
      operations in programs by dealing explicitly with operation-and-type
      tables, such as the table in Figure<SPACE/><REF NAME="fig:operator-table"/>.  The
      style of programming we used in Section<SPACE/><REF NAME="sec:manifest-types"/>
      organized the required dispatching on type by having each operation
      take care of its own dispatching.  In effect, this decomposes the
      operation-and-type table into rows, with each generic operation
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      representing a row of the table.
      </TEXT>
      <TEXT>
      An alternative implementation strategy is to decompose the table into
      columns and, instead of using <QUOTE>intelligent operations</QUOTE> that dispatch
      on data types, to work with <QUOTE>intelligent data objects</QUOTE> that dispatch
      on operation names.  We can do this by arranging things so that a data
      object, such as a rectangular number, is represented as a
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      that takes as input the required operation name and performs the
      operation indicated.  In such a discipline, <SPLITINLINE><SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
      could be written as

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{make-from-real-imag}[message-passing] -->
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
            (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
            (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
  dispatch)
        </SCHEME>
        <JAVASCRIPT>
function make_from_real_imag(x,y) {
   function dispatch(op) {
      if (op === "real_part")
         return x;
      else if (op === "imag_part")
         return y;
      else if (op === "magnitude")
         return sqrt(square(x) + square(y));
      else if (op === "angle")
         return atan(y,x);
      else
         return error("Unknown op -- make_from_real_imag",op);
  }
  return dispatch;
}
        </JAVASCRIPT>
      </SNIPPET>

      The corresponding <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, which applies a
      generic operation to an argument, now simply feeds the operation<APOS/>s
      name to the data object and lets the object do the work:<FOOTNOTE>One
        limitation of this organization is it permits only generic
        <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
        of one argument.</FOOTNOTE>

      <SNIPPET>
        <SCHEME>
          <!-- \indcode*{apply-generic}[with message passing] -->
(define (apply-generic op arg) (arg op))
        </SCHEME>
        <JAVASCRIPT>
function apply_generic(op,arg) {
   return head(arg)(op);
}
        </JAVASCRIPT>
      </SNIPPET>

      Note that the value returned by <SPLITINLINE><SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> is a
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><EMDASH/>the internal <SPLITINLINE><SCHEME><SCHEMEINLINE>dispatch</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>dispatch</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>.  This is the
      <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
      that is invoked when <SPLITINLINE><SCHEME><SCHEMEINLINE>apply-generic</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>apply_generic</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> requests an operation to
      be performed.
      </TEXT>
      <TEXT>
      This style of programming is called <EM>message passing</EM>.  The name
      comes from the image that a data object is an entity that receives the
      requested operation name as a <QUOTE>message.</QUOTE>  We have already seen an
      example of message passing in Section<SPACE/><REF NAME="sec:data?"/>, where we saw
      how <SPLITINLINE><SCHEME><SCHEMEINLINE>cons</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, <SPLITINLINE><SCHEME><SCHEMEINLINE>car</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>head</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>, and <SPLITINLINE><SCHEME><SCHEMEINLINE>cdr</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>tail</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE> could be defined with no data
      objects but only
      <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>.  Here we see that message passing is not
      a mathematical trick but a useful technique for organizing systems
      with generic operations.  In the remainder of this chapter we will
      continue to use data-directed programming, rather than message
      passing, to discuss generic arithmetic operations.  In Chapter<SPACE/>3 we
      will return to message passing, and we will see that it can be a
      powerful tool for structuring simulation programs.
      </TEXT>

      <EXERCISE>
        <!-- \indcode*{make-from-mag-ang}[message-passing] -->
        Implement the constructor <SCHEMEINLINE>make-from-mag-ang</SCHEMEINLINE> in message-passing style.
        This
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        should be analogous to the <SPLITINLINE><SCHEME><SCHEMEINLINE>make-from-real-imag</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>make_from_real_imag</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>
        <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
        given above.
      </EXERCISE>

      <EXERCISE>
        <INDEX>dispatching<SUBINDEX>comparing different styles</SUBINDEX></INDEX>
        As a large system with generic operations evolves, new types of data
        objects or new operations may be needed.  For each of the three
        strategies<EMDASH/>generic operations with explicit dispatch, data-directed
        style, and message-passing-style<EMDASH/>describe the changes that must be
        made to a system in order to add new types or new operations.  Which
        organization would be most appropriate for a system in which new types
        must often be added?  Which would be most appropriate for a system in
        which new operations must often be added?
        <LABEL NAME="ex:extend-generic"/>
      </EXERCISE>

    </SUBSECTION>